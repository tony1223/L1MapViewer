using System;
using System.Collections.Generic;
using System.Diagnostics;
// using System.Drawing; // Replaced with Eto.Drawing
// using System.Drawing.Imaging; // Replaced with SkiaSharp
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Eto.Forms;
using Eto.Drawing;
using L1MapViewer;
using L1MapViewer.CLI;
using L1MapViewer.Controls;
using L1MapViewer.Converter;
using L1MapViewer.Helper;
using L1MapViewer.Localization;
using L1MapViewer.Models;
using L1MapViewer.Other;
using L1MapViewer.Reader;
using Lin.Helper.Core.Sprite;
using Lin.Helper.Core.Pak;
using L1MapViewer.Compatibility;
using flyworld.eto.component;
using NLog;

namespace L1FlyMapViewer
{
    public partial class MapForm : Form, IMapViewer
    {
        // Logger
        private static readonly Logger _logger = LogManager.GetCurrentClassLogger();

        // ===== Model 層 =====
        /// <summary>
        /// 地圖文件 Model - 管理所有 S32 資料
        /// </summary>
        private readonly MapDocument _document = new MapDocument();

        /// <summary>
        /// 編輯狀態 Model - 管理選取、剪貼簿、Undo
        /// </summary>
        private readonly EditState _editState = new EditState();

        /// <summary>
        /// 檢視狀態 Model - 管理縮放、捲動、顯示選項
        /// </summary>
        private readonly ViewState _viewState = new ViewState();

        /// <summary>
        /// 互動狀態 Model - 管理拖曳、選取等互動狀態
        /// </summary>
        private readonly InteractionState _interaction = new InteractionState();

        /// <summary>
        /// 渲染快取 Model - 管理 Bitmap 和 Tile 資料快取
        /// </summary>
        private readonly RenderCache _renderCache = new RenderCache();

        // Layer8 動畫 Timer（快取已移至 _renderCache）
        private Timer _layer8AnimTimer;

        // IMapViewer 介面實作 - 明確公開控制項屬性
        ComboBox IMapViewer.comboBox1 => this.comboBox1;
        PictureBox IMapViewer.pictureBox1 => this.pictureBox1;
        PictureBox IMapViewer.pictureBox2 => this.pictureBox2;
        PictureBox IMapViewer.pictureBox3 => this.pictureBox3;
        PictureBox IMapViewer.pictureBox4 => this.pictureBox4;
        VScrollBar IMapViewer.vScrollBar1 => this.vScrollBar1;
        HScrollBar IMapViewer.hScrollBar1 => this.hScrollBar1;
        ToolStripProgressBar IMapViewer.toolStripProgressBar1 => this.toolStripProgressBar1;
        ToolStripStatusLabel IMapViewer.toolStripStatusLabel1 => this.toolStripStatusLabel1;
        ToolStripStatusLabel IMapViewer.toolStripStatusLabel2 => this.toolStripStatusLabel2;
        ToolStripStatusLabel IMapViewer.toolStripStatusLabel3 => this.toolStripStatusLabel3;
        Eto.Forms.Control IMapViewer.panel1 => this.panel1;

        private const int DRAG_THRESHOLD = 5;

        // 縮放相關（地圖預覽）
        [System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]
        public double zoomLevel { get; set; } = 1.0;
        private const double ZOOM_MIN = 0.5;
        private const double ZOOM_MAX = 5.0;
        private const double ZOOM_STEP = 0.2;
        private Image originalMapImage;

        // S32 編輯器縮放相關（統一使用 _viewState.ZoomLevel）
        private Image originalS32Image;

        // MiniMapControl（取代原本的 PictureBox 和渲染邏輯）
        private L1MapViewer.Controls.MiniMapControl _miniMapControl;

        // 狀態列控件引用 (用於同步狀態)
        private Eto.Forms.Button _statusBtnCopyMoveCmd;
        private Eto.Forms.TextBox _statusTxtJump;

        // 圖層切換防抖Timer
        private Timer renderDebounceTimer;

        // 拖曳結束後延遲渲染 Timer
        private Timer dragRenderTimer;

        // 素材貼上預覽狀態
        private Fs3pData _pendingMaterial = null;
        private string _pendingMaterialPath = null;

        // 效能 Log 檔案路徑（開關由 Program.PerfLogEnabled 控制，啟動時加 --perf-log）
        private static readonly string _perfLogPath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "perf.log");
        private static void LogPerf(string message)
        {
            if (!L1MapViewerCore.Program.PerfLogEnabled) return;
            string timestamp = DateTime.Now.ToString("HH:mm:ss.fff");
            string elapsed = $"+{L1MapViewerCore.Program.StartupStopwatch.ElapsedMilliseconds}ms";
            string line = $"{timestamp} {elapsed,-10} {message}";
            Console.WriteLine(line);
            try { File.AppendAllText(_perfLogPath, line + Environment.NewLine); } catch { }
        }

        // 通行性編輯模式
        private enum PassableEditMode
        {
            None,           // 無編輯模式
            Editing         // 通行編輯模式（選取區域後右鍵設定）
        }
        private PassableEditMode currentPassableEditMode = PassableEditMode.None;
        private Label lblPassabilityHelp; // 通行性編輯操作說明標籤

        // 區域編輯模式
        private RegionEditMode currentRegionEditMode = RegionEditMode.None;
        private RegionType currentRegionType = RegionType.Normal;
        private Label lblRegionHelp; // 區域編輯操作說明標籤
        private Button btnRegionNormal;  // 一般區域按鈕
        private Button btnRegionSafe;    // 安全區域按鈕
        private Button btnRegionCombat;  // 戰鬥區域按鈕

        // Layer5 透明編輯模式（狀態存於 _editState.IsLayer5EditMode）
        private Label lblLayer5Help; // Layer5 編輯操作說明標籤

        // 預設操作提示標籤
        private Label lblDefaultHint;

        // Undo 相關常數
        private const int MAX_UNDO_HISTORY = 5;

        // 拖曳相關狀態 - 已移至 _interaction

        // 拖曳效能監控
        private int _dragMoveCount = 0;
        private int _dragPaintCount = 0;
        private Stopwatch _dragSessionSw = new Stopwatch();

        // Viewport 和 Tile 快取 - 已移至 _renderCache

        // list.til 快取 - 儲存 Tile.pak 中 list.til 記錄的最大 TileId 數字
        private int? _listTilMaxId = null;

        /// <summary>
        /// 預載入地圖用到的所有 tile 檔案（背景執行）
        /// </summary>
        private void PreloadTilesAsync(IEnumerable<S32Data> s32Files)
        {
            Task.Run(() =>
            {
                var sw = Stopwatch.StartNew();

                // 收集所有用到的 tileId
                var tileIds = new HashSet<int>();
                foreach (var s32 in s32Files)
                {
                    // Layer1
                    for (int y = 0; y < 64; y++)
                    {
                        for (int x = 0; x < 128; x++)
                        {
                            var cell = s32.Layer1[y, x];
                            if (cell != null && cell.TileId >= 0)
                                tileIds.Add(cell.TileId);
                        }
                    }
                    // Layer4
                    foreach (var obj in s32.Layer4)
                    {
                        if (obj.TileId > 0)
                            tileIds.Add(obj.TileId);
                    }
                }

                // 並行載入所有 til 檔案
                int loadedCount = 0;
                System.Threading.Tasks.Parallel.ForEach(tileIds, tileId =>
                {
                    TileProvider.Instance.Preload(tileId);
                    System.Threading.Interlocked.Increment(ref loadedCount);
                });

                sw.Stop();
                LogPerf($"[PRELOAD] Loaded {loadedCount} til files in {sw.ElapsedMilliseconds}ms");
            });
        }

        /// <summary>
        /// 建立 S32 空間索引，用於快速查找指定區域內的 S32 檔案
        /// </summary>
        private void BuildS32SpatialIndex()
        {
            var sw = Stopwatch.StartNew();
            _s32SpatialIndex.Clear();

            int blockWidth = 64 * 24 * 2;   // 3072
            int blockHeight = 64 * 12 * 2;  // 1536

            foreach (var kvp in _document.S32Files)
            {
                string filePath = kvp.Key;
                S32Data s32Data = kvp.Value;

                int[] loc = s32Data.SegInfo.GetLoc(1.0);
                int mx = loc[0];
                int my = loc[1];

                // 計算這個 S32 block 覆蓋的格子範圍
                int minGridX = mx / SPATIAL_GRID_SIZE;
                int minGridY = my / SPATIAL_GRID_SIZE;
                int maxGridX = (mx + blockWidth - 1) / SPATIAL_GRID_SIZE;
                int maxGridY = (my + blockHeight - 1) / SPATIAL_GRID_SIZE;

                // 將 S32 加入所有覆蓋的格子
                for (int gx = minGridX; gx <= maxGridX; gx++)
                {
                    for (int gy = minGridY; gy <= maxGridY; gy++)
                    {
                        var key = (gx, gy);
                        if (!_s32SpatialIndex.TryGetValue(key, out var list))
                        {
                            list = new List<string>();
                            _s32SpatialIndex[key] = list;
                        }
                        list.Add(filePath);
                    }
                }
            }

            sw.Stop();
            LogPerf($"[SPATIAL-INDEX] Built index for {_document.S32Files.Count} S32 files, {_s32SpatialIndex.Count} grid cells, in {sw.ElapsedMilliseconds}ms");
        }

        /// <summary>
        /// 建立 Layer4 空間索引，用於快速查找附近的 Layer4 物件
        /// </summary>
        private void BuildLayer4SpatialIndex()
        {
            try
            {
                _layer4SpatialIndex.Build(_document.S32Files.Values);
                LogPerf($"[LAYER4-INDEX] Built index for {_layer4SpatialIndex.TotalObjects:N0} objects, {_layer4SpatialIndex.GridCellCount:N0} grid cells, {_layer4SpatialIndex.GroupCount:N0} groups, in {_layer4SpatialIndex.BuildTimeMs}ms");
            }
            catch (Exception ex)
            {
                LogPerf($"[LAYER4-INDEX] ERROR: {ex.Message}");
                Console.WriteLine($"BuildLayer4SpatialIndex error: {ex}");
            }
        }

        /// <summary>
        /// 使用空間索引快速查找與指定區域相交的 S32 檔案
        /// </summary>
        private HashSet<string> GetS32FilesInRect(Rectangle worldRect)
        {
            var result = new HashSet<string>();

            // 計算 worldRect 覆蓋的格子範圍
            int minGridX = worldRect.X / SPATIAL_GRID_SIZE;
            int minGridY = worldRect.Y / SPATIAL_GRID_SIZE;
            int maxGridX = (worldRect.Right - 1) / SPATIAL_GRID_SIZE;
            int maxGridY = (worldRect.Bottom - 1) / SPATIAL_GRID_SIZE;

            // 收集所有可能相交的 S32
            for (int gx = minGridX; gx <= maxGridX; gx++)
            {
                for (int gy = minGridY; gy <= maxGridY; gy++)
                {
                    if (_s32SpatialIndex.TryGetValue((gx, gy), out var list))
                    {
                        foreach (var filePath in list)
                        {
                            result.Add(filePath);
                        }
                    }
                }
            }

            return result;
        }

        // S32 Block 渲染快取 - 已移至 _renderCache

        // 記錄已經繪製到 viewport bitmap 的 S32 檔案路徑（用於增量渲染）
        private HashSet<string> _renderedS32Blocks = new HashSet<string>();

        // S32 空間索引 - key: (gridX, gridY), value: 該格子內的 S32 檔案路徑列表
        // 每個 S32 block 大小為 3072x1536，使用此索引可快速查找 worldRect 內的 S32
        private Dictionary<(int gridX, int gridY), List<string>> _s32SpatialIndex = new Dictionary<(int, int), List<string>>();
        private const int SPATIAL_GRID_SIZE = 3072;  // 與 S32 block 寬度相同

        // Layer4 空間索引 - 用於快速查找附近的 Layer4 物件
        private Layer4SpatialIndex _layer4SpatialIndex = new Layer4SpatialIndex();

        #region Layer4 Spatial Index Helpers

        /// <summary>
        /// 增量新增單個 Layer4 物件到空間索引
        /// </summary>
        private void Layer4Index_Add(S32Data s32Data, ObjectTile obj)
        {
            _layer4SpatialIndex.AddObject(s32Data, obj);
        }

        /// <summary>
        /// 增量新增多個 Layer4 物件到空間索引
        /// </summary>
        private void Layer4Index_AddRange(S32Data s32Data, IEnumerable<ObjectTile> objects)
        {
            _layer4SpatialIndex.AddObjects(s32Data, objects);
        }

        /// <summary>
        /// 增量移除單個 Layer4 物件從空間索引
        /// </summary>
        private void Layer4Index_Remove(S32Data s32Data, ObjectTile obj)
        {
            _layer4SpatialIndex.RemoveObject(s32Data, obj);
        }

        /// <summary>
        /// 增量移除多個 Layer4 物件從空間索引
        /// </summary>
        private void Layer4Index_RemoveRange(S32Data s32Data, IEnumerable<ObjectTile> objects)
        {
            _layer4SpatialIndex.RemoveObjects(s32Data, objects);
        }

        #endregion

        // 勾選的 S32 檔案快取（避免每次渲染都遍歷 UI）
        private HashSet<string> _checkedS32Files = new HashSet<string>();

        // 地圖過濾相關
        private List<string> allMapItems = new List<string>();  // 所有地圖項目
        private bool isFiltering = false;  // 防止過濾時觸發 SelectedIndexChanged

        public MapForm()
        {
            LogPerf("[FORM-CTOR] Start");
            InitializeComponent();
            this.AllowDrop = true;  // 允許從 Explorer 拖放檔案
            this.DragEnter += lvMaterials_DragEnter;
            this.DragOver += lvMaterials_DragOver;
            this.DragDrop += lvMaterials_DragDrop;
            LogPerf("[FORM-CTOR] InitializeComponent done");

            // 初始化渲染防抖Timer（50ms延遲，減少等待時間）
            renderDebounceTimer = new Timer();
            renderDebounceTimer.Interval = 50;
            renderDebounceTimer.Tick += (s, e) =>
            {
                var sw = Stopwatch.StartNew();
                _logger.Debug("[RENDER-DEBOUNCE] Timer tick, calling RenderS32Map");
                renderDebounceTimer.Stop();
                if (_document.S32Files.Count > 0)
                {
                    RenderS32Map();
                }
                _logger.Debug($"[RENDER-DEBOUNCE] Complete in {sw.ElapsedMilliseconds}ms");
            };

            // 初始化拖曳渲染延遲Timer（50ms延遲，減少等待時間）
            dragRenderTimer = new Timer();
            dragRenderTimer.Interval = 50;
            dragRenderTimer.Tick += (s, e) =>
            {
                var timerSw = Stopwatch.StartNew();
                _logger.Debug("[DRAG-TIMER] Tick - calling CheckAndRerenderIfNeeded");
                LogPerf($"[DRAG-TIMER] tick start");
                dragRenderTimer.Stop();
                CheckAndRerenderIfNeeded();
                timerSw.Stop();
                _logger.Debug($"[DRAG-TIMER] Tick complete in {timerSw.ElapsedMilliseconds}ms");
                LogPerf($"[DRAG-TIMER] tick end, total={timerSw.ElapsedMilliseconds}ms");
            };

            // 初始化 Layer8 動畫計時器（100ms 每帧）
            _layer8AnimTimer = new Timer();
            _layer8AnimTimer.Interval = 100;
            _layer8AnimTimer.Tick += (s, e) =>
            {
                var sw = Stopwatch.StartNew();
                if (_editState.EnabledLayer8Items.Count == 0)
                {
                    _layer8AnimTimer.Stop();
                    return;
                }

                // 更新所有啟用項目的帧索引
                var keys = _renderCache.Layer8AnimFrame.Keys.ToList();
                foreach (var key in keys)
                {
                    _renderCache.Layer8AnimFrame[key]++;
                }

                // 只重繪 L8 動畫覆蓋層，不影響地圖和其他圖層
                _mapViewerControl?.InvalidateAnimationOverlay();
                sw.Stop();
                if (sw.ElapsedMilliseconds > 10)
                    _logger.Debug($"[UI-TIMER] L8AnimTimer tick took {sw.ElapsedMilliseconds}ms");
            };

            // 註冊滑鼠滾輪事件用於縮放
            this.panel1.MouseWheel += Panel1_MouseWheel;

            // 確保 panel1 可以接收焦點
            this.panel1.SetTabStop(true);

            // 當滑鼠進入 panel1 時自動取得焦點
            this.panel1.MouseEnter += (s, e) => this.panel1.Focus();

            // 設置 PictureBox 的 SizeMode 為 StretchImage
            this.pictureBox1.SetSizeMode(PictureBoxSizeMode.StretchImage);
            this.pictureBox2.SetSizeMode(PictureBoxSizeMode.StretchImage);
            this.pictureBox3.SetSizeMode(PictureBoxSizeMode.StretchImage);
            this.pictureBox4.SetSizeMode(PictureBoxSizeMode.StretchImage);

            // 註冊 S32 編輯器的滑鼠滾輪事件
            this.s32MapPanel.MouseWheel += S32MapPanel_MouseWheel;
            this.s32MapPanel.SetTabStop(true);
            this.s32MapPanel.MouseEnter += (s, e) => this.s32MapPanel.Focus();

            // 啟用雙緩衝以減少閃爍 (Eto.Forms 自動處理，只有 WinForms 需要)
            try
            {
                var doubleBufferedProp = this.s32MapPanel.GetType().GetProperty("DoubleBuffered",
                    System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.NonPublic);
                if (doubleBufferedProp != null && doubleBufferedProp.CanWrite)
                {
                    doubleBufferedProp.SetValue(this.s32MapPanel, true);
                }
            }
            catch { /* Eto.Forms handles double buffering automatically */ }
            // MapViewerControl 已內建雙緩衝，不需要額外設定

            // 設定共享的 ViewState
            _mapViewerControl.SetViewState(_viewState);

            // 訂閱 MapViewerControl 事件
            _mapViewerControl.MapMouseDown += MapViewerControl_MapMouseDown;
            _mapViewerControl.MapMouseMove += MapViewerControl_MapMouseMove;
            _mapViewerControl.MapMouseUp += MapViewerControl_MapMouseUp;
            _mapViewerControl.PaintOverlay += MapViewerControl_PaintOverlay;
            _mapViewerControl.PaintOverlaySK = DrawSelectedCellsSK;
            _mapViewerControl.CoordinateChanged += MapViewerControl_CoordinateChanged;
            _mapViewerControl.RenderCompleted += MapViewerControl_RenderCompleted;
            _mapViewerControl.ScrollChanged += (s, e) => UpdateMiniMapViewportRect();
            _mapViewerControl.ZoomChanged += (s, e) =>
            {
                // 縮放按鈕觸發時，重新渲染並更新小地圖
                CheckAndRerenderIfNeeded();
                UpdateMiniMapViewportRect();
                lblS32Info.Text = $"縮放: {_viewState.ZoomLevel:P0}";
            };

            // 設定 MiniMapControl（取代 miniMapPictureBox）
            SetupMiniMapControl();

            // 拖曳移動視圖時更新小地圖（使用防抖避免過度更新）
            // 注意：現在使用中鍵拖曳移動視圖，不再使用 Panel AutoScroll

            // 建立通行性編輯操作說明標籤
            lblPassabilityHelp = new Label
            {
                AutoSize = true,
                BackColor = Color.FromArgb(200, 30, 30, 30),
                ForeColor = Colors.White,
                Font = new Font("Microsoft JhengHei", 9, FontStyle.None),
                Padding = new Padding(8),
                Visible = false,
                BorderStyle = BorderStyle.FixedSingle
            };
            this.s32MapPanel.GetControls().Add(lblPassabilityHelp);
            lblPassabilityHelp.BringToFront();
            lblPassabilityHelp.SetLocation(new Point(10, 10));

            // 建立區域編輯操作說明標籤
            lblRegionHelp = new Label
            {
                AutoSize = true,
                BackColor = Color.FromArgb(200, 40, 80, 40),
                ForeColor = Colors.White,
                Font = new Font("Microsoft JhengHei", 9, FontStyle.None),
                Padding = new Padding(8),
                Visible = false,
                BorderStyle = BorderStyle.FixedSingle
            };
            this.s32MapPanel.GetControls().Add(lblRegionHelp);
            lblRegionHelp.BringToFront();
            lblRegionHelp.SetLocation(new Point(10, 10));

            // 建立預設操作提示標籤
            lblDefaultHint = new Label
            {
                AutoSize = true,
                BackColor = Color.FromArgb(180, 50, 50, 50),
                ForeColor = Colors.White,
                Font = new Font("Microsoft JhengHei", 9, FontStyle.None),
                Padding = new Padding(8),
                Text = LocalizationManager.L("Hint_MouseControls"),
                Visible = true,
                BorderStyle = BorderStyle.FixedSingle
            };
            this.s32MapPanel.GetControls().Add(lblDefaultHint);
            lblDefaultHint.BringToFront();
            lblDefaultHint.SetLocation(new Point(10, 10));

            // 建立 Layer5 透明編輯操作說明標籤（預先創建，避免運行時添加控件導致的布局問題）
            lblLayer5Help = new Label();
            lblLayer5Help.SetAutoSize(false);
            lblLayer5Help.Size = new Size(200, 130);
            lblLayer5Help.BackgroundColor = Color.FromArgb(220, 30, 30, 50);
            lblLayer5Help.TextColor = Color.FromArgb(100, 180, 255);
            lblLayer5Help.Font = new Font("Microsoft JhengHei", 9F, FontStyle.None);
            lblLayer5Help.Padding = new Padding(8);
            lblLayer5Help.BorderStyle = BorderStyle.FixedSingle;
            lblLayer5Help.Visible = false; // 初始隱藏
            this.s32MapPanel.GetControls().Add(lblLayer5Help);
            lblLayer5Help.SetLocation(new Point(10, 10));

            // 建立區域類型切換按鈕
            btnRegionNormal = new Button
            {
                Text = "一般",
                Size = new Size(50, 25),
                Location = new Point(10, 85),
                BackColor = Color.FromArgb(200, 200, 200),
                FlatStyle = FlatStyle.Flat,
                Visible = false
            };
            btnRegionNormal.Click += (s, ev) => { currentRegionType = RegionType.Normal; UpdateRegionHelpLabel(); };
            this.s32MapPanel.GetControls().Add(btnRegionNormal);
            btnRegionNormal.BringToFront();

            btnRegionSafe = new Button
            {
                Text = "安全",
                Size = new Size(50, 25),
                Location = new Point(65, 85),
                BackColor = Color.FromArgb(100, 150, 255),
                FlatStyle = FlatStyle.Flat,
                Visible = false
            };
            btnRegionSafe.Click += (s, ev) => { currentRegionType = RegionType.Safe; UpdateRegionHelpLabel(); };
            this.s32MapPanel.GetControls().Add(btnRegionSafe);
            btnRegionSafe.BringToFront();

            btnRegionCombat = new Button
            {
                Text = "戰鬥",
                Size = new Size(50, 25),
                Location = new Point(120, 85),
                BackColor = Color.FromArgb(180, 100, 255),
                FlatStyle = FlatStyle.Flat,
                Visible = false
            };
            btnRegionCombat.Click += (s, ev) => { currentRegionType = RegionType.Combat; UpdateRegionHelpLabel(); };
            this.s32MapPanel.GetControls().Add(btnRegionCombat);
            btnRegionCombat.BringToFront();

            // 註冊 F5 快捷鍵重新載入
            this.KeyPreview = true;
            this.KeyDown += MapForm_KeyDown;

            // 訂閱語言變更事件
            LocalizationManager.LanguageChanged += OnLanguageChanged;
            UpdateLanguageMenuCheckmarks();
            UpdateLocalization();

            // 使用 Eto.Forms 原生布局重建 UI
            BuildEtoLayout();

            LogPerf("[FORM-CTOR] End");
        }

        /// <summary>
        /// 圖層面板的 ColoredCheckBox 列表
        /// </summary>
        private List<ColoredCheckBox> _layerColoredCheckBoxes;

        /// <summary>
        /// 創建自繪圖層面板
        /// </summary>
        private Eto.Forms.Panel CreateCustomLayerPanel()
        {
            // 創建 ColoredCheckBox 並綁定到原有的 CheckBox
            _layerColoredCheckBoxes = new List<ColoredCheckBox>();

            var layerConfigs = new[]
            {
                (text: "L1 地板", color: Eto.Drawing.Colors.White, chk: chkFloatLayer1),
                (text: "L2", color: Eto.Drawing.Colors.LightGrey, chk: chkFloatLayer2),
                (text: "L4 物件", color: Eto.Drawing.Colors.White, chk: chkFloatLayer4),
                (text: "L5 透明", color: Eto.Drawing.Color.FromArgb(100, 180, 255), chk: chkFloatLayer5),
                (text: "通行", color: Eto.Drawing.Colors.LightGreen, chk: chkFloatPassable),
                (text: "格線", color: Eto.Drawing.Colors.LightBlue, chk: chkFloatGrid),
                (text: "S32邊界", color: Eto.Drawing.Colors.Orange, chk: chkFloatS32Boundary),
                (text: "安全區", color: Eto.Drawing.Color.FromArgb(100, 180, 255), chk: chkFloatSafeZones),
                (text: "戰鬥區", color: Eto.Drawing.Color.FromArgb(255, 100, 100), chk: chkFloatCombatZones),
                (text: LocalizationManager.L("Layer_L8Spr"), color: Eto.Drawing.Color.FromArgb(255, 180, 100), chk: chkFloatLayer8Spr),
                (text: LocalizationManager.L("Layer_L8Marker"), color: Eto.Drawing.Color.FromArgb(255, 180, 100), chk: chkFloatLayer8Marker),
            };

            var stackLayout = new Eto.Forms.StackLayout
            {
                Orientation = Eto.Forms.Orientation.Vertical,
                Spacing = 5,
                Padding = new Eto.Drawing.Padding(8, 8, 8, 10)
            };

            // 標題
            var titleLabel = new Eto.Forms.Label
            {
                Text = "▣ 圖層",
                TextColor = Eto.Drawing.Colors.White,
                Font = new Eto.Drawing.Font(Eto.Drawing.SystemFont.Bold, 10)
            };
            stackLayout.Items.Add(titleLabel);

            // 添加每個 ColoredCheckBox
            foreach (var config in layerConfigs)
            {
                var coloredChk = new ColoredCheckBox
                {
                    Text = config.text,
                    TextColor = config.color,
                    Checked = config.chk.Checked == true
                };

                // 雙向綁定：ColoredCheckBox -> 原 CheckBox
                coloredChk.CheckedChanged += (s, e) =>
                {
                    config.chk.Checked = coloredChk.Checked;
                };

                // 原 CheckBox -> ColoredCheckBox (如果其他地方修改了原 CheckBox)
                config.chk.CheckedChanged += (s, e) =>
                {
                    if (coloredChk.Checked != (config.chk.Checked == true))
                    {
                        coloredChk.Checked = config.chk.Checked == true;
                    }
                };

                _layerColoredCheckBoxes.Add(coloredChk);
                stackLayout.Items.Add(coloredChk);
            }

            // 外層 Panel 提供背景色 (黑色)
            var panel = new Eto.Forms.Panel
            {
                Content = stackLayout,
                BackgroundColor = Eto.Drawing.Colors.Black
            };

            return panel;
        }

        /// <summary>
        /// 使用 Eto.Forms 原生布局重建主介面
        /// </summary>
        private void BuildEtoLayout()
        {
            // === 左側面板 (小地圖 + 地圖列表) ===
            var leftLayout = new Eto.Forms.StackLayout
            {
                Orientation = Eto.Forms.Orientation.Vertical,
                HorizontalContentAlignment = Eto.Forms.HorizontalAlignment.Stretch,
                Padding = new Eto.Drawing.Padding(5),
                Spacing = 5,
                Width = 280
            };

            // 小地圖 (固定大小 268x268)
            // 使用 _miniMapControl 而不是 miniMapPictureBox (由 SetupMiniMapControl 建立)
            _miniMapControl.Size = new Eto.Drawing.Size(268, 268);
            var miniMapContainer = new Eto.Forms.Panel
            {
                Content = _miniMapControl,
                Size = new Eto.Drawing.Size(268, 268),
                BackgroundColor = Eto.Drawing.Colors.Black
            };
            leftLayout.Items.Add(new Eto.Forms.StackLayoutItem(miniMapContainer, false));

            // 地圖列表 Tab
            var mapListLayout = new Eto.Forms.StackLayout
            {
                Orientation = Eto.Forms.Orientation.Vertical,
                HorizontalContentAlignment = Eto.Forms.HorizontalAlignment.Stretch,
                Spacing = 3
            };
            mapListLayout.Items.Add(new Eto.Forms.StackLayoutItem(txtMapSearch, false));
            mapListLayout.Items.Add(new Eto.Forms.StackLayoutItem(lstMaps, true));

            // S32 檔案 Tab
            var s32FilesHeader = new Eto.Forms.StackLayout
            {
                Orientation = Eto.Forms.Orientation.Horizontal,
                Spacing = 5
            };
            s32FilesHeader.Items.Add(new Eto.Forms.StackLayoutItem(lblS32Files, true));
            s32FilesHeader.Items.Add(new Eto.Forms.StackLayoutItem(btnS32SelectAll, false));
            s32FilesHeader.Items.Add(new Eto.Forms.StackLayoutItem(btnS32SelectNone, false));

            var s32FilesLayout = new Eto.Forms.StackLayout
            {
                Orientation = Eto.Forms.Orientation.Vertical,
                HorizontalContentAlignment = Eto.Forms.HorizontalAlignment.Stretch,
                Spacing = 3
            };
            s32FilesLayout.Items.Add(new Eto.Forms.StackLayoutItem(s32FilesHeader, false));
            s32FilesLayout.Items.Add(new Eto.Forms.StackLayoutItem(lstS32Files, true));

            // 重建 TabControl
            var leftTabs = new Eto.Forms.TabControl();
            var tabMap = new Eto.Forms.TabPage { Text = "地圖列表", Content = mapListLayout };
            var tabS32 = new Eto.Forms.TabPage { Text = "S32 檔案", Content = s32FilesLayout };
            leftTabs.Pages.Add(tabMap);
            leftTabs.Pages.Add(tabS32);

            leftLayout.Items.Add(new Eto.Forms.StackLayoutItem(leftTabs, true));

            // === 中間面板 (S32 編輯器) ===
            // 工具列按鈕 Row 1
            var toolRow1 = new Eto.Forms.StackLayout
            {
                Orientation = Eto.Forms.Orientation.Horizontal,
                Spacing = 5,
                Padding = new Eto.Drawing.Padding(5)
            };
            toolRow1.Items.Add(btnReloadMap);
            toolRow1.Items.Add(btnSaveS32);
            toolRow1.Items.Add(btnCopySettings);
            toolRow1.Items.Add(btnCopyMapCoords);
            toolRow1.Items.Add(btnImportFs32);

            // 工具列按鈕 Row 2
            var toolRow2 = new Eto.Forms.StackLayout
            {
                Orientation = Eto.Forms.Orientation.Horizontal,
                Spacing = 5,
                Padding = new Eto.Drawing.Padding(5, 0, 5, 5)
            };
            toolRow2.Items.Add(btnEditPassable);
            toolRow2.Items.Add(btnEditLayer5);
            toolRow2.Items.Add(btnRegionEdit);

            // 工具列容器
            var toolbarLayout = new Eto.Forms.StackLayout
            {
                Orientation = Eto.Forms.Orientation.Vertical,
                BackgroundColor = Eto.Drawing.Colors.LightGrey
            };
            toolbarLayout.Items.Add(toolRow1);
            toolbarLayout.Items.Add(toolRow2);

            // 地圖顯示區域 (包含 MapViewerControl 和浮動圖層面板)
            // 使用 Drawable 自繪圖層面板以確保顏色正確顯示
            var etoLayerPanel = CreateCustomLayerPanel();

            // 使用 PixelLayout 來支援圖層面板的絕對定位
            var mapPixelLayout = new Eto.Forms.PixelLayout();
            mapPixelLayout.Add(_mapViewerControl, 0, 0);
            mapPixelLayout.Add(etoLayerPanel, 10, 10);

            var mapContainer = new Eto.Forms.Panel
            {
                Content = mapPixelLayout,
                BackgroundColor = Eto.Drawing.Colors.Black
            };

            // 監聽 mapContainer 大小變更以調整子控件大小和圖層面板位置
            mapContainer.SizeChanged += (s, e) =>
            {
                _mapViewerControl.Size = mapContainer.Size;
                // 調整圖層面板位置（右上角）
                int x = Math.Max(10, mapContainer.Width - 120);
                mapPixelLayout.Move(etoLayerPanel, x, 10);
            };

            // 中間面板布局
            var centerLayout = new Eto.Forms.TableLayout
            {
                Spacing = new Eto.Drawing.Size(0, 0),
                Rows =
                {
                    new Eto.Forms.TableRow(new Eto.Forms.TableCell(toolbarLayout, false)),
                    new Eto.Forms.TableRow(new Eto.Forms.TableCell(mapContainer, true)) { ScaleHeight = true }
                }
            };

            // === 右側面板 (工具按鈕 + Tile 列表) ===
            // 工具按鈕列 (第一欄 - 編輯工具)
            var toolBtnCol1 = new Eto.Forms.StackLayout
            {
                Orientation = Eto.Forms.Orientation.Vertical,
                HorizontalContentAlignment = Eto.Forms.HorizontalAlignment.Stretch,
                Spacing = 2,
                Padding = new Eto.Drawing.Padding(2)
            };
            toolBtnCol1.Items.Add(btnToolCopy);
            toolBtnCol1.Items.Add(btnToolPaste);
            toolBtnCol1.Items.Add(btnToolDelete);
            toolBtnCol1.Items.Add(btnToolUndo);
            toolBtnCol1.Items.Add(btnToolRedo);
            toolBtnCol1.Items.Add(btnToolSave);
            toolBtnCol1.Items.Add(btnToolCellInfo);
            toolBtnCol1.Items.Add(btnToolReplaceTile);
            toolBtnCol1.Items.Add(btnToolAddS32);
            toolBtnCol1.Items.Add(btnToolClearLayer7);
            toolBtnCol1.Items.Add(btnToolClearCell);
            toolBtnCol1.Items.Add(btnMapValidate);

            // 工具按鈕列 (第二欄 - 查看各層)
            var toolBtnCol2 = new Eto.Forms.StackLayout
            {
                Orientation = Eto.Forms.Orientation.Vertical,
                HorizontalContentAlignment = Eto.Forms.HorizontalAlignment.Stretch,
                Spacing = 2,
                Padding = new Eto.Drawing.Padding(2)
            };
            toolBtnCol2.Items.Add(btnToolCheckL1);
            toolBtnCol2.Items.Add(btnToolCheckL2);
            toolBtnCol2.Items.Add(btnToolCheckL3);
            toolBtnCol2.Items.Add(btnToolCheckL4);
            toolBtnCol2.Items.Add(btnToolCheckL5);
            toolBtnCol2.Items.Add(btnToolCheckL6);
            toolBtnCol2.Items.Add(btnToolCheckL7);
            toolBtnCol2.Items.Add(btnToolCheckL8);
            toolBtnCol2.Items.Add(btnEnableVisibleL8);
            toolBtnCol2.Items.Add(btnViewClipboard);
            toolBtnCol2.Items.Add(btnToolTestTil);
            toolBtnCol2.Items.Add(btnToolClearTestTil);

            // 兩欄工具按鈕水平排列
            var toolBtnLayout = new Eto.Forms.StackLayout
            {
                Orientation = Eto.Forms.Orientation.Horizontal,
                VerticalContentAlignment = Eto.Forms.VerticalAlignment.Top,
                Spacing = 0
            };
            toolBtnLayout.Items.Add(toolBtnCol1);
            toolBtnLayout.Items.Add(toolBtnCol2);

            // Tile 列表區域
            var tileListLayout = new Eto.Forms.StackLayout
            {
                Orientation = Eto.Forms.Orientation.Vertical,
                HorizontalContentAlignment = Eto.Forms.HorizontalAlignment.Stretch,
                Spacing = 3,
                Padding = new Eto.Drawing.Padding(3)
            };
            tileListLayout.Items.Add(new Eto.Forms.StackLayoutItem(lblTileList, false));
            tileListLayout.Items.Add(new Eto.Forms.StackLayoutItem(txtTileSearch, false));
            tileListLayout.Items.Add(new Eto.Forms.StackLayoutItem(lvTiles, true));
            tileListLayout.Items.Add(new Eto.Forms.StackLayoutItem(lblMaterials, false));
            tileListLayout.Items.Add(new Eto.Forms.StackLayoutItem(lvMaterials, true));
            tileListLayout.Items.Add(new Eto.Forms.StackLayoutItem(btnMoreMaterials, false));

            // 群組縮圖區
            tileListLayout.Items.Add(new Eto.Forms.StackLayoutItem(lblGroupThumbnails, false));

            // 模式選擇 + 搜尋框 (並排)
            var groupControlRow = new Eto.Forms.TableLayout
            {
                Spacing = new Eto.Drawing.Size(3, 0),
                Rows = { new Eto.Forms.TableRow(
                    new Eto.Forms.TableCell(cmbGroupMode, false),
                    new Eto.Forms.TableCell(txtGroupSearch, true)
                )}
            };
            tileListLayout.Items.Add(new Eto.Forms.StackLayoutItem(groupControlRow, false));

            // 群組縮圖列表 (可伸縮)
            tileListLayout.Items.Add(new Eto.Forms.StackLayoutItem(lvGroupThumbnails, true));

            // 右側整體布局 (工具按鈕 + Tile 列表)
            var rightLayout = new Eto.Forms.Splitter
            {
                Orientation = Eto.Forms.Orientation.Horizontal,
                FixedPanel = Eto.Forms.SplitterFixedPanel.Panel1,
                Panel1MinimumSize = 80,
                Position = 85,
                Panel1 = toolBtnLayout,
                Panel2 = tileListLayout
            };

            // === 主內容區域 (左中右 Splitter) ===
            // 中右 Splitter
            var centerRightSplitter = new Eto.Forms.Splitter
            {
                Orientation = Eto.Forms.Orientation.Horizontal,
                FixedPanel = Eto.Forms.SplitterFixedPanel.Panel2,
                Panel2MinimumSize = 200,
                Position = 800,
                Panel1 = centerLayout,
                Panel2 = rightLayout
            };

            // 左 + (中右) Splitter
            var mainSplitter = new Eto.Forms.Splitter
            {
                Orientation = Eto.Forms.Orientation.Horizontal,
                FixedPanel = Eto.Forms.SplitterFixedPanel.Panel1,
                Panel1MinimumSize = 250,
                Position = 280,
                Panel1 = leftLayout,
                Panel2 = centerRightSplitter
            };

            // === 狀態列 ===
            // 使用 Designer.cs 中定義的狀態列控件
            var statusLayout = new Eto.Forms.TableLayout
            {
                Padding = new Eto.Drawing.Padding(5, 2),
                Spacing = new Eto.Drawing.Size(5, 0),
                BackgroundColor = Eto.Drawing.Color.FromArgb(240, 240, 240)
            };

            // 建立狀態列按鈕 (ToolStripButton 不能直接用於 StackLayout)
            var btnCopyMoveCmd = new Eto.Forms.Button
            {
                Text = toolStripCopyMoveCmd.Text,
                ToolTip = toolStripCopyMoveCmd.ToolTip,
                Enabled = toolStripCopyMoveCmd.Enabled,
                Size = new Eto.Drawing.Size(-1, 22)
            };
            btnCopyMoveCmd.Click += (s, e) => toolStripCopyMoveCmd_Click(s, e);
            // 保存引用以便更新 Enabled 狀態
            _statusBtnCopyMoveCmd = btnCopyMoveCmd;

            var btnJump = new Eto.Forms.Button
            {
                Text = toolStripJumpButton.Text,
                Size = new Eto.Drawing.Size(-1, 22)
            };
            btnJump.Click += (s, e) => toolStripJumpButton_Click(s, e);

            // 跳轉文字框
            var txtJump = new Eto.Forms.TextBox
            {
                Width = 100,
                ToolTip = "輸入座標 (X,Y) 然後按 Enter 或點擊跳轉"
            };
            txtJump.KeyDown += (s, e) =>
            {
                if (e.Key == Eto.Forms.Keys.Enter)
                {
                    toolStripJumpTextBox.Text = txtJump.Text;
                    toolStripJumpButton_Click(s, EventArgs.Empty);
                }
            };
            // 同步文字框內容
            _statusTxtJump = txtJump;

            // 狀態列左側 - 狀態資訊
            var statusLeft = new Eto.Forms.StackLayout
            {
                Orientation = Eto.Forms.Orientation.Horizontal,
                VerticalContentAlignment = Eto.Forms.VerticalAlignment.Center,
                Spacing = 10
            };
            statusLeft.Items.Add(toolStripStatusLabel1);
            statusLeft.Items.Add(new Eto.Forms.Label { Text = "|", TextColor = Eto.Drawing.Colors.Gray });
            statusLeft.Items.Add(toolStripStatusLabel2);

            // 狀態列中間 - 進度條 (填充剩餘空間)
            var statusCenter = new Eto.Forms.StackLayout
            {
                Orientation = Eto.Forms.Orientation.Horizontal,
                VerticalContentAlignment = Eto.Forms.VerticalAlignment.Center,
                Spacing = 5
            };
            statusCenter.Items.Add(toolStripStatusLabel3);
            statusCenter.Items.Add(toolStripProgressBar1);

            // 狀態列右側 - 複製指令、跳轉
            var statusRight = new Eto.Forms.StackLayout
            {
                Orientation = Eto.Forms.Orientation.Horizontal,
                VerticalContentAlignment = Eto.Forms.VerticalAlignment.Center,
                Spacing = 5
            };
            statusRight.Items.Add(btnCopyMoveCmd);
            statusRight.Items.Add(new Eto.Forms.Label { Text = "|", TextColor = Eto.Drawing.Colors.Gray });
            statusRight.Items.Add(new Eto.Forms.Label { Text = "跳轉座標:" });
            statusRight.Items.Add(txtJump);
            statusRight.Items.Add(btnJump);

            statusLayout.Rows.Add(new Eto.Forms.TableRow(
                new Eto.Forms.TableCell(statusLeft, false),
                new Eto.Forms.TableCell(statusCenter, true),
                new Eto.Forms.TableCell(statusRight, false)
            ));

            // === 主布局 (內容 + 狀態列) ===
            var mainLayout = new Eto.Forms.TableLayout
            {
                Spacing = new Eto.Drawing.Size(0, 0),
                Rows =
                {
                    new Eto.Forms.TableRow(new Eto.Forms.TableCell(mainSplitter, true)) { ScaleHeight = true },
                    new Eto.Forms.TableRow(new Eto.Forms.TableCell(statusLayout, false))
                }
            };

            // === 設定 Form ===
            // 設定選單 (WinFormsMenuStrip 已繼承自 Eto.Forms.MenuBar)
            this.Menu = menuStrip1;

            // 設定內容
            this.Content = mainLayout;

            // 設定視窗大小
            this.ClientSize = new Eto.Drawing.Size(1400, 750);
        }

        // 多語系方法已移至 MapForm/MapForm.Localization.cs

        // 處理快捷鍵
        private void MapForm_KeyDown(object sender, KeyEventArgs e)
        {
            // F5: 重新載入當前地圖
            if (e.GetKeyCode() == Keys.F5)
            {
                e.Handled = true;
                ReloadCurrentMap();
            }
            // F6: 分析 Layer3 屬性值統計
            else if (e.GetKeyCode() == Keys.F6)
            {
                e.Handled = true;
                AnalyzeLayer3Attributes();
            }
            // Ctrl+C: 複製選取區域
            else if (e.Control && e.GetKeyCode() == Keys.C && !e.Shift)
            {
                e.Handled = true;
                CopySelectedCells();
            }
            // Ctrl+Shift+C: 查看剪貼簿內容
            else if (e.Control && e.Shift && e.GetKeyCode() == Keys.C)
            {
                e.Handled = true;
                ShowClipboardViewer();
            }
            // Ctrl+V: 貼上選取區域
            else if (e.Control && e.GetKeyCode() == Keys.V)
            {
                e.Handled = true;
                PasteSelectedCells();
            }
            // Escape: 取消複製/貼上模式或取消多邊形繪製
            else if (e.GetKeyCode() == Keys.Escape)
            {
                e.Handled = true;
                // 優先取消多邊形繪製
                if (_editState.IsDrawingPassabilityPolygon)
                {
                    _editState.PassabilityPolygonPoints.Clear();
                    _editState.IsDrawingPassabilityPolygon = false;
                    _mapViewerControl.Refresh();
                    this.toolStripStatusLabel1.Text = "已取消多邊形繪製";
                }
                // 取消素材貼上模式
                else if (_pendingMaterial != null)
                {
                    CancelMaterialPasteMode();
                    this.toolStripStatusLabel1.Text = "已取消素材貼上模式";
                }
                else
                {
                    CancelLayer4CopyPaste();
                }
            }
            // Ctrl+Z: 還原
            else if (e.Control && e.GetKeyCode() == Keys.Z)
            {
                e.Handled = true;
                UndoLastAction();
            }
            // Ctrl+Y: 重做
            else if (e.Control && e.GetKeyCode() == Keys.Y)
            {
                e.Handled = true;
                RedoLastAction();
            }
            // Del: 刪除選取區域內的 Layer4 物件
            else if (e.GetKeyCode() == Keys.Delete)
            {
                e.Handled = true;
                DeleteSelectedLayer4Objects();
            }
            // 1/2/3 鍵：區域編輯模式下切換區域類型
            else if (currentRegionEditMode == RegionEditMode.SetRegion)
            {
                RegionType newRegionType = currentRegionType;
                string newRegionName = "";

                if (e.GetKeyCode() == Keys.D1 || e.GetKeyCode() == Keys.Keypad1)
                {
                    newRegionType = RegionType.Normal;
                    newRegionName = "一般區域";
                    e.Handled = true;
                }
                else if (e.GetKeyCode() == Keys.D2 || e.GetKeyCode() == Keys.Keypad2)
                {
                    newRegionType = RegionType.Safe;
                    newRegionName = "安全區域";
                    e.Handled = true;
                }
                else if (e.GetKeyCode() == Keys.D3 || e.GetKeyCode() == Keys.Keypad3)
                {
                    newRegionType = RegionType.Combat;
                    newRegionName = "戰鬥區域";
                    e.Handled = true;
                }

                if (newRegionType != currentRegionType)
                {
                    currentRegionType = newRegionType;
                    this.toolStripStatusLabel1.Text = $"區域設置模式 ({newRegionName})：直接點擊格子設定區域類型 | 1/2/3鍵切換區域類型";
                    UpdateRegionHelpLabel();
                }
            }
            // 方向鍵：小地圖焦點時移動視圖
            else if (_interaction.IsMiniMapFocused && (e.GetKeyCode() == Keys.Up || e.GetKeyCode() == Keys.Down ||
                                          e.GetKeyCode() == Keys.Left || e.GetKeyCode() == Keys.Right))
            {
                e.Handled = true;
                MoveMiniMapByArrowKey(e.GetKeyCode());
            }
        }

        // 刪除選取區域內的 Layer4 物件
        private void DeleteSelectedLayer4Objects()
        {
            if (!_interaction.IsLayer4CopyMode || _editState.SelectedCells.Count == 0)
            {
                this.toolStripStatusLabel1.Text = "請先使用左鍵選取要刪除的區域";
                return;
            }

            // 呼叫現有的批次刪除功能
            DeleteAllLayer4ObjectsInRegion(_editState.SelectedCells);

            // 清除選取狀態
            _interaction.IsLayer4CopyMode = false;
            selectedRegion = new Rectangle();
            copyRegionBounds = new Rectangle();
            _editState.SelectedCells.Clear();
            _mapViewerControl.Refresh();
        }

        // 複製 Layer4 物件
        private void CopySelectedCells()
        {
            if (!_interaction.IsLayer4CopyMode || copyRegionBounds.Width == 0 || copyRegionBounds.Height == 0)
            {
                this.toolStripStatusLabel1.Text = "請先使用 左鍵 選取要複製的區域";
                return;
            }

            // 檢查是否有選擇任何層
            bool copyLayer1 = copySettingLayer1;
            bool copyLayer2 = copySettingLayer2;
            bool copyLayer3 = copySettingLayer3;
            bool copyLayer4 = copySettingLayer4;
            bool copyLayer5 = copySettingLayer5;
            bool copyLayer7 = copySettingLayer7;
            bool copyLayer8 = copySettingLayer8;

            if (!copyLayer1 && !copyLayer2 && !copyLayer3 && !copyLayer4 && !copyLayer5 && !copyLayer7 && !copyLayer8)
            {
                this.toolStripStatusLabel1.Text = "請點擊「複製設定...」按鈕選擇要複製的圖層";
                return;
            }

            _editState.CellClipboard.Clear();

            // 使用已經在 MouseMove/MouseUp 中計算好的 _editState.SelectedCells
            List<SelectedCell> selectedCells = _editState.SelectedCells;

            if (selectedCells.Count == 0)
            {
                this.toolStripStatusLabel1.Text = "選取區域內沒有任何格子";
                return;
            }

            // 計算所有格子的全域 Layer1 座標範圍
            int minGlobalX = int.MaxValue, minGlobalY = int.MaxValue;
            foreach (var cell in selectedCells)
            {
                int globalX = cell.S32Data.SegInfo.nLinBeginX * 2 + cell.LocalX;
                int globalY = cell.S32Data.SegInfo.nLinBeginY + cell.LocalY;
                if (globalX < minGlobalX) minGlobalX = globalX;
                if (globalY < minGlobalY) minGlobalY = globalY;
            }

            // 確保 minGlobalX 是偶數，以保持相對座標的奇偶性
            if (minGlobalX % 2 != 0)
            {
                minGlobalX -= 1;
            }

            int layer1Count = 0, layer3Count = 0, layer4Count = 0;

            // 收集每個格子的資料
            foreach (var cell in selectedCells)
            {
                int globalX = cell.S32Data.SegInfo.nLinBeginX * 2 + cell.LocalX;
                int globalY = cell.S32Data.SegInfo.nLinBeginY + cell.LocalY;

                var cellData = new CopiedCellData
                {
                    RelativeX = globalX - minGlobalX,
                    RelativeY = globalY - minGlobalY
                };

                // Layer1 資料（地板）- 一個 Layer3 格子對應兩個 Layer1 格子
                if (copyLayer1)
                {
                    int layer1X = cell.LocalX;  // 偶數
                    if (layer1X >= 0 && layer1X < 128 && cell.LocalY >= 0 && cell.LocalY < 64)
                    {
                        var cell1 = cell.S32Data.Layer1[cell.LocalY, layer1X];
                        if (cell1 != null)
                        {
                            cellData.Layer1Cell1 = new TileCell { X = cell1.X, Y = cell1.Y, TileId = cell1.TileId, IndexId = cell1.IndexId };
                            if (cell1.TileId > 0) layer1Count++;
                        }
                    }
                    if (layer1X + 1 >= 0 && layer1X + 1 < 128 && cell.LocalY >= 0 && cell.LocalY < 64)
                    {
                        var cell2 = cell.S32Data.Layer1[cell.LocalY, layer1X + 1];
                        if (cell2 != null)
                        {
                            cellData.Layer1Cell2 = new TileCell { X = cell2.X, Y = cell2.Y, TileId = cell2.TileId, IndexId = cell2.IndexId };
                            if (cell2.TileId > 0) layer1Count++;
                        }
                    }
                }

                // Layer3 資料（屬性）
                if (copyLayer3)
                {
                    int layer3X = cell.LocalX / 2;  // Layer3 座標
                    if (layer3X >= 0 && layer3X < 64 && cell.LocalY >= 0 && cell.LocalY < 64)
                    {
                        var attr = cell.S32Data.Layer3[cell.LocalY, layer3X];
                        if (attr != null)
                        {
                            cellData.Layer3Attr = new MapAttribute { Attribute1 = attr.Attribute1, Attribute2 = attr.Attribute2 };
                            layer3Count++;
                        }
                    }
                }

                // Layer4 資料已移至跨區塊搜索統一處理

                _editState.CellClipboard.Add(cellData);
            }

            // Layer4 物件搜索：遍歷所有 S32，找出座標精確落在選取範圍內的物件
            if (copyLayer4 && selectedCells.Count > 0)
            {
                // 建立選取格子的全域座標集合 (Layer3 座標系)
                var selectedGlobalCells = new HashSet<(int x, int y)>();
                foreach (var cell in selectedCells)
                {
                    int globalL1X = cell.S32Data.SegInfo.nLinBeginX*2 + cell.LocalX;
                    int globalL1Y = cell.S32Data.SegInfo.nLinBeginY + cell.LocalY;
                    selectedGlobalCells.Add((globalL1X, globalL1Y));
                    selectedGlobalCells.Add((globalL1X +1 , globalL1Y));
                }

                // 遍歷所有 S32 檔案搜索物件（精確匹配選取格子）
                foreach (var s32Data in _document.S32Files.Values)
                {
                    int segStartX = s32Data.SegInfo.nLinBeginX;
                    int segStartY = s32Data.SegInfo.nLinBeginY;

                    for (int i = 0; i < s32Data.Layer4.Count; i++)
                    {
                        var obj = s32Data.Layer4[i];

                        // 計算物件的全域座標 (考慮物件 X 可能超出 0-127 範圍)
                        int objGlobalL3X = segStartX + obj.X / 2;
                        int objGlobalL1X = segStartX*2 + obj.X ;
                        int objGlobalL3Y = segStartY + obj.Y;

                        // 精確檢查是否在選取的格子內
                        if (selectedGlobalCells.Contains((objGlobalL1X, objGlobalL3Y)))
                        {
                            // obj.X 本身就是 Layer1 局部座標 (0-127)
                            int objGlobalLayer1X = segStartX * 2 + obj.X;
                            int objGlobalY = segStartY + obj.Y;
                            int relX = objGlobalLayer1X - minGlobalX;
                            int relY = objGlobalY - minGlobalY;

                            bool alreadyCopied = _editState.CellClipboard.Any(cd =>
                                cd.Layer4Objects.Any(o =>
                                    o.RelativeX == relX && o.RelativeY == relY && o.GroupId == obj.GroupId && o.Layer == obj.Layer && o.IndexId == obj.IndexId && o.TileId == obj.TileId));

                            if (!alreadyCopied)
                            {
                                // 建立新的 cellData 來存放物件
                                var objCellData = new CopiedCellData
                                {
                                    RelativeX = relX,
                                    RelativeY = relY
                                };
                                objCellData.Layer4Objects.Add(new CopiedObjectTile
                                {
                                    RelativeX = relX,
                                    RelativeY = relY,
                                    GroupId = obj.GroupId,
                                    Layer = obj.Layer,
                                    IndexId = obj.IndexId,
                                    TileId = obj.TileId,
                                    OriginalIndex = i,
                                    // 記錄 Layer1 座標系統 (0-127) 的局部座標
                                    OriginalLocalLayer1X = obj.X,
                                    OriginalLocalY = obj.Y
                                });
                                _editState.CellClipboard.Add(objCellData);
                                layer4Count++;
                            }
                        }
                    }
                }
            }

            _editState.SourceMapId = _document.MapId;
            _editState.CopySourceOrigin = new Point(minGlobalX, minGlobalY);  // 記錄複製時的原點

            // 複製 Layer2 和 Layer5-8 資料（從所有 S32 收集落在選取範圍內的項目）
            _editState.Layer2Clipboard.Clear();
            _editState.Layer5Clipboard.Clear();
            _editState.Layer6Clipboard.Clear();
            _editState.Layer7Clipboard.Clear();
            _editState.Layer8Clipboard.Clear();

            // 建立選取格子的全域 Layer1 座標集合（用於 Layer2 跨區塊搜索）
            var selectedGlobalL1Cells = new HashSet<(int x, int y)>();
            foreach (var cell in selectedCells)
            {
                int globalX = cell.S32Data.SegInfo.nLinBeginX * 2 + cell.LocalX;
                int globalY = cell.S32Data.SegInfo.nLinBeginY + cell.LocalY;
                selectedGlobalL1Cells.Add((globalX, globalY));
                // Layer2 項目可能落在 X 或 X+1 的位置
                selectedGlobalL1Cells.Add((globalX + 1, globalY));
            }

            // Layer2：遍歷所有 S32 檔案，複製座標落在選取範圍內的項目
            if (copyLayer2)
            {
                foreach (var s32Data in _document.S32Files.Values)
                {
                    if (s32Data.Layer2.Count == 0) continue;

                    int s32StartX = s32Data.SegInfo.nLinBeginX * 2;
                    int s32StartY = s32Data.SegInfo.nLinBeginY;

                    foreach (var item in s32Data.Layer2)
                    {
                        // 計算 Layer2 項目的全域座標
                        int itemGlobalX = s32StartX + item.X;
                        int itemGlobalY = s32StartY + item.Y;

                        // 檢查是否落在選取範圍內（selectedGlobalL1Cells 已包含 X 和 X+1）
                        if (selectedGlobalL1Cells.Contains((itemGlobalX, itemGlobalY)))
                        {
                            // 計算相對於複製原點的座標
                            int relativeX = itemGlobalX - minGlobalX;
                            int relativeY = itemGlobalY - minGlobalY;

                            // 避免重複加入（相對座標應為非負值）
                            if (relativeX >= 0 && relativeY >= 0 && relativeX <= 255 && relativeY <= 255)
                            {
                                if (!_editState.Layer2Clipboard.Any(l => l.X == relativeX && l.Y == relativeY && l.TileId == item.TileId))
                                {
                                    _editState.Layer2Clipboard.Add(new Layer2Item
                                    {
                                        X = (byte)relativeX,
                                        Y = (byte)relativeY,
                                        IndexId = item.IndexId,
                                        TileId = item.TileId,
                                        UK = item.UK
                                    });
                                }
                            }
                        }
                    }
                }
            }

            // Layer5-8：只複製座標落在選取格子範圍內的項目
            if (copyLayer5 || copyLayer7 || copyLayer8)
            {
                // 建立選取格子的本地座標集合（按 S32 檔案分組）
                // Layer5 使用 Layer1 座標系 (X=0-127, Y=0-63)
                // Layer7 使用 Layer3 座標系 (X=0-63, Y=0-63)
                var selectedL1CellsByS32 = new Dictionary<S32Data, HashSet<(int x, int y)>>();  // Layer5 用
                var selectedL3CellsByS32 = new Dictionary<S32Data, HashSet<(int x, int y)>>();  // Layer7 用
                foreach (var cell in selectedCells)
                {
                    if (!selectedL1CellsByS32.ContainsKey(cell.S32Data))
                    {
                        selectedL1CellsByS32[cell.S32Data] = new HashSet<(int, int)>();
                        selectedL3CellsByS32[cell.S32Data] = new HashSet<(int, int)>();
                    }
                    // Layer5: X 是 0-127 (Layer1 座標)，Y 是 0-63
                    // 一個遊戲格子對應兩個 Layer1 X 座標（LocalX 和 LocalX+1）
                    selectedL1CellsByS32[cell.S32Data].Add((cell.LocalX, cell.LocalY));
                    if (cell.LocalX + 1 < 128)
                    {
                        selectedL1CellsByS32[cell.S32Data].Add((cell.LocalX + 1, cell.LocalY));
                    }
                    // Layer7: X 是 0-63 (Layer3 座標)，Y 是 0-63
                    int localL3X = cell.LocalX / 2;
                    selectedL3CellsByS32[cell.S32Data].Add((localL3X, cell.LocalY));
                }

                foreach (var kvp in selectedL1CellsByS32)
                {
                    var s32Data = kvp.Key;
                    var l1Cells = kvp.Value;
                    var l3Cells = selectedL3CellsByS32[s32Data];
                    int segStartX = s32Data.SegInfo.nLinBeginX;
                    int segStartY = s32Data.SegInfo.nLinBeginY;

                    // Layer5 - 透明圖塊（檢查 X, Y 是否在選取範圍內）
                    if (copyLayer5)
                    {
                        foreach (var item in s32Data.Layer5)
                        {
                            // Layer5 的 X 是 0-127 (Layer1 座標)，Y 是 0-63
                            if (l1Cells.Contains((item.X, item.Y)))
                            {
                                // 計算相對於複製原點的全域座標
                                int globalL1X = segStartX * 2 + item.X;
                                int globalY = segStartY + item.Y;
                                int relX = globalL1X - minGlobalX;
                                int relY = globalY - minGlobalY;

                                // 儲存相對座標（使用 X, Y 欄位暫存）
                                if (!_editState.Layer5Clipboard.Any(l => l.X == relX && l.Y == relY && l.ObjectIndex == item.ObjectIndex))
                                {
                                    _editState.Layer5Clipboard.Add(new Layer5Item { X = (byte)relX, Y = (byte)relY, ObjectIndex = item.ObjectIndex, Type = item.Type });
                                }
                            }
                        }
                    }

                    // Layer6 不再複製（由 Layer1/Layer2/Layer4 的 TileId 決定）

                    // Layer7 - 傳送點（檢查 X, Y 是否在選取範圍內）
                    if (copyLayer7)
                    {
                        foreach (var item in s32Data.Layer7)
                        {
                            // Layer7 的 X, Y 是 64x64 座標系 (Layer3)
                            if (l3Cells.Contains((item.X, item.Y)))
                            {
                                // 計算相對於複製原點的座標（Layer3 座標系）
                                int globalL3X = segStartX + item.X;
                                int globalY = segStartY + item.Y;
                                int relL3X = globalL3X - (minGlobalX / 2);  // minGlobalX 是 Layer1 座標，除以 2 得到 Layer3
                                int relY = globalY - minGlobalY;

                                if (!_editState.Layer7Clipboard.Any(l => l.Name == item.Name && l.X == relL3X && l.Y == relY))
                                {
                                    _editState.Layer7Clipboard.Add(new Layer7Item { Name = item.Name, X = (byte)relL3X, Y = (byte)relY, TargetMapId = item.TargetMapId, PortalId = item.PortalId });
                                }
                            }
                        }
                    }

                    // Layer8 - 特效（檢查 X, Y 是否在選取範圍內）
                    // 注意：Layer8 的 X, Y 是全域遊戲座標（絕對座標），不是本地座標
                    if (copyLayer8)
                    {
                        foreach (var item in s32Data.Layer8)
                        {
                            // Layer8 X,Y 是全域遊戲座標，先轉為本地座標來判斷是否在選取範圍內
                            int localL3X = item.X - segStartX;
                            int localL3Y = item.Y - segStartY;

                            // 檢查是否在有效範圍內
                            if (localL3X < 0 || localL3X >= 64 || localL3Y < 0 || localL3Y >= 64)
                                continue;

                            if (l3Cells.Contains((localL3X, localL3Y)))
                            {
                                // 計算相對於複製原點的座標（使用全域座標）
                                int globalL3X = item.X;  // 已經是全域座標
                                int globalY = item.Y;
                                int relL3X = globalL3X - (minGlobalX / 2);
                                int relY = globalY - minGlobalY;

                                if (!_editState.Layer8Clipboard.Any(l => l.SprId == item.SprId && l.X == relL3X && l.Y == relY))
                                {
                                    _editState.Layer8Clipboard.Add(new Layer8Item { SprId = item.SprId, X = (ushort)relL3X, Y = (ushort)relY, ExtendedData = item.ExtendedData });
                                }
                            }
                        }
                    }
                }
            }

            // 設定剪貼簿狀態（任何一個剪貼簿有資料就算有）
            hasLayer4Clipboard = _editState.CellClipboard.Count > 0 ||
                                 _editState.Layer2Clipboard.Count > 0 ||
                                 _editState.Layer5Clipboard.Count > 0 ||
                                 _editState.Layer7Clipboard.Count > 0 ||
                                 _editState.Layer8Clipboard.Count > 0;

            // 組合提示訊息
            var parts = new List<string>();
            if (copyLayer1 && layer1Count > 0) parts.Add($"L1:{layer1Count}");
            if (copyLayer2 && _editState.Layer2Clipboard.Count > 0) parts.Add($"L2:{_editState.Layer2Clipboard.Count}");
            if (copyLayer3 && layer3Count > 0) parts.Add($"L3:{layer3Count}");
            if (copyLayer4 && layer4Count > 0) parts.Add($"L4:{layer4Count}");
            if (copyLayer5 && _editState.Layer5Clipboard.Count > 0) parts.Add($"L5:{_editState.Layer5Clipboard.Count}");
            if (copyLayer7 && _editState.Layer7Clipboard.Count > 0) parts.Add($"L7:{_editState.Layer7Clipboard.Count}");
            if (copyLayer8 && _editState.Layer8Clipboard.Count > 0) parts.Add($"L8:{_editState.Layer8Clipboard.Count}");

            string layerInfo = parts.Count > 0 ? string.Join(", ", parts) : "無資料";
            this.toolStripStatusLabel1.Text = $"已複製 {selectedCells.Count} 格 ({layerInfo}) 來源: {_document.MapId}，左鍵選取貼上位置後按 Ctrl+V";

            // 清除選取框但保留複製資料
            _interaction.IsLayer4CopyMode = false;
            selectedRegion = new Rectangle();
            copyRegionBounds = new Rectangle();
            _editState.SelectedCells.Clear();
            _mapViewerControl.Refresh();
        }

        // 查看剪貼簿按鈕點擊
        private void btnViewClipboard_Click(object sender, EventArgs e)
        {
            ShowClipboardViewer();
        }

        // 顯示剪貼簿內容
        private void ShowClipboardViewer()
        {
            bool hasAnyData = _editState.CellClipboard.Count > 0 ||
                              _editState.Layer2Clipboard.Count > 0 ||
                              _editState.Layer5Clipboard.Count > 0 ||
                              _editState.Layer6Clipboard.Count > 0 ||
                              _editState.Layer7Clipboard.Count > 0 ||
                              _editState.Layer8Clipboard.Count > 0;

            if (!hasAnyData)
            {
                WinFormsMessageBox.Show("剪貼簿是空的。\n\n請先選取區域後按 Ctrl+C 複製。", "剪貼簿", MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            Form viewer = new Form
            {
                Text = "剪貼簿內容",
                Size = new Size(700, 500),
                StartPosition = FormStartPosition.CenterParent,
                MinimizeBox = false,
                MaximizeBox = true,
                ShowInTaskbar = false
            };

            TabControl tabs = new TabControl { Dock = DockStyle.Fill };

            // 摘要頁籤
            TabPage summaryTab = new TabPage("摘要");
            TextBox summaryBox = new TextBox
            {
                Multiline = true,
                ReadOnly = true,
                Dock = DockStyle.Fill,
                ScrollBars = ScrollBars.Vertical,
                Font = new Font("Consolas", 10)
            };

            var sb = new System.Text.StringBuilder();
            sb.AppendLine($"=== 剪貼簿摘要 ===");
            sb.AppendLine($"來源地圖: {_editState.SourceMapId}");
            sb.AppendLine($"複製原點: ({_editState.CopySourceOrigin.X}, {_editState.CopySourceOrigin.Y})");
            sb.AppendLine();
            sb.AppendLine($"Layer1 格子: {_editState.CellClipboard.Count(c => c.Layer1Cell1 != null || c.Layer1Cell2 != null)}");
            sb.AppendLine($"Layer2 項目: {_editState.Layer2Clipboard.Count}");
            sb.AppendLine($"Layer3 屬性: {_editState.CellClipboard.Count(c => c.Layer3Attr != null)}");
            sb.AppendLine($"Layer4 物件: {_editState.CellClipboard.Sum(c => c.Layer4Objects?.Count ?? 0)}");
            sb.AppendLine($"Layer5 項目: {_editState.Layer5Clipboard.Count}");
            sb.AppendLine($"Layer6 TileId: {_editState.Layer6Clipboard.Count}");
            sb.AppendLine($"Layer7 傳送點: {_editState.Layer7Clipboard.Count}");
            sb.AppendLine($"Layer8 特效: {_editState.Layer8Clipboard.Count}");
            summaryBox.Text = sb.ToString();
            summaryTab.GetControls().Add(summaryBox);
            tabs.GetTabPages().Add(summaryTab);

            // Layer2 頁籤
            if (_editState.Layer2Clipboard.Count > 0)
            {
                TabPage l2Tab = new TabPage($"Layer2 ({_editState.Layer2Clipboard.Count})");
                ListView lv2 = new ListView
                {
                    Dock = DockStyle.Fill,
                    View = View.Details,
                    FullRowSelect = true,
                    GridLines = true
                };
                lv2.Columns.Add("相對X", 60);
                lv2.Columns.Add("相對Y", 60);
                lv2.Columns.Add("TileId", 80);
                lv2.Columns.Add("IndexId", 60);

                foreach (var item in _editState.Layer2Clipboard)
                {
                    var lvi = new ListViewItem(item.X.ToString());
                    lvi.SubItems.Add(item.Y.ToString());
                    lvi.SubItems.Add(item.TileId.ToString());
                    lvi.SubItems.Add(item.IndexId.ToString());
                    lv2.Items.Add(lvi);
                }
                l2Tab.GetControls().Add(lv2);
                tabs.GetTabPages().Add(l2Tab);
            }

            // Layer4 頁籤
            var allL4 = _editState.CellClipboard.SelectMany(c => c.Layer4Objects ?? new List<CopiedObjectTile>()).ToList();
            if (allL4.Count > 0)
            {
                TabPage l4Tab = new TabPage($"Layer4 ({allL4.Count})");
                ListView lv4 = new ListView
                {
                    Dock = DockStyle.Fill,
                    View = View.Details,
                    FullRowSelect = true,
                    GridLines = true
                };
                lv4.Columns.Add("相對X", 60);
                lv4.Columns.Add("相對Y", 60);
                lv4.Columns.Add("GroupId", 70);
                lv4.Columns.Add("Layer", 50);
                lv4.Columns.Add("TileId", 80);

                foreach (var obj in allL4)
                {
                    var lvi = new ListViewItem(obj.RelativeX.ToString());
                    lvi.SubItems.Add(obj.RelativeY.ToString());
                    lvi.SubItems.Add(obj.GroupId.ToString());
                    lvi.SubItems.Add(obj.Layer.ToString());
                    lvi.SubItems.Add(obj.TileId.ToString());
                    lv4.Items.Add(lvi);
                }
                l4Tab.GetControls().Add(lv4);
                tabs.GetTabPages().Add(l4Tab);
            }

            // Layer5 頁籤
            if (_editState.Layer5Clipboard.Count > 0)
            {
                TabPage l5Tab = new TabPage($"Layer5 ({_editState.Layer5Clipboard.Count})");
                ListView lv5 = new ListView
                {
                    Dock = DockStyle.Fill,
                    View = View.Details,
                    FullRowSelect = true,
                    GridLines = true
                };
                lv5.Columns.Add("相對X", 60);
                lv5.Columns.Add("相對Y", 60);
                lv5.Columns.Add("ObjectIndex", 90);
                lv5.Columns.Add("Type", 50);

                foreach (var item in _editState.Layer5Clipboard)
                {
                    var lvi = new ListViewItem(item.X.ToString());
                    lvi.SubItems.Add(item.Y.ToString());
                    lvi.SubItems.Add(item.ObjectIndex.ToString());
                    lvi.SubItems.Add(item.Type.ToString());
                    lv5.Items.Add(lvi);
                }
                l5Tab.GetControls().Add(lv5);
                tabs.GetTabPages().Add(l5Tab);
            }

            // Layer7 頁籤
            if (_editState.Layer7Clipboard.Count > 0)
            {
                TabPage l7Tab = new TabPage($"Layer7 ({_editState.Layer7Clipboard.Count})");
                ListView lv7 = new ListView
                {
                    Dock = DockStyle.Fill,
                    View = View.Details,
                    FullRowSelect = true,
                    GridLines = true
                };
                lv7.Columns.Add("相對X", 60);
                lv7.Columns.Add("相對Y", 60);
                lv7.Columns.Add("TargetMapId", 90);
                lv7.Columns.Add("PortalId", 70);
                lv7.Columns.Add("Name", 100);

                foreach (var item in _editState.Layer7Clipboard)
                {
                    var lvi = new ListViewItem(item.X.ToString());
                    lvi.SubItems.Add(item.Y.ToString());
                    lvi.SubItems.Add(item.TargetMapId.ToString());
                    lvi.SubItems.Add(item.PortalId.ToString());
                    lvi.SubItems.Add(item.Name ?? "");
                    lv7.Items.Add(lvi);
                }
                l7Tab.GetControls().Add(lv7);
                tabs.GetTabPages().Add(l7Tab);
            }

            // Layer8 頁籤
            if (_editState.Layer8Clipboard.Count > 0)
            {
                TabPage l8Tab = new TabPage($"Layer8 ({_editState.Layer8Clipboard.Count})");
                ListView lv8 = new ListView
                {
                    Dock = DockStyle.Fill,
                    View = View.Details,
                    FullRowSelect = true,
                    GridLines = true
                };
                lv8.Columns.Add("相對X", 60);
                lv8.Columns.Add("相對Y", 60);
                lv8.Columns.Add("SprId", 80);
                lv8.Columns.Add("ExtData", 80);

                foreach (var item in _editState.Layer8Clipboard)
                {
                    var lvi = new ListViewItem(item.X.ToString());
                    lvi.SubItems.Add(item.Y.ToString());
                    lvi.SubItems.Add(item.SprId.ToString());
                    lvi.SubItems.Add(item.ExtendedData.ToString());
                    lv8.Items.Add(lvi);
                }
                l8Tab.GetControls().Add(lv8);
                tabs.GetTabPages().Add(l8Tab);
            }

            viewer.GetControls().Add(tabs);
            viewer.ShowDialog(this);
        }

        // 貼上選取區域
        private void PasteSelectedCells()
        {
            // 檢查任何一個剪貼簿是否有資料
            bool hasAnyClipboardData = _editState.CellClipboard.Count > 0 ||
                                       _editState.Layer2Clipboard.Count > 0 ||
                                       _editState.Layer5Clipboard.Count > 0 ||
                                       _editState.Layer6Clipboard.Count > 0 ||
                                       _editState.Layer7Clipboard.Count > 0 ||
                                       _editState.Layer8Clipboard.Count > 0;

            if (!hasLayer4Clipboard || !hasAnyClipboardData)
            {
                this.toolStripStatusLabel1.Text = "剪貼簿沒有資料，請先使用左鍵選取區域後按 Ctrl+C 複製";
                return;
            }

            // 需要先選取貼上位置（檢查 CopyRegionOrigin 是否有效）
            if (_editState.CopyRegionOrigin.X < 0 || _editState.CopyRegionOrigin.Y < 0)
            {
                this.toolStripStatusLabel1.Text = "請使用左鍵選取貼上位置";
                return;
            }

            // 取得貼上位置的全域 Layer1 座標
            int pasteOriginX = _editState.CopyRegionOrigin.X;
            int pasteOriginY = _editState.CopyRegionOrigin.Y;


            int layer1Count = 0, layer3Count = 0, layer4Count = 0;
            int skippedCount = 0;

            // 建立 Undo 記錄
            var undoAction = new UndoAction
            {
                Description = $"貼上 {_editState.CellClipboard.Count} 格資料"
            };

            // 貼上每個格子的資料
            foreach (var cellData in _editState.CellClipboard)
            {
                // 計算目標全域 Layer1 座標
                int targetGlobalX = pasteOriginX + cellData.RelativeX;
                int targetGlobalY = pasteOriginY + cellData.RelativeY;

                // 轉換為遊戲座標（Layer3）來找 S32
                int targetGameX = targetGlobalX / 2;
                int targetGameY = targetGlobalY;

                // 找到目標格子所屬的 S32
                S32Data targetS32 = GetS32DataByGameCoords(targetGameX, targetGameY);
                if (targetS32 == null)
                {
                    skippedCount++;
                    continue;
                }

                // 計算目標 S32 內的局部座標
                int localX = targetGlobalX - targetS32.SegInfo.nLinBeginX * 2;
                int localY = targetGlobalY - targetS32.SegInfo.nLinBeginY;

                // 檢查座標是否有效
                if (localX < 0 || localX >= 128 || localY < 0 || localY >= 64)
                {
                    skippedCount++;
                    continue;
                }

                // Layer1 資料（地板）- 記錄舊值和新值到 Undo
                if (cellData.Layer1Cell1 != null && localX >= 0 && localX < 128)
                {
                    var oldCell = targetS32.Layer1[localY, localX];
                    undoAction.ModifiedLayer1.Add(new UndoLayer1Info
                    {
                        S32FilePath = targetS32.FilePath,
                        LocalX = localX,
                        LocalY = localY,
                        OldTileId = oldCell?.TileId ?? 0,
                        OldIndexId = oldCell?.IndexId ?? 0,
                        NewTileId = cellData.Layer1Cell1.TileId,
                        NewIndexId = cellData.Layer1Cell1.IndexId
                    });

                    targetS32.Layer1[localY, localX] = new TileCell
                    {
                        X = localX,
                        Y = localY,
                        TileId = cellData.Layer1Cell1.TileId,
                        IndexId = cellData.Layer1Cell1.IndexId
                    };
                    if (cellData.Layer1Cell1.TileId > 0) layer1Count++;
                    targetS32.IsModified = true;
                }
                if (cellData.Layer1Cell2 != null && localX + 1 >= 0 && localX + 1 < 128)
                {
                    var oldCell = targetS32.Layer1[localY, localX + 1];
                    undoAction.ModifiedLayer1.Add(new UndoLayer1Info
                    {
                        S32FilePath = targetS32.FilePath,
                        LocalX = localX + 1,
                        LocalY = localY,
                        OldTileId = oldCell?.TileId ?? 0,
                        OldIndexId = oldCell?.IndexId ?? 0,
                        NewTileId = cellData.Layer1Cell2.TileId,
                        NewIndexId = cellData.Layer1Cell2.IndexId
                    });

                    targetS32.Layer1[localY, localX + 1] = new TileCell
                    {
                        X = localX + 1,
                        Y = localY,
                        TileId = cellData.Layer1Cell2.TileId,
                        IndexId = cellData.Layer1Cell2.IndexId
                    };
                    if (cellData.Layer1Cell2.TileId > 0) layer1Count++;
                    targetS32.IsModified = true;
                }

                // Layer3 資料（屬性）- 記錄舊值和新值到 Undo
                if (cellData.Layer3Attr != null)
                {
                    int layer3X = localX / 2;
                    if (layer3X >= 0 && layer3X < 64)
                    {
                        var oldAttr = targetS32.Layer3[localY, layer3X];
                        undoAction.ModifiedLayer3.Add(new UndoLayer3Info
                        {
                            S32FilePath = targetS32.FilePath,
                            LocalX = layer3X,
                            LocalY = localY,
                            OldAttribute1 = oldAttr?.Attribute1 ?? 0,
                            OldAttribute2 = oldAttr?.Attribute2 ?? 0,
                            NewAttribute1 = cellData.Layer3Attr.Attribute1,
                            NewAttribute2 = cellData.Layer3Attr.Attribute2
                        });

                        targetS32.Layer3[localY, layer3X] = new MapAttribute
                        {
                            Attribute1 = cellData.Layer3Attr.Attribute1,
                            Attribute2 = cellData.Layer3Attr.Attribute2
                        };
                        layer3Count++;
                        targetS32.IsModified = true;
                    }
                }

                // Layer4 資料（物件）- 加入新物件並記錄到 Undo
                if (cellData.Layer4Objects.Count > 0)
                {
                    // 加入新物件
                    foreach (var objData in cellData.Layer4Objects.OrderBy(o => o.OriginalIndex))
                    {
                        // 計算物件在目標 S32 內的局部座標（Layer1 座標系統 0-127）
                        int objTargetGlobalX = pasteOriginX + objData.RelativeX;
                        int objTargetGlobalY = pasteOriginY + objData.RelativeY;
                        int objLocalLayer1X = objTargetGlobalX - targetS32.SegInfo.nLinBeginX * 2;
                        int objLocalY = objTargetGlobalY - targetS32.SegInfo.nLinBeginY;

                        // obj.X 是 Layer1 座標，可能超過 127（物件可以跨格子）
                        if (objLocalLayer1X >= 0 && objLocalY >= 0 && objLocalY < 64)
                        {
                            var newObj = new ObjectTile
                            {
                                GroupId = objData.GroupId,
                                X = objLocalLayer1X,  // 使用 Layer1 座標
                                Y = objLocalY,
                                Layer = objData.Layer,
                                IndexId = objData.IndexId,
                                TileId = objData.TileId
                            };
                            targetS32.Layer4.Add(newObj);
                            Layer4Index_Add(targetS32, newObj);
                            layer4Count++;

                            // 記錄新增的物件到 Undo（還原時要刪除）
                            undoAction.AddedObjects.Add(new UndoObjectInfo
                            {
                                S32FilePath = targetS32.FilePath,
                                GameX = targetS32.SegInfo.nLinBeginX + objLocalLayer1X / 2,
                                GameY = targetS32.SegInfo.nLinBeginY + objLocalY,
                                LocalX = objLocalLayer1X,
                                LocalY = objLocalY,
                                GroupId = objData.GroupId,
                                Layer = objData.Layer,
                                IndexId = objData.IndexId,
                                TileId = objData.TileId
                            });
                        }
                    }
                    targetS32.IsModified = true;
                }
            }

            // 儲存 Undo 記錄（如果有任何修改）
            if (undoAction.AddedObjects.Count > 0 || undoAction.ModifiedLayer1.Count > 0 || undoAction.ModifiedLayer3.Count > 0)
            {
                PushUndoAction(undoAction);
            }

            // 合併 Layer2 和 Layer5-8 到所有受影響的目標 S32（根據設定）
            int layer2AddedCount = 0;
            int layer5to8CopiedCount = 0;
            var affectedS32Set = new HashSet<S32Data>();
            foreach (var cellData in _editState.CellClipboard)
            {
                int targetGlobalX = pasteOriginX + cellData.RelativeX;
                int targetGlobalY = pasteOriginY + cellData.RelativeY;
                int targetGameX = targetGlobalX / 2;
                int targetGameY = targetGlobalY;
                S32Data targetS32 = GetS32DataByGameCoords(targetGameX, targetGameY);
                if (targetS32 != null)
                    affectedS32Set.Add(targetS32);
            }

            // Layer2 - 貼圖層（需要計算正確的目標座標）- 根據設定
            if (copySettingLayer2 && _editState.Layer2Clipboard.Count > 0)
            {
                foreach (var item in _editState.Layer2Clipboard)
                {
                    // item.X, item.Y 是相對座標（相對於複製原點的 Layer1 座標）
                    int targetGlobalL1X = pasteOriginX + item.X;
                    int targetGlobalY = pasteOriginY + item.Y;

                    // 找到目標 S32
                    int targetGameX = targetGlobalL1X / 2;
                    int targetGameY = targetGlobalY;
                    S32Data l2TargetS32 = GetS32DataByGameCoords(targetGameX, targetGameY);
                    if (l2TargetS32 == null) continue;

                    // 計算目標 S32 內的局部座標
                    int localL1X = targetGlobalL1X - l2TargetS32.SegInfo.nLinBeginX * 2;
                    int localY = targetGlobalY - l2TargetS32.SegInfo.nLinBeginY;

                    // 檢查座標是否在有效範圍內 (Layer2 X 可達 255, Y 範圍 0-127)
                    if (localL1X < 0 || localL1X > 255 || localY < 0 || localY >= 128)
                        continue;

                    // 檢查是否已存在
                    if (!l2TargetS32.Layer2.Any(l => l.X == localL1X && l.Y == localY && l.TileId == item.TileId))
                    {
                        var newLayer2Item = new Layer2Item
                        {
                            X = (byte)localL1X,
                            Y = (byte)localY,
                            IndexId = item.IndexId,
                            TileId = item.TileId,
                            UK = item.UK
                        };
                        l2TargetS32.Layer2.Add(newLayer2Item);
                        layer2AddedCount++;
                        l2TargetS32.IsModified = true;

                        // 記錄 Undo 資訊
                        undoAction.AddedLayer2Items.Add(new UndoLayer2Info
                        {
                            S32FilePath = l2TargetS32.FilePath,
                            X = newLayer2Item.X,
                            Y = newLayer2Item.Y,
                            IndexId = newLayer2Item.IndexId,
                            TileId = newLayer2Item.TileId,
                            UK = newLayer2Item.UK
                        });
                    }
                }
            }

            // Layer6 不再複製（由 Layer1/Layer2/Layer4 的 TileId 決定）

            // Layer5 - 透明圖塊（需要計算正確的目標座標）- 根據設定
            if (copySettingLayer5 && _editState.Layer5Clipboard.Count > 0)
            {
                foreach (var item in _editState.Layer5Clipboard)
                {
                    // item.X, item.Y 是相對座標（相對於複製原點）
                    int targetGlobalL1X = pasteOriginX + item.X;
                    int targetGlobalY = pasteOriginY + item.Y;

                    // 找到目標 S32
                    int targetGameX = targetGlobalL1X / 2;
                    int targetGameY = targetGlobalY;
                    S32Data l5TargetS32 = GetS32DataByGameCoords(targetGameX, targetGameY);
                    if (l5TargetS32 == null) continue;

                    // 計算目標 S32 內的局部座標
                    int localL1X = targetGlobalL1X - l5TargetS32.SegInfo.nLinBeginX * 2;
                    int localY = targetGlobalY - l5TargetS32.SegInfo.nLinBeginY;

                    // 檢查座標是否有效
                    if (localL1X < 0 || localL1X >= 128 || localY < 0 || localY >= 64)
                        continue;

                    // 檢查是否已存在
                    if (!l5TargetS32.Layer5.Any(l => l.X == localL1X && l.Y == localY && l.ObjectIndex == item.ObjectIndex))
                    {
                        l5TargetS32.Layer5.Add(new Layer5Item
                        {
                            X = (byte)localL1X,
                            Y = (byte)localY,
                            ObjectIndex = item.ObjectIndex,
                            Type = item.Type
                        });
                        l5TargetS32.IsModified = true;
                    }
                }
            }

            // Layer7 - 傳送點（需要計算正確的目標座標）- 根據設定
            if (copySettingLayer7 && _editState.Layer7Clipboard.Count > 0)
            {
                foreach (var item in _editState.Layer7Clipboard)
                {
                    // item.X, item.Y 是相對座標（相對於複製原點的 Layer3 座標）
                    // 先轉為 Layer1 座標系，再計算目標
                    int targetGlobalL1X = pasteOriginX + item.X * 2;
                    int targetGlobalY = pasteOriginY + item.Y;

                    // 找到目標 S32
                    int targetGameX = targetGlobalL1X / 2;
                    int targetGameY = targetGlobalY;
                    S32Data l7TargetS32 = GetS32DataByGameCoords(targetGameX, targetGameY);
                    if (l7TargetS32 == null) continue;

                    // 計算目標 S32 內的局部 Layer3 座標
                    int localL3X = targetGameX - l7TargetS32.SegInfo.nLinBeginX;
                    int localY = targetGlobalY - l7TargetS32.SegInfo.nLinBeginY;

                    // 檢查座標是否有效
                    if (localL3X < 0 || localL3X >= 64 || localY < 0 || localY >= 64)
                        continue;

                    // 檢查是否已存在
                    if (!l7TargetS32.Layer7.Any(l => l.Name == item.Name && l.X == localL3X && l.Y == localY))
                    {
                        l7TargetS32.Layer7.Add(new Layer7Item
                        {
                            Name = item.Name,
                            X = (byte)localL3X,
                            Y = (byte)localY,
                            TargetMapId = item.TargetMapId,
                            PortalId = item.PortalId
                        });
                        l7TargetS32.IsModified = true;
                    }
                }
            }

            // Layer8 - 特效（需要計算正確的目標座標）- 根據設定
            // 注意：Layer8 的 X, Y 是全域遊戲座標（絕對座標），不是本地座標
            if (copySettingLayer8 && _editState.Layer8Clipboard.Count > 0)
            {
                foreach (var item in _editState.Layer8Clipboard)
                {
                    // item.X, item.Y 是相對座標（相對於複製原點的 Layer3 座標）
                    // 先轉為 Layer1 座標系，再計算目標全域遊戲座標
                    int targetGlobalL1X = pasteOriginX + item.X * 2;
                    int targetGlobalY = pasteOriginY + item.Y;

                    // 計算目標全域遊戲座標
                    int targetGameX = targetGlobalL1X / 2;
                    int targetGameY = targetGlobalY;

                    // 找到目標 S32
                    S32Data l8TargetS32 = GetS32DataByGameCoords(targetGameX, targetGameY);
                    if (l8TargetS32 == null) continue;

                    // 計算本地座標用於驗證範圍
                    int localL3X = targetGameX - l8TargetS32.SegInfo.nLinBeginX;
                    int localY = targetGlobalY - l8TargetS32.SegInfo.nLinBeginY;

                    // 檢查座標是否有效
                    if (localL3X < 0 || localL3X >= 64 || localY < 0 || localY >= 64)
                        continue;

                    // 檢查是否已存在（使用全域座標比較）
                    if (!l8TargetS32.Layer8.Any(l => l.SprId == item.SprId && l.X == targetGameX && l.Y == targetGameY))
                    {
                        // Layer8 存儲全域遊戲座標
                        l8TargetS32.Layer8.Add(new Layer8Item
                        {
                            SprId = item.SprId,
                            X = (ushort)targetGameX,
                            Y = (ushort)targetGameY,
                            ExtendedData = item.ExtendedData
                        });
                        l8TargetS32.IsModified = true;
                    }
                }
            }

            // 清除選取模式
            _interaction.IsLayer4CopyMode = false;
            selectedRegion = new Rectangle();
            copyRegionBounds = new Rectangle();
            _editState.SelectedCells.Clear();

            // 重新渲染地圖
            RenderS32Map();

            // 檢查是否跨地圖貼上
            bool isCrossMap = !string.IsNullOrEmpty(_editState.SourceMapId) && _editState.SourceMapId != _document.MapId;

            // 組合提示訊息
            var parts = new List<string>();
            if (layer1Count > 0) parts.Add($"L1:{layer1Count}");
            if (layer2AddedCount > 0) parts.Add($"L2:+{layer2AddedCount}");
            if (layer3Count > 0) parts.Add($"L3:{layer3Count}");
            if (layer4Count > 0) parts.Add($"L4:{layer4Count}");
            if (layer5to8CopiedCount > 0) parts.Add($"L6:+{layer5to8CopiedCount}");

            string layerInfo = parts.Count > 0 ? string.Join(", ", parts) : "無資料";
            string message = $"已貼上 {_editState.CellClipboard.Count} 格 ({layerInfo})";
            if (isCrossMap)
                message += $" (從 {_editState.SourceMapId} 跨地圖貼上)";
            if (skippedCount > 0)
                message += $"，{skippedCount} 格超出範圍被跳過";
            this.toolStripStatusLabel1.Text = message;

            // 清除快取並重新渲染
            ClearS32BlockCache();
            RenderS32Map();

            // 更新 Layer5 異常檢查按鈕
            UpdateMapValidateButton();
        }

        // 取消複製/貼上模式
        private void CancelLayer4CopyPaste()
        {
            _interaction.IsLayer4CopyMode = false;
            // 恢復顯示全部群組
            UpdateGroupThumbnailsList();
            selectedRegion = new Rectangle();
            copyRegionBounds = new Rectangle();
            _editState.SelectedCells.Clear();
            _mapViewerControl.Refresh();
            this.toolStripStatusLabel1.Text = "已取消複製/貼上模式";
        }

        // 新增 Undo 記錄
        private void PushUndoAction(UndoAction action)
        {
            _editState.UndoHistory.Push(action);
            // 新操作會清空 redo 歷史
            _editState.RedoHistory.Clear();
            // 限制歷史記錄數量
            if (_editState.UndoHistory.Count > MAX_UNDO_HISTORY)
            {
                var tempStack = new Stack<UndoAction>();
                for (int i = 0; i < MAX_UNDO_HISTORY; i++)
                {
                    tempStack.Push(_editState.UndoHistory.Pop());
                }
                _editState.UndoHistory.Clear();
                while (tempStack.Count > 0)
                {
                    _editState.UndoHistory.Push(tempStack.Pop());
                }
            }
        }

        // 執行還原 (Ctrl+Z)
        private void UndoLastAction()
        {
            if (_editState.UndoHistory.Count == 0)
            {
                this.toolStripStatusLabel1.Text = "沒有可還原的操作";
                return;
            }

            var action = _editState.UndoHistory.Pop();

            // 還原刪除的物件（重新新增）
            foreach (var objInfo in action.RemovedObjects)
            {
                S32Data targetS32 = null;
                if (_document.S32Files.TryGetValue(objInfo.S32FilePath, out targetS32))
                {
                    var newObj = new ObjectTile
                    {
                        GroupId = objInfo.GroupId,
                        X = objInfo.LocalX,
                        Y = objInfo.LocalY,
                        Layer = objInfo.Layer,
                        IndexId = objInfo.IndexId,
                        TileId = objInfo.TileId
                    };
                    targetS32.Layer4.Add(newObj);
                    Layer4Index_Add(targetS32, newObj);
                    targetS32.IsModified = true;
                }
            }

            // 還原新增的物件（刪除）
            foreach (var objInfo in action.AddedObjects)
            {
                S32Data targetS32 = null;
                if (_document.S32Files.TryGetValue(objInfo.S32FilePath, out targetS32))
                {
                    var objToRemove = targetS32.Layer4.FirstOrDefault(o =>
                        o.X == objInfo.LocalX &&
                        o.Y == objInfo.LocalY &&
                        o.GroupId == objInfo.GroupId &&
                        o.Layer == objInfo.Layer &&
                        o.IndexId == objInfo.IndexId &&
                        o.TileId == objInfo.TileId);

                    if (objToRemove != null)
                    {
                        targetS32.Layer4.Remove(objToRemove);
                        Layer4Index_Remove(targetS32, objToRemove);
                        targetS32.IsModified = true;
                    }
                }
            }

            // 還原新增的第二層資料（刪除）
            foreach (var layer2Info in action.AddedLayer2Items)
            {
                S32Data targetS32 = null;
                if (_document.S32Files.TryGetValue(layer2Info.S32FilePath, out targetS32))
                {
                    var itemToRemove = targetS32.Layer2.FirstOrDefault(l =>
                        l.X == layer2Info.X &&
                        l.Y == layer2Info.Y &&
                        l.TileId == layer2Info.TileId &&
                        l.IndexId == layer2Info.IndexId);

                    if (itemToRemove != null)
                    {
                        targetS32.Layer2.Remove(itemToRemove);
                        targetS32.IsModified = true;
                    }
                }
            }

            // 還原刪除的第七層資料（重新新增）
            foreach (var layer7Info in action.RemovedLayer7Items)
            {
                S32Data targetS32 = null;
                if (_document.S32Files.TryGetValue(layer7Info.S32FilePath, out targetS32))
                {
                    targetS32.Layer7.Add(new Layer7Item
                    {
                        Name = layer7Info.Name,
                        X = layer7Info.X,
                        Y = layer7Info.Y,
                        TargetMapId = layer7Info.TargetMapId,
                        PortalId = layer7Info.PortalId
                    });
                    targetS32.IsModified = true;
                }
            }

            // 還原修改的第一層資料（地板）
            foreach (var layer1Info in action.ModifiedLayer1)
            {
                S32Data targetS32 = null;
                if (_document.S32Files.TryGetValue(layer1Info.S32FilePath, out targetS32))
                {
                    targetS32.Layer1[layer1Info.LocalY, layer1Info.LocalX] = new TileCell
                    {
                        X = layer1Info.LocalX,
                        Y = layer1Info.LocalY,
                        TileId = layer1Info.OldTileId,
                        IndexId = layer1Info.OldIndexId
                    };
                    targetS32.IsModified = true;
                }
            }

            // 還原修改的第三層資料（屬性）
            foreach (var layer3Info in action.ModifiedLayer3)
            {
                S32Data targetS32 = null;
                if (_document.S32Files.TryGetValue(layer3Info.S32FilePath, out targetS32))
                {
                    targetS32.Layer3[layer3Info.LocalY, layer3Info.LocalX] = new MapAttribute
                    {
                        Attribute1 = layer3Info.OldAttribute1,
                        Attribute2 = layer3Info.OldAttribute2
                    };
                    targetS32.IsModified = true;
                }
            }

            // 將此動作放入 redo 歷史
            _editState.RedoHistory.Push(action);

            // 清除快取並重新渲染地圖
            ClearS32BlockCache();
            RenderS32Map();

            // 更新 Layer5 異常檢查按鈕
            UpdateMapValidateButton();

            this.toolStripStatusLabel1.Text = $"已還原: {action.Description} (Ctrl+Z: {_editState.UndoHistory.Count} / Ctrl+Y: {_editState.RedoHistory.Count})";
        }

        // 執行重做 (Ctrl+Y)
        private void RedoLastAction()
        {
            if (_editState.RedoHistory.Count == 0)
            {
                this.toolStripStatusLabel1.Text = "沒有可重做的操作";
                return;
            }

            var action = _editState.RedoHistory.Pop();

            // 重做新增的物件（重新新增）
            foreach (var objInfo in action.AddedObjects)
            {
                S32Data targetS32 = null;
                if (_document.S32Files.TryGetValue(objInfo.S32FilePath, out targetS32))
                {
                    var newObj = new ObjectTile
                    {
                        GroupId = objInfo.GroupId,
                        X = objInfo.LocalX,
                        Y = objInfo.LocalY,
                        Layer = objInfo.Layer,
                        IndexId = objInfo.IndexId,
                        TileId = objInfo.TileId
                    };
                    targetS32.Layer4.Add(newObj);
                    Layer4Index_Add(targetS32, newObj);
                    targetS32.IsModified = true;
                }
            }

            // 重做刪除的物件（重新刪除）
            foreach (var objInfo in action.RemovedObjects)
            {
                S32Data targetS32 = null;
                if (_document.S32Files.TryGetValue(objInfo.S32FilePath, out targetS32))
                {
                    var objToRemove = targetS32.Layer4.FirstOrDefault(o =>
                        o.X == objInfo.LocalX &&
                        o.Y == objInfo.LocalY &&
                        o.GroupId == objInfo.GroupId &&
                        o.Layer == objInfo.Layer &&
                        o.IndexId == objInfo.IndexId &&
                        o.TileId == objInfo.TileId);

                    if (objToRemove != null)
                    {
                        targetS32.Layer4.Remove(objToRemove);
                        Layer4Index_Remove(targetS32, objToRemove);
                        targetS32.IsModified = true;
                    }
                }
            }

            // 重做刪除的第七層資料（重新刪除）
            foreach (var layer7Info in action.RemovedLayer7Items)
            {
                S32Data targetS32 = null;
                if (_document.S32Files.TryGetValue(layer7Info.S32FilePath, out targetS32))
                {
                    var itemToRemove = targetS32.Layer7.FirstOrDefault(l =>
                        l.Name == layer7Info.Name &&
                        l.X == layer7Info.X &&
                        l.Y == layer7Info.Y &&
                        l.TargetMapId == layer7Info.TargetMapId &&
                        l.PortalId == layer7Info.PortalId);

                    if (itemToRemove != null)
                    {
                        targetS32.Layer7.Remove(itemToRemove);
                        targetS32.IsModified = true;
                    }
                }
            }

            // 重做修改的第一層資料（套用新值）
            foreach (var layer1Info in action.ModifiedLayer1)
            {
                S32Data targetS32 = null;
                if (_document.S32Files.TryGetValue(layer1Info.S32FilePath, out targetS32))
                {
                    targetS32.Layer1[layer1Info.LocalY, layer1Info.LocalX] = new TileCell
                    {
                        X = layer1Info.LocalX,
                        Y = layer1Info.LocalY,
                        TileId = layer1Info.NewTileId,
                        IndexId = layer1Info.NewIndexId
                    };
                    targetS32.IsModified = true;
                }
            }

            // 重做修改的第三層資料（套用新值）
            foreach (var layer3Info in action.ModifiedLayer3)
            {
                S32Data targetS32 = null;
                if (_document.S32Files.TryGetValue(layer3Info.S32FilePath, out targetS32))
                {
                    targetS32.Layer3[layer3Info.LocalY, layer3Info.LocalX] = new MapAttribute
                    {
                        Attribute1 = layer3Info.NewAttribute1,
                        Attribute2 = layer3Info.NewAttribute2
                    };
                    targetS32.IsModified = true;
                }
            }

            // 將此動作放回 undo 歷史
            _editState.UndoHistory.Push(action);

            // 清除快取並重新渲染地圖
            ClearS32BlockCache();
            RenderS32Map();

            // 更新 Layer5 異常檢查按鈕
            UpdateMapValidateButton();

            this.toolStripStatusLabel1.Text = $"已重做: {action.Description} (Ctrl+Z: {_editState.UndoHistory.Count} / Ctrl+Y: {_editState.RedoHistory.Count})";
        }

        // 取得等距菱形區域內的所有格子（支援長方形）
        private List<SelectedCell> GetCellsInIsometricRegion(Rectangle region)
        {
            List<SelectedCell> result = new List<SelectedCell>();

            if (string.IsNullOrEmpty(_document.MapId) || !Share.MapDataList.ContainsKey(_document.MapId))
                return result;

            Struct.L1Map currentMap = Share.MapDataList[_document.MapId];

            // 計算菱形的參數（使用實際寬高）
            float centerX = region.Left + region.Width / 2f;
            float centerY = region.Top + region.Height / 2f;
            float halfWidth = region.Width / 2f;
            float halfHeight = region.Height / 2f;

            foreach (var s32Data in _document.S32Files.Values)
            {
                // 使用與 RenderS32Map 相同的座標計算方式
                int[] loc = s32Data.SegInfo.GetLoc(1.0);
                int mx = loc[0];
                int my = loc[1];

                for (int y = 0; y < 64; y++)
                {
                    for (int x = 0; x < 128; x++)
                    {
                        // 與 drawTilBlock 相同的像素計算
                        int localBaseX = 0;
                        int localBaseY = 63 * 12;
                        localBaseX -= 24 * (x / 2);
                        localBaseY -= 12 * (x / 2);

                        int X = mx + localBaseX + x * 24 + y * 24;
                        int Y = my + localBaseY + y * 12;

                        // 格子中心點
                        float cellCenterX = X + 12;
                        float cellCenterY = Y + 12;

                        // 檢查是否在等距菱形內
                        if (IsPointInIsometricRegion(cellCenterX, cellCenterY, centerX, centerY, halfWidth, halfHeight))
                        {
                            result.Add(new SelectedCell
                            {
                                S32Data = s32Data,
                                LocalX = x,
                                LocalY = y
                            });
                        }
                    }
                }
            }

            return result;
        }

        // 檢查點是否在等距菱形內
        private bool IsPointInIsometricRegion(float px, float py, float centerX, float centerY, float halfWidth, float halfHeight)
        {
            // 使用標準化的菱形檢測公式
            float dx = Math.Abs(px - centerX) / halfWidth;
            float dy = Math.Abs(py - centerY) / halfHeight;
            return (dx + dy) <= 1.0f;
        }

        // 根據選中的格子計算對齊格子的菱形邊界
        private Rectangle GetAlignedBoundsFromCells(List<SelectedCell> cells)
        {
            if (cells.Count == 0 || string.IsNullOrEmpty(_document.MapId) || !Share.MapDataList.ContainsKey(_document.MapId))
                return new Rectangle();

            Struct.L1Map currentMap = Share.MapDataList[_document.MapId];

            // 計算所有格子的螢幕座標範圍
            int minScreenX = int.MaxValue, maxScreenX = int.MinValue;
            int minScreenY = int.MaxValue, maxScreenY = int.MinValue;

            foreach (var cell in cells)
            {
                // 使用與 RenderS32Map 相同的座標計算方式（GetLoc + drawTilBlock 公式）
                int[] loc = cell.S32Data.SegInfo.GetLoc(1.0);
                int mx = loc[0];
                int my = loc[1];

                // 與 drawTilBlock 相同的像素計算
                int localBaseX = 0;
                int localBaseY = 63 * 12;
                localBaseX -= 24 * (cell.LocalX / 2);
                localBaseY -= 12 * (cell.LocalX / 2);

                int X = mx + localBaseX + cell.LocalX * 24 + cell.LocalY * 24;
                int Y = my + localBaseY + cell.LocalY * 12;

                // 菱形的四個頂點
                int left = X + 0;
                int right = X + 24;
                int top = Y + 0;
                int bottom = Y + 24;

                minScreenX = Math.Min(minScreenX, left);
                maxScreenX = Math.Max(maxScreenX, right);
                minScreenY = Math.Min(minScreenY, top);
                maxScreenY = Math.Max(maxScreenY, bottom);
            }

            // 計算菱形的中心和大小
            int centerX = (minScreenX + maxScreenX) / 2;
            int centerY = (minScreenY + maxScreenY) / 2;
            int width = maxScreenX - minScreenX;
            int height = maxScreenY - minScreenY;

            // 返回一個矩形，表示菱形的邊界框
            return new Rectangle(centerX - width / 2, centerY - height / 2, width, height);
        }

        // 取得螢幕矩形區域內的所有格子（用於拖曳選取時即時對齊）
        private List<SelectedCell> GetCellsInScreenRect(Rectangle screenRect)
        {
            List<SelectedCell> result = new List<SelectedCell>();

            if (string.IsNullOrEmpty(_document.MapId) || !Share.MapDataList.ContainsKey(_document.MapId))
                return result;

            Struct.L1Map currentMap = Share.MapDataList[_document.MapId];

            foreach (var s32Data in _document.S32Files.Values)
            {
                // 使用與 RenderS32Map 相同的座標計算方式
                int[] loc = s32Data.SegInfo.GetLoc(1.0);
                int mx = loc[0];
                int my = loc[1];

                for (int y = 0; y < 64; y++)
                {
                    for (int x = 0; x < 128; x++)
                    {
                        // 與 drawTilBlock 相同的像素計算
                        int localBaseX = 0;
                        int localBaseY = 63 * 12;
                        localBaseX -= 24 * (x / 2);
                        localBaseY -= 12 * (x / 2);

                        int X = mx + localBaseX + x * 24 + y * 24;
                        int Y = my + localBaseY + y * 12;

                        // 格子中心點
                        int cellCenterX = X + 12;
                        int cellCenterY = Y + 12;

                        // 檢查格子中心是否在螢幕矩形內
                        if (screenRect.Contains(cellCenterX, cellCenterY))
                        {
                            result.Add(new SelectedCell
                            {
                                S32Data = s32Data,
                                LocalX = x,
                                LocalY = y
                            });
                        }
                    }
                }
            }

            return result;
        }

        // 從螢幕起點到終點，計算等距投影矩形範圍內的所有格子
        private List<SelectedCell> GetCellsInIsometricRange(Point startPoint, Point endPoint)
        {
            if (string.IsNullOrEmpty(_document.MapId) || !Share.MapDataList.ContainsKey(_document.MapId))
                return new List<SelectedCell>();

            // 找出起點和終點對應的遊戲座標
            var (startGameX, startGameY, _, _, _) = ScreenToGameCoords(startPoint.X, startPoint.Y);
            var (endGameX, endGameY, _, _, _) = ScreenToGameCoords(endPoint.X, endPoint.Y);

            // 如果起點找不到，返回空
            if (startGameX < 0)
                return new List<SelectedCell>();

            // 如果終點找不到，使用起點
            if (endGameX < 0)
            {
                endGameX = startGameX;
                endGameY = startGameY;
            }

            // 計算遊戲座標範圍
            int minGameX = Math.Min(startGameX, endGameX);
            int maxGameX = Math.Max(startGameX, endGameX);
            int minGameY = Math.Min(startGameY, endGameY);
            int maxGameY = Math.Max(startGameY, endGameY);

            // 限制選取範圍最大 150x150
            const int MaxSelectionSize = 150;
            if (maxGameX - minGameX >= MaxSelectionSize)
            {
                if (endGameX > startGameX)
                    maxGameX = minGameX + MaxSelectionSize - 1;
                else
                    minGameX = maxGameX - MaxSelectionSize + 1;
            }
            if (maxGameY - minGameY >= MaxSelectionSize)
            {
                if (endGameY > startGameY)
                    maxGameY = minGameY + MaxSelectionSize - 1;
                else
                    minGameY = maxGameY - MaxSelectionSize + 1;
            }

            // 計算螢幕範圍對應的世界座標矩形，用於空間索引查詢
            int minScreenX = Math.Min(startPoint.X, endPoint.X);
            int minScreenY = Math.Min(startPoint.Y, endPoint.Y);
            int maxScreenX = Math.Max(startPoint.X, endPoint.X);
            int maxScreenY = Math.Max(startPoint.Y, endPoint.Y);

            int worldLeft = (int)(minScreenX / _viewState.ZoomLevel) + _viewState.ScrollX;
            int worldTop = (int)(minScreenY / _viewState.ZoomLevel) + _viewState.ScrollY;
            int worldRight = (int)(maxScreenX / _viewState.ZoomLevel) + _viewState.ScrollX;
            int worldBottom = (int)(maxScreenY / _viewState.ZoomLevel) + _viewState.ScrollY;

            // 擴大查詢範圍以確保不漏掉邊界的 S32（含擴展區域）
            Rectangle queryRect = new Rectangle(worldLeft - 6144, worldTop - 3072,
                                                 worldRight - worldLeft + 12288,
                                                 worldBottom - worldTop + 6144);
            var candidateFiles = GetS32FilesInRect(queryRect);

            _logger.Debug($"[GetCellsInIsometricRange] gameRange=({minGameX},{minGameY})-({maxGameX},{maxGameY}), queryRect=({queryRect.X},{queryRect.Y},{queryRect.Width},{queryRect.Height}), candidateFiles.Count={candidateFiles.Count}");
            foreach (var f in candidateFiles)
            {
                _logger.Debug($"[GetCellsInIsometricRange] candidateFile: {Path.GetFileName(f)}");
            }

            // 收集候選 S32 資料
            var candidateS32s = new List<S32Data>();
            foreach (var filePath in candidateFiles)
            {
                if (_document.S32Files.TryGetValue(filePath, out var s32Data))
                {
                    candidateS32s.Add(s32Data);
                    _logger.Debug($"[GetCellsInIsometricRange] candidateS32: {Path.GetFileName(s32Data.FilePath)}, nLinBeginX={s32Data.SegInfo.nLinBeginX}, nLinBeginY={s32Data.SegInfo.nLinBeginY}");
                }
            }

            // 使用 CoordinateHelper 的優化版本收集格子（支援擴展區域）
            var result = CoordinateHelper.GetCellsInGameCoordRange(
                minGameX, maxGameX, minGameY, maxGameY,
                candidateS32s, currentS32Data);

            _logger.Debug($"[GetCellsInIsometricRange] result.Count={result.Count}");

            // 統計每個 S32 有多少格子被選中
            var s32CellCounts = new Dictionary<string, int>();
            foreach (var cell in result)
            {
                var fname = Path.GetFileName(cell.S32Data.FilePath);
                if (!s32CellCounts.ContainsKey(fname))
                    s32CellCounts[fname] = 0;
                s32CellCounts[fname]++;
            }
            foreach (var kvp in s32CellCounts)
            {
                _logger.Debug($"[GetCellsInIsometricRange] S32 {kvp.Key} has {kvp.Value} cells selected");
            }

            return result;
        }

        // 重新載入當前地圖
        private void ReloadCurrentMap()
        {
            if (string.IsNullOrEmpty(_document.MapId))
            {
                this.toolStripStatusLabel1.Text = "沒有選擇地圖";
                return;
            }

            // 記住當前滾動位置
            int scrollX = _viewState.ScrollX;
            int scrollY = _viewState.ScrollY;

            // 重新整理 Share.MapDataList 中的地圖資料（更新檔案清單）
            L1MapHelper.RefreshMap(_document.MapId);

            // 清除 Tile 相關快取
            TileHashManager.ClearCache();
            _renderCache.TilFileCache.Clear();
            _renderCache.TilRemasterCache.Clear();
            _renderCache.TileDataCache.Clear();
            cachedAggregatedTiles.Clear();
            TileProvider.Instance.ClearCache();  // 清除 TileProvider 快取

            // 清除編輯狀態
            _editState.HighlightedS32Data = null;
            _editState.HighlightedCellX = -1;
            _editState.HighlightedCellY = -1;

            // 重新載入 S32 檔案
            this.toolStripStatusLabel1.Text = "正在重新載入...";
            LoadS32FileList(_document.MapId);

            // 恢復滾動位置
            _viewState.SetScrollSilent(scrollX, scrollY);
            hScrollBar1.Value = Math.Clamp(scrollX, hScrollBar1.Minimum, hScrollBar1.Maximum);
            vScrollBar1.Value = Math.Clamp(scrollY, vScrollBar1.Minimum, vScrollBar1.Maximum);

            CheckAndRerenderIfNeeded();
            UpdateMiniMap();
        }

        private void MapForm_Load(object sender, EventArgs e)
        {
            LogPerf("[FORM-LOAD] Start");

            // 初始化浮動圖層面板狀態（必須在載入地圖前執行）
            SyncFloatPanelCheckboxes();
            s32EditorPanel_Resize(null, null);
            layerFloatPanel.BringToFront();
            LogPerf("[FORM-LOAD] Panel setup done");

            // 載入最近使用的素材
            RefreshMaterialsList();
            LogPerf("[FORM-LOAD] Materials list loaded");

            string iniPath = Path.GetTempPath() + "mapviewer.ini";

            // 檢查是否有保存的天堂路徑，如果有就自動載入
            if (File.Exists(iniPath))
            {
                string savedPath = Utils.GetINI("Path", "LineagePath", "", iniPath);
                LogPerf($"[FORM-LOAD] INI savedPath={savedPath}");
                if (!string.IsNullOrEmpty(savedPath) && Directory.Exists(savedPath))
                {
                    // 如果還沒載入地圖資料，自動載入
                    if (Share.MapDataList == null || Share.MapDataList.Count == 0)
                    {
                        LogPerf("[FORM-LOAD] Calling LoadMap...");
                        this.toolStripStatusLabel3.Text = savedPath;
                        Share.LineagePath = savedPath;
                        this.LoadMap(savedPath);
                        LogPerf("[FORM-LOAD] LoadMap returned (async continues in background)");
                        return; // LoadMap 會觸發 comboBox1_SelectedIndexChanged，會自動載入上次選擇的地圖
                    }
                }
            }

            // 如果已經有地圖資料，填充 comboBox
            if (Share.MapDataList != null && Share.MapDataList.Count > 0)
            {
                LogPerf("[FORM-LOAD] Filling comboBox...");
                // 儲存所有地圖項目供過濾使用
                allMapItems.Clear();
                foreach (string key in Utils.SortAsc(Share.MapDataList.Keys))
                {
                    Struct.L1Map l1Map = Share.MapDataList[key];
                    allMapItems.Add(string.Format("{0}-{1}", key, l1Map.szName));
                }

                isFiltering = true;
                this.comboBox1.Items.Clear();
                this.comboBox1.BeginUpdate();
                foreach (var item in allMapItems)
                {
                    this.comboBox1.Items.Add(item);
                }
                this.comboBox1.EndUpdate();
                isFiltering = false;

                // 讀取上次選擇的地圖名稱
                if (this.comboBox1.Items.Count > 0)
                {
                    string lastMapName = "";

                    if (File.Exists(iniPath))
                    {
                        lastMapName = Utils.GetINI("MapForm", "LastSelectedMapName", "", iniPath);
                    }

                    // 如果有上次選擇的地圖，找到它
                    int selectedIndex = 0;
                    if (!string.IsNullOrEmpty(lastMapName))
                    {
                        for (int i = 0; i < this.comboBox1.Items.Count; i++)
                        {
                            if (this.comboBox1.Items[i].ToString() == lastMapName)
                            {
                                selectedIndex = i;
                                break;
                            }
                        }
                    }

                    LogPerf($"[FORM-LOAD] Setting comboBox1.SelectedIndex={selectedIndex}");
                    this.comboBox1.SelectedIndex = selectedIndex;
                }
            }
            LogPerf("[FORM-LOAD] End");
        }

        private void openToolStripMenuItem_Click(object sender, EventArgs e)
        {
            using (FolderBrowserDialog folderDialog = new FolderBrowserDialog())
            {
                folderDialog.Description = "請選擇天堂資料夾";
                folderDialog.ShowNewFolderButton = false;

                string iniPath = Path.GetTempPath() + "mapviewer.ini";
                if (File.Exists(iniPath))
                {
                    string savedPath = Utils.GetINI("Path", "LineagePath", "", iniPath);
                    if (!string.IsNullOrEmpty(savedPath) && Directory.Exists(savedPath))
                        folderDialog.SelectedPath = savedPath;
                }
                else
                {
                    folderDialog.SelectedPath = Environment.GetFolderPath(Environment.SpecialFolder.ProgramFiles);
                }

                if (folderDialog.ShowDialog(this) != DialogResult.Ok || string.IsNullOrEmpty(folderDialog.SelectedPath))
                    return;

                this.toolStripStatusLabel3.Text = folderDialog.SelectedPath;
                Share.LineagePath = folderDialog.SelectedPath;
                Utils.WriteINI("Path", "LineagePath", folderDialog.SelectedPath, iniPath);
                this.LoadMap(folderDialog.SelectedPath);
            }
        }

        // 匯出地圖通行資料給伺服器使用（L1J 格式）
        private void exportL1JToolStripMenuItem_Click(object sender, EventArgs e)
        {
            ExportPassabilityData(isL1JFormat: true);
        }

        // 匯出地圖通行資料給伺服器使用（DIR 格式）
        private void exportDIRToolStripMenuItem_Click(object sender, EventArgs e)
        {
            ExportPassabilityData(isL1JFormat: false);
        }

        // 通用匯出通行資料函數
        private void ExportPassabilityData(bool isL1JFormat)
        {
            if (string.IsNullOrEmpty(_document.MapId) || !Share.MapDataList.ContainsKey(_document.MapId))
            {
                WinFormsMessageBox.Show("請先載入地圖！", "提示", MessageBoxButtons.OK, MessageBoxIcon.Warning);
                return;
            }

            if (_document.S32Files.Count == 0)
            {
                WinFormsMessageBox.Show("請先在 S32 編輯器中載入地圖資料！", "提示", MessageBoxButtons.OK, MessageBoxIcon.Warning);
                return;
            }

            string formatName = isL1JFormat ? "L1J" : "DIR";
            using (SaveFileDialog saveDialog = new SaveFileDialog())
            {
                saveDialog.Filter = "文字檔 (*.txt)|*.txt";
                saveDialog.FileName = $"{_document.MapId}.txt";
                saveDialog.Title = $"匯出地圖通行資料 ({formatName} 格式)";

                if (saveDialog.ShowDialog(this) == DialogResult.Ok)
                {
                    try
                    {
                        ExportMapData(saveDialog.FileName, isL1JFormat);
                        WinFormsMessageBox.Show($"已成功匯出至：\n{saveDialog.FileName}\n格式: {formatName}", "匯出完成", MessageBoxButtons.OK, MessageBoxIcon.Information);
                    }
                    catch (Exception ex)
                    {
                        WinFormsMessageBox.Show($"匯出失敗：{ex.Message}", "錯誤", MessageBoxButtons.OK, MessageBoxIcon.Error);
                    }
                }
            }
        }

        // 匯出地圖資料（參考 MapTool 的格式）
        // MapTool 的 readS32 讀取方式：
        // - 從 offset 32768 + tileCount*6 + 2 開始
        // - 每個格子讀 4 bytes: [Attribute1, ?, Attribute2, ?]
        // - 迴圈是 64x64，tileList_t1 存 Attribute1，tileList_t3 存 Attribute2
        // - xLength = S32數量 * 64（不是 128！）
        // isL1JFormat: true = L1J 格式（經過轉換），false = DIR 格式（原始 8 方向）
        private void ExportMapData(string filePath, bool isL1JFormat = true)
        {
            // 根據實際載入的 S32 檔案計算維度（與 CLI 和 MapTool 相同方式）
            // nLinBeginX/Y 已經是 Layer3 座標（每區塊 64 格），不需要轉換
            int minX = int.MaxValue, maxX = int.MinValue;
            int minY = int.MaxValue, maxY = int.MinValue;

            foreach (var s32Data in _document.S32Files.Values)
            {
                int blockStartX = s32Data.SegInfo.nLinBeginX;  // 已是 Layer3 座標
                int blockStartY = s32Data.SegInfo.nLinBeginY;

                minX = Math.Min(minX, blockStartX);
                maxX = Math.Max(maxX, blockStartX + 63);  // 區塊結束 = 起始 + 63
                minY = Math.Min(minY, blockStartY);
                maxY = Math.Max(maxY, blockStartY + 63);
            }

            int xLength = maxX - minX + 1;
            int yLength = maxY - minY + 1;
            int xBegin = minX;
            int yBegin = minY;

            // 建立 tileList_t1 和 tileList_t3 陣列（對應 MapTool 的格式）
            // t1 = Attribute1 (上下方向判斷), t3 = Attribute2 (左右方向判斷)
            int[,] tileList_t1 = new int[xLength, yLength];
            int[,] tileList_t3 = new int[xLength, yLength];

            // 初始化為不可通行（1 = 預設值，與 MapTool 相同）
            for (int x = 0; x < xLength; x++)
            {
                for (int y = 0; y < yLength; y++)
                {
                    tileList_t1[x, y] = 1;
                    tileList_t3[x, y] = 1;
                }
            }

            // 從 S32 資料填充 tileList
            foreach (var s32Data in _document.S32Files.Values)
            {
                // 計算這個 S32 在地圖陣列中的偏移
                int offsetX = s32Data.SegInfo.nLinBeginX - xBegin;
                int offsetY = s32Data.SegInfo.nLinBeginY - yBegin;

                // Layer3 是 64x64
                for (int ly = 0; ly < 64; ly++)
                {
                    for (int lx = 0; lx < 64; lx++)
                    {
                        var attr = s32Data.Layer3[ly, lx];
                        if (attr == null) continue;

                        int gx = offsetX + lx;
                        int gy = offsetY + ly;

                        if (gx >= 0 && gx < xLength && gy >= 0 && gy < yLength)
                        {
                            // Attribute1 用於上下方向 (t1), Attribute2 用於左右方向 (t3)
                            // 需要經過 replaceException 處理（與 MapTool 相同）
                            int attr1Value = PassabilityService.ReplaceException(attr.Attribute1);
                            int attr2Value = PassabilityService.ReplaceException(attr.Attribute2);
                            tileList_t1[gx, gy] = attr1Value;
                            tileList_t3[gx, gy] = attr2Value;
                        }
                    }
                }
            }

            // 計算 8 方向通行性（參考 MapTool 的 decryptData）
            int[,] tileList = new int[xLength, yLength];

            for (int x = 0; x < xLength; x++)
            {
                for (int y = 0; y < yLength; y++)
                {
                    if (x + 1 < xLength && y + 1 < yLength && x - 1 >= 0 && y - 1 >= 0)
                    {
                        // D0: 下方 - isPassable_D0(x, y) => (tileList_t1[x, y + 1] & 1) == 0
                        if ((tileList_t1[x, y + 1] & 1) == 0)
                            tileList[x, y] += 1;
                        // D4: 上方 - isPassable_D4(x, y) => (tileList_t1[x, y] & 1) == 0
                        if ((tileList_t1[x, y] & 1) == 0)
                            tileList[x, y] += 2;
                        // D2: 左方 - isPassable_D2(x, y) => (tileList_t3[x - 1, y] & 1) == 0
                        if ((tileList_t3[x - 1, y] & 1) == 0)
                            tileList[x, y] += 4;
                        // D6: 右方 - isPassable_D6(x, y) => (tileList_t3[x, y] & 1) == 0
                        if ((tileList_t3[x, y] & 1) == 0)
                            tileList[x, y] += 8;

                        // D1: 左下對角 - isPassable_D1(x - 1, y + 1)
                        if (PassabilityService.IsPassable_D1(tileList_t1, tileList_t3, x - 1, y + 1, xLength, yLength))
                            tileList[x, y] += 16;
                        // D3: 左上對角 - isPassable_D3(x - 1, y - 1)
                        if (PassabilityService.IsPassable_D3(tileList_t1, tileList_t3, x - 1, y - 1, xLength, yLength))
                            tileList[x, y] += 32;
                        // D5: 右上對角 - isPassable_D5(x + 1, y - 1)
                        if (PassabilityService.IsPassable_D5(tileList_t1, tileList_t3, x + 1, y - 1, xLength, yLength))
                            tileList[x, y] += 64;
                        // D7: 右下對角 - isPassable_D7(x + 1, y + 1)
                        if (PassabilityService.IsPassable_D7(tileList_t1, tileList_t3, x + 1, y + 1, xLength, yLength))
                            tileList[x, y] += 128;

                        // 區域類型 - getZone(x, y) 使用 tileList_t1[x, y]
                        tileList[x, y] += PassabilityService.GetZone(tileList_t1[x, y]);
                    }
                }
            }

            // 根據格式選擇輸出資料
            int[,] outputData;
            if (isL1JFormat)
            {
                // L1J 格式：經過轉換的簡化格式
                outputData = FormatL1J(tileList, xLength, yLength);
            }
            else
            {
                // DIR 格式：直接輸出原始 8 方向 + 區域類型
                outputData = tileList;
            }

            // 寫入檔案（與 MapTool 相同格式，不含座標範圍，不含 BOM）
            using (StreamWriter writer = new StreamWriter(filePath, false, new System.Text.UTF8Encoding(false)))
            {
                // 寫入資料（y 為行，x 為列）
                for (int y = 0; y < yLength; y++)
                {
                    StringBuilder line = new StringBuilder();
                    for (int x = 0; x < xLength; x++)
                    {
                        if (x > 0) line.Append(",");
                        line.Append(outputData[x, y]);
                    }
                    writer.WriteLine(line.ToString());
                }
            }

            this.toolStripStatusLabel1.Text = $"已匯出 {_document.MapId}.txt ({xLength}x{yLength})";
        }

        // 對角方向通行性判斷 - 已移至 Helper/PassabilityService.cs

        // 轉換為 L1J 格式（完全按照 MapTool 的 formate_L1J 邏輯）
        private int[,] FormatL1J(int[,] tileList, int xLength, int yLength)
        {
            int[,] result = new int[xLength, yLength];

            for (int y = 0; y < yLength; y++)
            {
                for (int x = 0; x < xLength; x++)
                {
                    int tile = tileList[x, y];

                    // (tile & 1) == 1 || (tile & 2) == 2 => +2
                    if ((tile & 1) == 1 || (tile & 2) == 2)
                        result[x, y] += 2;

                    // (tile & 4) == 4 || (tile & 8) == 8 => +1
                    if ((tile & 4) == 4 || (tile & 8) == 8)
                        result[x, y] += 1;

                    // (tile & 1) == 1 && (tile & 2) == 2 => +8
                    if ((tile & 1) == 1 && (tile & 2) == 2)
                        result[x, y] += 8;

                    // (tile & 4) == 4 && (tile & 8) == 8 => +4
                    if ((tile & 4) == 4 && (tile & 8) == 8)
                        result[x, y] += 4;

                    // (tile & 256) == 256 => 什麼都不做（一般區域）
                    // (tile & 512) == 512 => +16（安全區域）
                    if ((tile & 512) == 512)
                        result[x, y] += 16;

                    // (tile & 1024) == 1024 => +32（戰鬥區域）
                    if ((tile & 1024) == 1024)
                        result[x, y] += 32;
                }
            }

            return result;
        }

        // 匯出所有地圖通行資料（L1J 格式）
        private void exportAllL1JToolStripMenuItem_Click(object sender, EventArgs e)
        {
            ExportAllMapsPassability(isL1JFormat: true);
        }

        // 匯出所有地圖通行資料（DIR 格式）
        private void exportAllDIRToolStripMenuItem_Click(object sender, EventArgs e)
        {
            ExportAllMapsPassability(isL1JFormat: false);
        }

        // 匯出所有地圖通行資料
        private void ExportAllMapsPassability(bool isL1JFormat)
        {
            // 檢查是否已載入客戶端
            if (Share.MapDataList == null || Share.MapDataList.Count == 0)
            {
                WinFormsMessageBox.Show("請先開啟天堂客戶端！", "提示", MessageBoxButtons.OK, MessageBoxIcon.Warning);
                return;
            }

            string formatName = isL1JFormat ? "L1J" : "DIR";

            // 選擇輸出資料夾
            using (var folderDialog = new FolderBrowserDialog())
            {
                folderDialog.Description = $"選擇輸出資料夾 ({formatName} 格式)";
                folderDialog.ShowNewFolderButton = true;

                if (folderDialog.ShowDialog(this) != DialogResult.Ok)
                    return;

                string outputFolder = folderDialog.SelectedPath;

                // 取得所有地圖 ID 並排序
                var mapIds = Share.MapDataList.Keys
                    .Where(id => int.TryParse(id, out _))
                    .OrderBy(id => int.Parse(id))
                    .ToList();

                if (mapIds.Count == 0)
                {
                    WinFormsMessageBox.Show("沒有找到任何地圖！", "提示", MessageBoxButtons.OK, MessageBoxIcon.Warning);
                    return;
                }

                // 確認匯出
                var result = WinFormsMessageBox.Show(
                    $"將匯出 {mapIds.Count} 張地圖的通行資料\n格式: {formatName}\n輸出至: {outputFolder}\n\n是否繼續？",
                    "確認匯出",
                    MessageBoxButtons.YesNo,
                    MessageBoxIcon.Question);

                if (result != DialogResult.Yes)
                    return;

                // 開始匯出
                Utils.ShowProgressBar(true, this);
                int successCount = 0;
                int failCount = 0;
                var failedMaps = new List<string>();

                for (int i = 0; i < mapIds.Count; i++)
                {
                    string mapId = mapIds[i];
                    this.toolStripStatusLabel1.Text = $"正在匯出 {mapId} ({i + 1}/{mapIds.Count})...";
                    toolStripProgressBar1.Value = (int)((i + 1) * 100.0 / mapIds.Count);
                    ApplicationHelper.DoEvents();

                    try
                    {
                        // 載入地圖的 S32 檔案
                        var mapData = Share.MapDataList[mapId];
                        var s32Files = new Dictionary<string, S32Data>();

                        Console.WriteLine($"[ExportAllMaps] 處理地圖 {mapId}, 檔案數: {mapData.FullFileNameList.Count}");

                        // 收集已處理的區塊座標（用於 S32 優先）
                        var processedBlocks = new HashSet<(int, int)>();

                        // 優先處理 S32 檔案
                        foreach (var entry in mapData.FullFileNameList)
                        {
                            string filePath = entry.Key;
                            if (!File.Exists(filePath)) continue;
                            if (!entry.Value.isS32) continue;

                            try
                            {
                                var s32Data = S32Parser.ParseFile(filePath);
                                if (s32Data != null)
                                {
                                    // 從 L1MapSeg 設定 SegInfo
                                    var segInfo = entry.Value;
                                    s32Data.SegInfo = new Struct.L1MapSeg(segInfo.nBlockX, segInfo.nBlockY, true);
                                    s32Files[filePath] = s32Data;
                                    processedBlocks.Add((entry.Value.nBlockX, entry.Value.nBlockY));
                                }
                            }
                            catch
                            {
                                // 解析失敗，跳過此檔案
                            }
                        }

                        // 處理 SEG 檔案（只處理沒有對應 S32 的區塊）
                        foreach (var entry in mapData.FullFileNameList)
                        {
                            string filePath = entry.Key;
                            if (!File.Exists(filePath)) continue;
                            if (entry.Value.isS32) continue;  // 跳過 S32（已處理）

                            // 檢查是否已有同位置的 S32
                            if (processedBlocks.Contains((entry.Value.nBlockX, entry.Value.nBlockY)))
                                continue;

                            try
                            {
                                var s32Data = S32Parser.ParseFile(filePath);
                                if (s32Data != null)
                                {
                                    // 從 L1MapSeg 設定 SegInfo
                                    var segInfo = entry.Value;
                                    s32Data.SegInfo = new Struct.L1MapSeg(segInfo.nBlockX, segInfo.nBlockY, false);
                                    s32Files[filePath] = s32Data;
                                }
                            }
                            catch
                            {
                                // 解析失敗，跳過此檔案
                            }
                        }

                        if (s32Files.Count == 0)
                        {
                            failedMaps.Add($"{mapId} (無地圖檔案)");
                            failCount++;
                            continue;
                        }

                        // 匯出通行資料
                        string outputPath = Path.Combine(outputFolder, $"{mapId}.txt");
                        ExportMapDataFromS32Files(outputPath, s32Files, isL1JFormat);
                        successCount++;
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine($"[ExportAllMaps] 地圖 {mapId} 匯出失敗: {ex.Message}");
                        Console.WriteLine($"[ExportAllMaps] StackTrace: {ex.StackTrace}");
                        failedMaps.Add($"{mapId} ({ex.Message})");
                        failCount++;
                    }
                }

                Utils.ShowProgressBar(false, this);
                this.toolStripStatusLabel1.Text = $"匯出完成：成功 {successCount}，失敗 {failCount}";

                string message = $"匯出完成！\n\n成功: {successCount} 張地圖\n失敗: {failCount} 張地圖";
                if (failedMaps.Count > 0 && failedMaps.Count <= 10)
                {
                    message += "\n\n失敗的地圖:\n" + string.Join("\n", failedMaps);
                }
                else if (failedMaps.Count > 10)
                {
                    message += $"\n\n失敗的地圖 (前10個):\n" + string.Join("\n", failedMaps.Take(10)) + $"\n...還有 {failedMaps.Count - 10} 個";
                }

                WinFormsMessageBox.Show(message, "匯出結果", MessageBoxButtons.OK,
                    failCount > 0 ? MessageBoxIcon.Warning : MessageBoxIcon.Information);
            }
        }

        // 從 S32 檔案集合匯出通行資料（不依賴 _document）
        private void ExportMapDataFromS32Files(string filePath, Dictionary<string, S32Data> s32Files, bool isL1JFormat)
        {
            // 計算維度
            int minX = int.MaxValue, maxX = int.MinValue;
            int minY = int.MaxValue, maxY = int.MinValue;

            foreach (var s32Data in s32Files.Values)
            {
                if (s32Data?.SegInfo == null) continue;

                int blockStartX = s32Data.SegInfo.nLinBeginX;
                int blockStartY = s32Data.SegInfo.nLinBeginY;

                minX = Math.Min(minX, blockStartX);
                maxX = Math.Max(maxX, blockStartX + 63);
                minY = Math.Min(minY, blockStartY);
                maxY = Math.Max(maxY, blockStartY + 63);
            }

            // 檢查是否有有效資料
            if (minX == int.MaxValue || maxX == int.MinValue)
            {
                throw new Exception("無有效的 S32 資料");
            }

            int xLength = maxX - minX + 1;
            int yLength = maxY - minY + 1;
            int xBegin = minX;
            int yBegin = minY;

            // 建立 tileList 陣列
            int[,] tileList_t1 = new int[xLength, yLength];
            int[,] tileList_t3 = new int[xLength, yLength];

            // 初始化為不可通行
            for (int x = 0; x < xLength; x++)
            {
                for (int y = 0; y < yLength; y++)
                {
                    tileList_t1[x, y] = 1;
                    tileList_t3[x, y] = 1;
                }
            }

            // 從 S32 資料填充 tileList
            foreach (var s32Data in s32Files.Values)
            {
                if (s32Data?.SegInfo == null || s32Data.Layer3 == null) continue;

                int offsetX = s32Data.SegInfo.nLinBeginX - xBegin;
                int offsetY = s32Data.SegInfo.nLinBeginY - yBegin;

                for (int ly = 0; ly < 64; ly++)
                {
                    for (int lx = 0; lx < 64; lx++)
                    {
                        var attr = s32Data.Layer3[ly, lx];
                        if (attr == null) continue;

                        int gx = offsetX + lx;
                        int gy = offsetY + ly;

                        if (gx >= 0 && gx < xLength && gy >= 0 && gy < yLength)
                        {
                            int attr1Value = PassabilityService.ReplaceException(attr.Attribute1);
                            int attr2Value = PassabilityService.ReplaceException(attr.Attribute2);
                            tileList_t1[gx, gy] = attr1Value;
                            tileList_t3[gx, gy] = attr2Value;
                        }
                    }
                }
            }

            // 計算 8 方向通行性
            int[,] tileList = new int[xLength, yLength];

            for (int x = 0; x < xLength; x++)
            {
                for (int y = 0; y < yLength; y++)
                {
                    if (x + 1 < xLength && y + 1 < yLength && x - 1 >= 0 && y - 1 >= 0)
                    {
                        if ((tileList_t1[x, y + 1] & 1) == 0)
                            tileList[x, y] += 1;
                        if ((tileList_t1[x, y] & 1) == 0)
                            tileList[x, y] += 2;
                        if ((tileList_t3[x - 1, y] & 1) == 0)
                            tileList[x, y] += 4;
                        if ((tileList_t3[x, y] & 1) == 0)
                            tileList[x, y] += 8;

                        if (PassabilityService.IsPassable_D1(tileList_t1, tileList_t3, x - 1, y + 1, xLength, yLength))
                            tileList[x, y] += 16;
                        if (PassabilityService.IsPassable_D3(tileList_t1, tileList_t3, x - 1, y - 1, xLength, yLength))
                            tileList[x, y] += 32;
                        if (PassabilityService.IsPassable_D5(tileList_t1, tileList_t3, x + 1, y - 1, xLength, yLength))
                            tileList[x, y] += 64;
                        if (PassabilityService.IsPassable_D7(tileList_t1, tileList_t3, x + 1, y + 1, xLength, yLength))
                            tileList[x, y] += 128;

                        tileList[x, y] += PassabilityService.GetZone(tileList_t1[x, y]);
                    }
                }
            }

            // 根據格式選擇輸出資料
            int[,] outputData = isL1JFormat ? FormatL1J(tileList, xLength, yLength) : tileList;

            // 寫入檔案
            using (StreamWriter writer = new StreamWriter(filePath, false, new System.Text.UTF8Encoding(false)))
            {
                for (int y = 0; y < yLength; y++)
                {
                    StringBuilder line = new StringBuilder();
                    for (int x = 0; x < xLength; x++)
                    {
                        if (x > 0) line.Append(",");
                        line.Append(outputData[x, y]);
                    }
                    writer.WriteLine(line.ToString());
                }
            }
        }

        public void LoadMap(string selectedPath)
        {
            LogPerf("[LOADMAP] Start");

            // 先在 UI 執行緒檢查路徑是否有效（避免 MessageBox 在背景執行緒彈出）
            string szMapPath = string.Format(@"{0}\map\", selectedPath);
            if (!Directory.Exists(szMapPath))
            {
                WinFormsMessageBox.Show("錯誤的天堂路徑");
                return;
            }

            // 切換資料夾時清除所有快取（不同資料夾的 tile/idx 內容不同）
            _renderCache.TilFileCache.Clear();
            _renderCache.TilRemasterCache.Clear();
            _renderCache.TileDataCache.Clear();
            cachedAggregatedTiles.Clear();
            Share.IdxDataList.Clear();  // 清除 idx 快取，強制重新讀取新資料夾的 idx
            Share.MapDataList.Clear();  // 清除地圖快取，強制重新讀取新資料夾的地圖
            TileHashManager.ClearCache();  // 清除 Tile MD5 快取
            _listTilMaxId = null;       // 清除 list.til 快取
            TileProvider.Instance.ClearAllOverrides();  // 清除測 til override
            TileProvider.Instance.ClearCache();         // 清除 TileProvider 快取

            // 清除當前地圖狀態
            _document.S32Files.Clear();
            _document.MapId = null;
            lstS32Files.Items.Clear();
            _checkedS32Files.Clear();
            lvTiles.Items.Clear();
            lvGroupThumbnails.Items.Clear();
            ClearS32BlockCache();
            ClearMiniMapCache();

            // 清除 viewport
            lock (_renderCache.ViewportBitmapLock)
            {
                if (_renderCache.ViewportBitmap != null)
                {
                    _renderCache.ViewportBitmap.Dispose();
                    _renderCache.ViewportBitmap = null;
                }
            }
            pictureBox1.Invalidate();

            LogPerf("[LOADMAP] Cache cleared");

            Utils.ShowProgressBar(true, this);
            this.toolStripStatusLabel1.Text = "正在讀取地圖列表...";

            // 在背景執行緒載入地圖資料
            Task.Run(() =>
            {
                try
                {
                    DebugLog.Log("[LOADMAP-BG] Task started");
                    LogPerf("[LOADMAP-BG] Task started, calling L1MapHelper.Read...");
                    var stopwatch = Stopwatch.StartNew();
                    var dictionary = L1MapHelper.Read(selectedPath);
                    stopwatch.Stop();
                    long readMs = stopwatch.ElapsedMilliseconds;
                    DebugLog.Log($"[LOADMAP-BG] L1MapHelper.Read done: {readMs}ms, maps={dictionary.Count}");
                    LogPerf($"[LOADMAP-BG] L1MapHelper.Read done: {readMs}ms, maps={dictionary.Count}");

                    // 回到 UI 執行緒更新介面
                    DebugLog.Log("[LOADMAP-BG] Invoking UI update...");
                    LogPerf("[LOADMAP-BG] Invoking UI update...");
                    this.BeginInvoke((MethodInvoker)delegate
                    {
                    LogPerf("[LOADMAP-UI] BeginInvoke callback started");
                    stopwatch.Restart();

                    // 儲存所有地圖項目供過濾使用
                    allMapItems.Clear();
                    foreach (string key in Utils.SortAsc(dictionary.Keys))
                    {
                        Struct.L1Map l1Map = dictionary[key];
                        allMapItems.Add(string.Format("{0}-{1}", key, l1Map.szName));
                    }

                    // 填充 ComboBox（保留給相容性）
                    isFiltering = true;
                    this.comboBox1.Items.Clear();
                    this.comboBox1.BeginUpdate();
                    foreach (var item in allMapItems)
                    {
                        this.comboBox1.Items.Add(item);
                    }
                    this.comboBox1.EndUpdate();
                    isFiltering = false;

                    // 填充 lstMaps ListBox
                    this.lstMaps.BeginUpdate();
                    this.lstMaps.Items.Clear();
                    foreach (var item in allMapItems)
                    {
                        this.lstMaps.Items.Add(item);
                    }
                    this.lstMaps.EndUpdate();

                    long uiMs = stopwatch.ElapsedMilliseconds;
                    LogPerf($"[LOADMAP-UI] Lists filled: {uiMs}ms");

                    // 讀取上次選擇的地圖名稱（改用名稱而非索引，避免過濾後索引錯亂）
                    if (this.comboBox1.Items.Count > 0)
                    {
                        string iniPath = Path.GetTempPath() + "mapviewer.ini";
                        string lastMapName = "";

                        if (File.Exists(iniPath))
                        {
                            lastMapName = Utils.GetINI("MapForm", "LastSelectedMapName", "", iniPath);
                        }

                        // 如果有上次選擇的地圖，找到它
                        int selectedIndex = 0;
                        if (!string.IsNullOrEmpty(lastMapName))
                        {
                            for (int i = 0; i < this.comboBox1.Items.Count; i++)
                            {
                                if (this.comboBox1.Items[i].ToString() == lastMapName)
                                {
                                    selectedIndex = i;
                                    break;
                                }
                            }
                        }

                        // 先設為 -1 再設回來，強制觸發 SelectedIndexChanged 事件
                        // 這樣即使選擇相同的 index，也會重新載入 S32 檔案
                        LogPerf($"[LOADMAP-UI] Setting comboBox1.SelectedIndex={selectedIndex} (will trigger LoadS32FileList)");
                        this.comboBox1.SelectedIndex = -1;
                        this.comboBox1.SelectedIndex = selectedIndex;
                        LogPerf("[LOADMAP-UI] comboBox1.SelectedIndex set done");

                        // 同步選擇 lstMaps
                        isFiltering = true;  // 防止 lstMaps 再次觸發載入
                        this.lstMaps.SelectedIndex = selectedIndex;
                        isFiltering = false;
                    }

                    this.toolStripStatusLabel2.Text = $"Maps={dictionary.Count}, Files={L1MapHelper.LastTotalFileCount}";
                    this.toolStripStatusLabel1.Text = $"載入完成 - Zone3desc:{L1MapHelper.LastLoadZone3descMs}ms, ZoneXml:{L1MapHelper.LastLoadZoneXmlMs}ms, 掃描目錄:{L1MapHelper.LastScanDirectoriesMs}ms, UI:{uiMs}ms (總計:{readMs + uiMs}ms)";
                    Utils.ShowProgressBar(false, this);
                    LogPerf("[LOADMAP-UI] Done");
                });
                }
                catch (Exception ex)
                {
                    DebugLog.Log($"[LOADMAP-BG] EXCEPTION: {ex.GetType().Name}: {ex.Message}");
                    DebugLog.Log($"[LOADMAP-BG] StackTrace: {ex.StackTrace}");
                    if (ex.InnerException != null)
                    {
                        DebugLog.Log($"[LOADMAP-BG] InnerException: {ex.InnerException.GetType().Name}: {ex.InnerException.Message}");
                    }
                    this.BeginInvoke((MethodInvoker)delegate
                    {
                        Utils.ShowProgressBar(false, this);
                        this.toolStripStatusLabel1.Text = $"載入錯誤: {ex.Message}";
                        WinFormsMessageBox.Show($"載入地圖時發生錯誤:\n{ex.Message}\n\n詳細資訊已寫入 debug log:\n{DebugLog.LogPath}",
                            "錯誤", MessageBoxButtons.OK, MessageBoxIcon.Error);
                    });
                }
            });
            LogPerf("[LOADMAP] Task.Run started (async)");
        }

        // 地圖搜尋過濾
        private void comboBox1_TextChanged(object sender, EventArgs e)
        {
            if (isFiltering) return;

            string searchText = this.comboBox1.Text.ToLower();

            // 如果文字為空或是選中了一個項目，不過濾
            if (string.IsNullOrEmpty(searchText) || this.comboBox1.SelectedItem != null &&
                this.comboBox1.SelectedItem.ToString().ToLower() == searchText)
            {
                return;
            }

            isFiltering = true;

            // 記住游標位置
            int cursorPos = this.comboBox1.SelectionStart;

            // 過濾項目
            var filteredItems = allMapItems
                .Where(item => item.ToLower().Contains(searchText))
                .ToList();

            this.comboBox1.BeginUpdate();
            this.comboBox1.Items.Clear();
            foreach (var item in filteredItems)
            {
                this.comboBox1.Items.Add(item);
            }
            this.comboBox1.EndUpdate();

            // 還原文字和游標位置
            this.comboBox1.Text = searchText;
            this.comboBox1.SelectionStart = cursorPos;
            this.comboBox1.SelectionLength = 0;

            // 顯示下拉選單
            if (filteredItems.Count > 0 && !this.comboBox1.DroppedDown)
            {
                this.comboBox1.DroppedDown = true;
            }

            isFiltering = false;

            this.toolStripStatusLabel1.Text = $"找到 {filteredItems.Count} 個地圖";
        }

        // 清空搜尋，顯示所有地圖
        private void ResetMapFilter()
        {
            isFiltering = true;
            this.comboBox1.BeginUpdate();
            this.comboBox1.Items.Clear();
            foreach (var item in allMapItems)
            {
                this.comboBox1.Items.Add(item);
            }
            this.comboBox1.EndUpdate();
            isFiltering = false;
        }

        // ===== 左下角 Tab: 地圖列表 =====

        // 地圖搜尋（左下角 Tab）
        private void txtMapSearch_TextChanged(object sender, EventArgs e)
        {
            if (isFiltering) return;

            string searchText = txtMapSearch.Text.ToLower().Trim();

            isFiltering = true;
            lstMaps.BeginUpdate();
            lstMaps.Items.Clear();

            if (string.IsNullOrEmpty(searchText))
            {
                // 顯示所有地圖
                foreach (var item in allMapItems)
                {
                    lstMaps.Items.Add(item);
                }
            }
            else
            {
                // 過濾地圖
                foreach (var item in allMapItems)
                {
                    if (item.ToLower().Contains(searchText))
                    {
                        lstMaps.Items.Add(item);
                    }
                }
            }

            lstMaps.EndUpdate();
            isFiltering = false;

            this.toolStripStatusLabel1.Text = $"找到 {lstMaps.Items.Count} 個地圖";
        }

        // 地圖列表選擇變更（左下角 Tab）
        private void lstMaps_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (isFiltering) return;
            if (lstMaps.SelectedItem == null) return;

            string selectedMapName = lstMaps.SelectedItem.ToString();

            // 取得地圖 ID
            string szSelectName = selectedMapName;
            if (szSelectName.Contains("-"))
                szSelectName = szSelectName.Split('-')[0].Trim();

            // 驗證地圖是否存在
            if (!Share.MapDataList.ContainsKey(szSelectName))
            {
                toolStripStatusLabel1.Text = $"地圖 {szSelectName} 不存在";
                return;
            }

            // 保存當前選擇的地圖名稱
            string iniPath = Path.GetTempPath() + "mapviewer.ini";
            Utils.WriteINI("MapForm", "LastSelectedMapName", selectedMapName, iniPath);

            // 重置縮放級別
            zoomLevel = 1.0;
            if (originalMapImage != null)
            {
                originalMapImage.Dispose();
                originalMapImage = null;
            }

            // 重置 S32 編輯器縮放級別
            LogPerf($"[ZOOM-RESET] listBox selection, old={_viewState.ZoomLevel}");
            _viewState.ZoomLevel = 1.0;
            if (originalS32Image != null)
            {
                originalS32Image.Dispose();
                originalS32Image = null;
            }

            // 同步 comboBox1（保持相容性）
            isFiltering = true;
            for (int i = 0; i < comboBox1.Items.Count; i++)
            {
                if (comboBox1.Items[i].ToString() == selectedMapName)
                {
                    comboBox1.SelectedIndex = i;
                    break;
                }
            }
            isFiltering = false;

            // 載入地圖
            try
            {
                var swMapSelect = Stopwatch.StartNew();

                // 跳過 doPaintEvent - S32 編輯器有自己的 viewport 渲染，不需要舊版地圖縮圖
                // 這可以節省 6+ 秒（原本會讀取所有 S32 檔案計算 SHA1）
                LogPerf($"[MAP-SELECT] Skipping doPaintEvent (S32 editor mode)");

                // 載入該地圖的 s32 檔案清單
                LoadS32FileList(szSelectName);
                LogPerf($"[MAP-SELECT] LoadS32FileList: {swMapSelect.ElapsedMilliseconds}ms");
            }
            catch (Exception ex)
            {
                toolStripStatusLabel1.Text = $"載入地圖失敗: {ex.Message}";
            }
        }

        // 地圖列表右鍵選單
        private void lstMaps_MouseUp(object sender, MouseEventArgs e)
        {
            if (e.Buttons != Eto.Forms.MouseButtons.Alternate)
                return;

            int index = lstMaps.IndexFromPoint(new Point((int)e.Location.X, (int)e.Location.Y));
            if (index < 0 || index >= lstMaps.Items.Count)
                return;

            // 選取該項目
            lstMaps.SelectedIndex = index;
            string selectedMapName = lstMaps.Items[index].ToString();

            // 取得地圖 ID
            string mapId = selectedMapName;
            if (mapId.Contains("-"))
                mapId = mapId.Split('-')[0].Trim();

            // 建立右鍵選單
            var menu = new ContextMenuStrip();

            // 匯出為地圖包選項
            var exportItem = new ToolStripMenuItem("匯出為地圖包 (fs32)...");
            exportItem.Click += (s, args) => ExportMapAsFs32(mapId);
            menu.Items.Add(exportItem);

            menu.Show(lstMaps, e.Location);
        }

        // 匯出整張地圖為 fs32
        private void ExportMapAsFs32(string mapId)
        {
            // 檢查地圖是否存在
            if (!Share.MapDataList.ContainsKey(mapId))
            {
                WinFormsMessageBox.Show($"地圖 {mapId} 不存在", "錯誤", MessageBoxButtons.OK, MessageBoxIcon.Error);
                return;
            }

            // 顯示匯出選項對話框
            using (var dialog = new L1MapViewer.Forms.ExportOptionsDialog(isFs3p: false, hasSelection: false))
            {
                if (dialog.ShowDialog(this) != DialogResult.Ok)
                    return;

                try
                {
                    // 先載入 S32 檔案
                    toolStripStatusLabel1.Text = $"正在載入地圖 {mapId}...";
                    ApplicationHelper.DoEvents();

                    var currentMap = Share.MapDataList[mapId];
                    var tempDocument = new MapDocument { MapId = mapId };

                    int loadedCount = 0;
                    foreach (var kvp in currentMap.FullFileNameList)
                    {
                        string filePath = kvp.Key;
                        var segInfo = kvp.Value;

                        if (File.Exists(filePath))
                        {
                            S32Data s32Data = null;
                            if (segInfo.isS32)
                            {
                                // 解析 .s32 檔案
                                s32Data = S32Parser.ParseFile(filePath);
                            }
                            else
                            {
                                // 解析 .seg 檔案
                                s32Data = SegParser.ParseFile(filePath);
                            }

                            if (s32Data != null)
                            {
                                s32Data.SegInfo = segInfo;
                                s32Data.FilePath = filePath;
                                tempDocument.S32Files[filePath] = s32Data;
                                loadedCount++;
                                if (loadedCount % 10 == 0)
                                {
                                    toolStripStatusLabel1.Text = $"正在載入地圖檔案... ({loadedCount})";
                                    ApplicationHelper.DoEvents();
                                }
                            }
                        }
                    }

                    if (tempDocument.S32Files.Count == 0)
                    {
                        WinFormsMessageBox.Show($"地圖 {mapId} 沒有可用的地圖檔案 (.s32 或 .seg)", "錯誤", MessageBoxButtons.OK, MessageBoxIcon.Error);
                        return;
                    }

                    // 檢查異常（在選擇儲存位置之前，若會移除 L8 擴展則不檢查）
                    if (!CheckLayer5IssuesAndConfirm(tempDocument.S32Files, "匯出", checkTileLimit: false, checkLayer8Extended: !dialog.StripLayer8Ext))
                        return;

                    // 預先準備 Layer8 SPR 打包（在 SaveFileDialog 之前）
                    var (sprListPath, sprIds) = PrepareLayer8SprPackaging(tempDocument.S32Files.Values, dialog.LayerFlags);

                    // 選擇儲存位置
                    using (var saveDialog = new SaveFileDialog())
                    {
                        saveDialog.Filter = "FS32 地圖包|*.fs32";
                        saveDialog.FileName = $"{mapId}.fs32";

                        if (saveDialog.ShowDialog(this) != DialogResult.Ok)
                            return;

                        toolStripStatusLabel1.Text = $"正在建立 fs32 檔案...";
                        ApplicationHelper.DoEvents();

                        // 建立 fs32
                        var fs32 = Fs32Writer.CreateFromMap(tempDocument, dialog.LayerFlags, dialog.IncludeTiles, dialog.StripLayer8Ext);

                        // 共用處理（R版 tile 轉換 + Layer8 SPR 打包）
                        ProcessFs32BeforeSave(fs32, dialog.IncludeTiles, sprListPath, sprIds);

                        Fs32Writer.Write(fs32, saveDialog.FileName);

                        string resultMsg = $"已匯出至 {saveDialog.FileName}\n({fs32.Blocks.Count} 區塊, {fs32.Tiles.Count} 圖塊, {fs32.Sprs.Count} SPR)";
                        toolStripStatusLabel1.Text = resultMsg.Replace("\n", " ");
                        ShowAutoCloseMessage(resultMsg, "匯出完成");
                    }
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"[Export] Error: {ex}");
                    WinFormsMessageBox.Show($"匯出失敗: {ex.Message}\n\n{ex.StackTrace}", "錯誤", MessageBoxButtons.OK, MessageBoxIcon.Error);
                }
            }
        }

        private void comboBox1_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (isFiltering) return;  // 過濾中不觸發
            if (this.comboBox1.SelectedItem == null)
                return;

            LogPerf($"[COMBOBOX-CHANGED] Start, map={this.comboBox1.SelectedItem}");
            var swCombo = Stopwatch.StartNew();

            // 保存當前選擇的地圖名稱（用名稱而非索引，避免過濾後錯亂）
            string iniPath = Path.GetTempPath() + "mapviewer.ini";
            Utils.WriteINI("MapForm", "LastSelectedMapName", this.comboBox1.SelectedItem.ToString(), iniPath);

            // 重置縮放級別
            zoomLevel = 1.0;
            if (originalMapImage != null)
            {
                originalMapImage.Dispose();
                originalMapImage = null;
            }

            // 重置 S32 編輯器縮放級別
            LogPerf($"[ZOOM-RESET] comboBox selection, old={_viewState.ZoomLevel}");
            _viewState.ZoomLevel = 1.0;
            if (originalS32Image != null)
            {
                originalS32Image.Dispose();
                originalS32Image = null;
            }

            string szSelectName = this.comboBox1.SelectedItem.ToString();
            if (szSelectName.Contains("-"))
                szSelectName = szSelectName.Split('-')[0].Trim();

            // 跳過 doPaintEvent - S32 編輯器有自己的 viewport 渲染，不需要舊版地圖縮圖
            // 這可以節省 6+ 秒（原本會讀取所有 S32 檔案計算 SHA1）
            LogPerf($"[COMBOBOX-CHANGED] Skipping doPaintEvent (S32 editor mode)");

            // 載入該地圖的 s32 檔案清單
            LoadS32FileList(szSelectName);
            LogPerf($"[COMBOBOX-CHANGED] LoadS32FileList done: {swCombo.ElapsedMilliseconds}ms");

            // 選擇後重置過濾，顯示所有地圖
            ResetMapFilter();
            LogPerf($"[COMBOBOX-CHANGED] End, total={swCombo.ElapsedMilliseconds}ms");
        }

        // ===== 小地圖 =====
        // 小地圖尺寸常數
        private const int MINIMAP_SIZE = 400;

        // 小地圖方法已移至 MapForm/MapForm.MiniMap.cs

        /// <summary>
        /// 直接複製 bitmap 像素（比 Graphics.DrawImage 快，支援透明色 0）
        /// </summary>
        private void CopyBitmapDirect(Bitmap src, Bitmap dst, int dstX, int dstY)
        {
            int srcW = src.Width;
            int srcH = src.Height;
            int dstW = dst.Width;
            int dstH = dst.Height;

            // 計算實際複製範圍
            int startX = Math.Max(0, -dstX);
            int startY = Math.Max(0, -dstY);
            int endX = Math.Min(srcW, dstW - dstX);
            int endY = Math.Min(srcH, dstH - dstY);

            if (startX >= endX || startY >= endY) return;

            Rectangle srcRect = new Rectangle(0, 0, srcW, srcH);
            Rectangle dstRect = new Rectangle(0, 0, dstW, dstH);

            BitmapData srcData = src.LockBits(srcRect, ImageLockMode.ReadOnly, PixelFormat.Format16bppRgb555);
            BitmapData dstData = dst.LockBits(dstRect, ImageLockMode.ReadWrite, PixelFormat.Format16bppRgb555);

            unsafe
            {
                byte* srcPtr = (byte*)srcData.Scan0;
                byte* dstPtr = (byte*)dstData.Scan0;
                int srcStride = srcData.Stride;
                int dstStride = dstData.Stride;

                for (int y = startY; y < endY; y++)
                {
                    ushort* srcRow = (ushort*)(srcPtr + y * srcStride + startX * 2);
                    ushort* dstRow = (ushort*)(dstPtr + (y + dstY) * dstStride + (startX + dstX) * 2);

                    for (int x = startX; x < endX; x++)
                    {
                        ushort pixel = *srcRow++;
                        if (pixel != 0)  // 跳過透明色
                        {
                            *dstRow = pixel;
                        }
                        dstRow++;
                    }
                }
            }

            src.UnlockBits(srcData);
            dst.UnlockBits(dstData);
        }

        public void vScrollBar1_Scroll(object sender, EventArgs e)
        {
            this.pictureBox1.Top = -this.vScrollBar1.Value;
            if (!this._interaction.IsMouseDrag)
                UpdateMiniMapViewportRect();
        }

        public void hScrollBar1_Scroll(object sender, EventArgs e)
        {
            this.pictureBox1.Left = -this.hScrollBar1.Value;
            if (!this._interaction.IsMouseDrag)
                UpdateMiniMapViewportRect();
        }

        private void pictureBox2_MouseDown(object sender, MouseEventArgs e)
        {
            if (e.Buttons == Eto.Forms.MouseButtons.Primary)
            {
                this._interaction.MouseDownPoint = CursorPosition.Position;
                this._interaction.IsMouseDrag = true;
                this.Cursor = Cursors.Hand;
            }
            else if (e.Buttons == Eto.Forms.MouseButtons.Alternate)
            {
                L1MapHelper.doLocTagEvent(e, this);
            }
        }

        private void pictureBox2_MouseUp(object sender, MouseEventArgs e)
        {
            if (e.Buttons != Eto.Forms.MouseButtons.Primary)
                return;

            this.Cursor = Cursors.Default;

            if (this._interaction.IsMouseDrag)
            {
                int dragDistance = Math.Abs(CursorPosition.Position.X - this._interaction.MouseDownPoint.X) +
                                  Math.Abs(CursorPosition.Position.Y - this._interaction.MouseDownPoint.Y);

                if (dragDistance < DRAG_THRESHOLD)
                {
                    int adjustedX = (int)(e.Location.X / this.zoomLevel);
                    int adjustedY = (int)(e.Location.Y / this.zoomLevel);
                    var linLoc = L1MapHelper.GetLinLocation(adjustedX, adjustedY);
                    if (linLoc != null)
                    {
                        ShowSinglePoint(linLoc.x, linLoc.y);
                    }
                }

                UpdateMiniMapViewportRect();
                this._interaction.IsMouseDrag = false;
            }
        }

        private void pictureBox2_MouseMove(object sender, MouseEventArgs e)
        {
            if (this._interaction.IsMouseDrag)
            {
                try
                {
                    int deltaX = CursorPosition.Position.X - this._interaction.MouseDownPoint.X;
                    int deltaY = CursorPosition.Position.Y - this._interaction.MouseDownPoint.Y;

                    int newScrollX = this.hScrollBar1.Value - deltaX;
                    int newScrollY = this.vScrollBar1.Value - deltaY;

                    if (this.hScrollBar1.Maximum > 0)
                    {
                        newScrollX = Math.Max(this.hScrollBar1.Minimum, Math.Min(newScrollX, this.hScrollBar1.Maximum));
                        this.hScrollBar1.Value = newScrollX;
                    }

                    if (this.vScrollBar1.Maximum > 0)
                    {
                        newScrollY = Math.Max(this.vScrollBar1.Minimum, Math.Min(newScrollY, this.vScrollBar1.Maximum));
                        this.vScrollBar1.Value = newScrollY;
                    }

                    this.vScrollBar1_Scroll(null, null);
                    this.hScrollBar1_Scroll(null, null);

                    this._interaction.MouseDownPoint = CursorPosition.Position;
                }
                catch
                {
                    // 忽略錯誤
                }
            }
            else
            {
                L1MapHelper.doMouseMoveEvent(e, this);
            }
        }

        private void pictureBox2_Paint(object sender, PaintEventArgs e)
        {
            // 可以在這裡繪製額外的標記
        }

        // 滑鼠滾輪縮放地圖
        private void Panel1_MouseWheel(object sender, MouseEventArgs e)
        {
            if (ControlCompat.ModifierKeys != Keys.Control)
                return;

            if (this.pictureBox1.Image == null)
                return;

            double oldZoom = zoomLevel;
            if (e.Delta.Height > 0)
            {
                zoomLevel = Math.Min(ZOOM_MAX, zoomLevel + ZOOM_STEP);
            }
            else
            {
                zoomLevel = Math.Max(ZOOM_MIN, zoomLevel - ZOOM_STEP);
            }

            if (Math.Abs(oldZoom - zoomLevel) < 0.001)
                return;

            if (originalMapImage == null)
            {
                originalMapImage = (Image)this.pictureBox1.Image.Clone();
            }

            this.panel1.SuspendLayout();

            try
            {
                Point mousePos = this.panel1.PointToClient(CursorPosition.Position);

                double xRatio = (double)(mousePos.X + this.hScrollBar1.Value) / this.pictureBox1.Width;
                double yRatio = (double)(mousePos.Y + this.vScrollBar1.Value) / this.pictureBox1.Height;

                int newWidth = (int)(originalMapImage.Width * zoomLevel);
                int newHeight = (int)(originalMapImage.Height * zoomLevel);

                this.pictureBox1.Size = new Size(newWidth, newHeight);
                this.pictureBox2.Size = new Size(newWidth, newHeight);
                this.pictureBox3.Size = new Size(newWidth, newHeight);
                this.pictureBox4.Size = new Size(newWidth, newHeight);

                this.hScrollBar1.Maximum = Math.Max(0, newWidth);
                this.vScrollBar1.Maximum = Math.Max(0, newHeight);

                int newScrollX = (int)(newWidth * xRatio - mousePos.X);
                int newScrollY = (int)(newHeight * yRatio - mousePos.Y);

                this.hScrollBar1.Value = Math.Max(0, Math.Min(this.hScrollBar1.Maximum - this.panel1.Width, newScrollX));
                this.vScrollBar1.Value = Math.Max(0, Math.Min(this.vScrollBar1.Maximum - this.panel1.Height, newScrollY));

                this.vScrollBar1_Scroll(null, null);
                this.hScrollBar1_Scroll(null, null);
            }
            finally
            {
                this.panel1.ResumeLayout();
            }

            this.panel1.Invalidate();
        }

        // S32 編輯器滑鼠滾輪事件
        private void S32MapPanel_MouseWheel(object sender, MouseEventArgs e)
        {
            // Shift+滾輪 = 左右捲動，普通滾輪 = 上下捲動
            // 注意：Ctrl+滾輪縮放已移至 MapViewerControl 的縮放按鈕
            int scrollAmount = (int)(100 / _viewState.ZoomLevel);  // 捲動量（世界座標像素）
            int currentX = _viewState.ScrollX;
            int currentY = _viewState.ScrollY;

            // 使用 ViewState 的捲動限制（已包含緩衝區）
            if (ControlCompat.ModifierKeys == Keys.Shift)
            {
                // 左右捲動
                int newX = currentX - (e.Delta.Height > 0 ? scrollAmount : -scrollAmount);
                newX = Math.Max(_viewState.MinScrollX, Math.Min(newX, _viewState.MaxScrollX));
                _viewState.SetScrollSilent(newX, currentY);
            }
            else
            {
                // 上下捲動
                int newY = currentY - (e.Delta.Height > 0 ? scrollAmount : -scrollAmount);
                newY = Math.Max(_viewState.MinScrollY, Math.Min(newY, _viewState.MaxScrollY));
                _viewState.SetScrollSilent(currentX, newY);
            }

            // 檢查是否需要重新渲染
            CheckAndRerenderIfNeeded();

            // 更新小地圖紅框
            UpdateMiniMapViewportRect();

            // 阻止事件繼續傳遞
            ((HandledMouseEventArgs)e).Handled = true;
        }

        // 執行實際的縮放操作（使用 Viewport 渲染）
        private void ApplyS32Zoom(double targetZoomLevel)
        {
            try
            {
                LogPerf($"[APPLY-ZOOM] start, targetZoom={targetZoomLevel}, currentZoom={_viewState.ZoomLevel}");

                // 檢查是否有載入地圖
                if (_viewState.MapWidth <= 0 || _viewState.MapHeight <= 0)
                {
                    LogPerf($"[APPLY-ZOOM] no map loaded");
                    return;
                }

                // 更新縮放級別（統一在 _viewState 中管理）
                _viewState.ZoomLevel = 1.0 + targetZoomLevel;

                // 注意：不要清除舊的渲染狀態，讓舊 bitmap 繼續顯示直到新的準備好
                // NeedsRerender() 會檢測到縮放改變並觸發重新渲染

                LogPerf($"[APPLY-ZOOM] calling RenderS32Map");

                // 重新渲染（縮放改變會觸發重新渲染）
                RenderS32Map();

                LogPerf($"[APPLY-ZOOM] calling UpdateMiniMapViewportRect");

                // 更新小地圖紅框（縮放只影響視窗大小，不需重繪底圖）
                UpdateMiniMapViewportRect();

                // 更新狀態欄顯示縮放級別
                this.lblS32Info.Text = $"縮放: {_viewState.ZoomLevel:P0}";

                LogPerf($"[APPLY-ZOOM] done");
            }
            catch (Exception ex)
            {
                LogPerf($"[APPLY-ZOOM] error: {ex.Message}");
                this.lblS32Info.Text = $"縮放失敗: {ex.Message}";
            }
        }

        // 顯示單點座標
        private void ShowSinglePoint(int x, int y)
        {
            string coords = string.Format("{0},{1}", x, y);
            this.toolStripStatusLabel2.Text = coords;

            try
            {
                ClipboardHelper.SetText(coords);
                this.toolStripStatusLabel1.Text = "已複製: " + coords;
            }
            catch
            {
                this.toolStripStatusLabel1.Text = coords;
            }
        }

        // 小地圖事件處理方法已移至 MapForm/MapForm.MiniMap.cs

        // ===== S32 編輯器功能 =====
        // 類型定義已移至 Models/S32DataModels.cs

        // 當前選擇的 S32 檔案資訊（用於顯示）
        private S32FileItem currentS32FileItem;

        // 便捷屬性：從字典中獲取當前選中的 S32 資料
        private S32Data currentS32Data
        {
            get
            {
                if (currentS32FileItem != null && _document.S32Files.ContainsKey(currentS32FileItem.FilePath))
                {
                    return _document.S32Files[currentS32FileItem.FilePath];
                }
                return null;
            }
        }

        // 便捷屬性：檢查當前選中的 S32 是否已修改
        private bool isS32Modified
        {
            get
            {
                return currentS32Data != null && currentS32Data.IsModified;
            }
            set
            {
                if (currentS32Data != null)
                {
                    currentS32Data.IsModified = value;
                }
            }
        }

        // 區域選擇相關變量
        private bool isSelectingRegion = false;
        // regionStartPoint 已移至 _interaction.RegionStartPoint
        private Point regionEndPoint;
        private Rectangle selectedRegion;

        // Layer4 複製貼上相關變數
        // isLayer4CopyMode 已移至 _interaction.IsLayer4CopyMode
        private bool hasLayer4Clipboard = false;         // 剪貼簿是否有資料
        private Rectangle copyRegionBounds;               // 複製區域的範圍（螢幕座標）

        // 複製/刪除設定（由 Dialog 設定）
        private bool copySettingLayer1 = true;
        private bool copySettingLayer2 = true;
        private bool copySettingLayer3 = true;
        private bool copySettingLayer4 = true;
        private bool copySettingLayer5 = true;
        private bool copySettingLayer7 = true;
        private bool copySettingLayer8 = true;
        // 向後相容屬性
        private bool copySettingLayer5to8 => copySettingLayer5 || copySettingLayer7 || copySettingLayer8;

        // 根據遊戲座標找到對應的 S32Data
        private S32Data GetS32DataByGameCoords(int gameX, int gameY)
        {
            foreach (var s32Data in _document.S32Files.Values)
            {
                if (gameX >= s32Data.SegInfo.nLinBeginX && gameX <= s32Data.SegInfo.nLinEndX &&
                    gameY >= s32Data.SegInfo.nLinBeginY && gameY <= s32Data.SegInfo.nLinEndY)
                {
                    return s32Data;
                }
            }
            return null;
        }

        // [座標轉換方法已移至 MapForm.Coordinates.cs]

        // 載入當前地圖的 s32 檔案清單並載入所有 S32 資料
        private void LoadS32FileList(string mapId)
        {
            LogPerf($"[LOAD-S32-LIST] Start, mapId={mapId}");
            var totalStopwatch = Stopwatch.StartNew();
            var phaseStopwatch = new Stopwatch();

            lstS32Files.Items.Clear();
            _checkedS32Files.Clear();  // 清空快取
            _document.S32Files.Clear();
            _layer4SpatialIndex.Clear();  // 清空 Layer4 空間索引
            _document.MapId = mapId;
            lblS32Files.Text = "S32 檔案清單";  // 重置標籤

            // 清除所有快取
            ClearS32BlockCache();
            ClearMiniMapCache();
            cachedAggregatedTiles.Clear();
            _renderCache.TileDataCache.Clear();
            _renderCache.TilFileCache.Clear();
            _renderCache.TilRemasterCache.Clear();
            LogPerf($"[LOAD-S32-LIST] Caches cleared: {totalStopwatch.ElapsedMilliseconds}ms");

            // 清除 viewport bitmap
            lock (_renderCache.ViewportBitmapLock)
            {
                if (_renderCache.ViewportBitmap != null)
                {
                    _renderCache.ViewportBitmap.Dispose();
                    _renderCache.ViewportBitmap = null;
                }
            }

            // 重置 ViewState
            _viewState.Reset();

            // 清除編輯狀態（保留剪貼簿以支援跨地圖複製）
            _editState.SelectedCells.Clear();
            // 注意：不清除 CellClipboard、Layer2Clipboard、Layer5-8Clipboard，以支援跨地圖複製
            // _editState.CellClipboard.Clear();
            // _editState.Layer2Clipboard.Clear();
            // _editState.Layer5Clipboard.Clear();
            // _editState.Layer6Clipboard.Clear();
            // _editState.Layer7Clipboard.Clear();
            // _editState.Layer8Clipboard.Clear();
            _editState.UndoHistory.Clear();
            _editState.RedoHistory.Clear();
            _editState.SelectedLayer4Groups.Clear();
            // hasLayer4Clipboard 也保留，不清除
            _interaction.IsLayer4CopyMode = false;
            selectedRegion = new Rectangle();
            copyRegionBounds = new Rectangle();

            // 清除群組縮圖
            lvGroupThumbnails.Items.Clear();

            // 隱藏 Layer5 異常按鈕
            btnMapValidate.Visible = false;

            // 從 Share.MapDataList 取得地圖資料
            if (!Share.MapDataList.ContainsKey(mapId))
                return;

            Struct.L1Map currentMap = Share.MapDataList[mapId];

            // 階段 1: UI 清單建立
            phaseStopwatch.Restart();
            List<S32FileItem> s32FileItems = new List<S32FileItem>();
            foreach (var kvp in currentMap.FullFileNameList)
            {
                string filePath = kvp.Key;
                Struct.L1MapSeg segInfo = kvp.Value;

                // 處理 s32 和 seg 檔案
                string fileName = Path.GetFileName(filePath);
                string fileType = segInfo.isS32 ? "" : " [SEG]";
                string displayName = $"{fileName}{fileType} ({segInfo.nBlockX:X4},{segInfo.nBlockY:X4}) [{segInfo.nLinBeginX},{segInfo.nLinBeginY}~{segInfo.nLinEndX},{segInfo.nLinEndY}]";

                S32FileItem item = new S32FileItem
                {
                    FilePath = filePath,
                    DisplayName = displayName,
                    SegInfo = segInfo,
                    IsChecked = true
                };

                int index = lstS32Files.Items.Add(item);
                lstS32Files.SetItemChecked(index, true);  // 預設勾選
                _checkedS32Files.Add(filePath);  // 加入快取
                s32FileItems.Add(item);
            }
            long uiListMs = phaseStopwatch.ElapsedMilliseconds;

            // 自動選擇第一個S32檔案
            if (lstS32Files.Items.Count > 0)
            {
                lstS32Files.SelectedIndex = 0;
            }

            // 更新 S32 檔案清單標籤顯示數量
            lblS32Files.Text = $"S32 檔案清單 ({s32FileItems.Count})";

            this.toolStripStatusLabel1.Text = $"找到 {s32FileItems.Count} 個 S32 檔案，正在載入...";

            // 使用背景執行緒順序載入（避免並行造成磁碟競爭）
            LogPerf($"[LOAD-S32-LIST] Starting background Task.Run, s32Count={s32FileItems.Count}");
            Task.Run(() =>
            {
                LogPerf("[LOAD-S32-BG] Task started");
                long totalFileReadMs = 0;
                long totalParseMs = 0;
                int loadedCount = 0;

                // 階段 1: 循序讀取所有檔案（避免磁碟競爭）
                var fileDataList = new List<(S32FileItem item, byte[] data)>();
                var readSw = Stopwatch.StartNew();
                foreach (var item in s32FileItems)
                {
                    try
                    {
                        byte[] data = File.ReadAllBytes(item.FilePath);
                        fileDataList.Add((item, data));
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine($"讀取 S32 檔案失敗: {item.FilePath}, 錯誤: {ex.Message}");
                    }
                }
                readSw.Stop();
                totalFileReadMs = readSw.ElapsedMilliseconds;
                LogPerf($"[LOAD-S32-BG] File read done: {totalFileReadMs}ms, files={fileDataList.Count}");

                // 階段 2: 平行解析所有檔案（使用 ConcurrentBag 避免 Dictionary 鎖競爭）
                var parsedResults = new System.Collections.Concurrent.ConcurrentBag<(string path, S32Data data)>();
                var parseSw = Stopwatch.StartNew();
                var parallelOptions = new System.Threading.Tasks.ParallelOptions
                {
                    MaxDegreeOfParallelism = Environment.ProcessorCount
                };
                System.Threading.Tasks.Parallel.ForEach(fileDataList, parallelOptions, fileData =>
                {
                    try
                    {
                        S32Data s32Data;
                        if (fileData.item.SegInfo.isS32)
                        {
                            // 解析 .s32 檔案
                            s32Data = ParseS32File(fileData.data);
                        }
                        else
                        {
                            // 解析 .seg 檔案
                            s32Data = SegParser.Parse(fileData.data);
                        }

                        if (s32Data != null)
                        {
                            s32Data.FilePath = fileData.item.FilePath;
                            s32Data.SegInfo = fileData.item.SegInfo;
                            s32Data.IsModified = false;
                            parsedResults.Add((fileData.item.FilePath, s32Data));
                        }
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine($"解析地圖檔案失敗: {fileData.item.FilePath}, 錯誤: {ex.Message}");
                    }
                });
                parseSw.Stop();
                totalParseMs = parseSw.ElapsedMilliseconds;

                // 將結果複製到 _document.S32Files
                foreach (var (path, data) in parsedResults)
                {
                    _document.S32Files[path] = data;
                }
                loadedCount = parsedResults.Count;

                LogPerf($"[S32-LOAD] {loadedCount} files, read={totalFileReadMs}ms (seq), parse={totalParseMs}ms (parallel)");

                // 建立空間索引（用於快速查找 worldRect 內的 S32）
                BuildS32SpatialIndex();

                // 建立 Layer4 空間索引（用於快速查找附近物件）
                BuildLayer4SpatialIndex();

                // 預載入所有 tile 檔案（背景執行，與 UI 更新並行）
                PreloadTilesAsync(_document.S32Files.Values.ToList());

                // 記錄背景載入完成時間
                long bgLoadMs = totalStopwatch.ElapsedMilliseconds;

                // 載入完成後更新 UI
                this.Invoke((MethodInvoker)delegate
                {
                    long invokeStartMs = totalStopwatch.ElapsedMilliseconds;
                    long invokeOverheadMs = invokeStartMs - bgLoadMs;

                    // 階段 3: 設定初始捲動位置到地圖中央（在渲染之前）
                    phaseStopwatch.Restart();
                    if (_document.S32Files.Count > 0)
                    {
                        SetInitialScrollToCenter(currentMap);
                    }
                    long scrollSetupMs = phaseStopwatch.ElapsedMilliseconds;

                    // 階段 4: Viewport 渲染（已經在中央位置）
                    phaseStopwatch.Restart();
                    if (_document.S32Files.Count > 0)
                    {
                        // 同步 CheckedS32Files 到 MapDocument
                        SyncCheckedS32FilesToDocument();

                        // 使用舊的渲染（MapViewerControl 整合尚未完成）
                        RenderS32Map();

                        // TODO: 完成 MapViewerControl 整合後改用這個
                        // _mapViewerControl.LoadMap(_document);
                    }
                    long viewportRenderMs = phaseStopwatch.ElapsedMilliseconds;

                    // 階段 5: 小地圖更新
                    phaseStopwatch.Restart();
                    if (_document.S32Files.Count > 0)
                    {
                        UpdateMiniMap();
                    }
                    long miniMapMs = phaseStopwatch.ElapsedMilliseconds;

                    // 階段 6: Tile 列表 + 群組縮圖更新（兩者並行背景執行）
                    phaseStopwatch.Restart();
                    if (_document.S32Files.Count > 0)
                    {
                        UpdateGroupThumbnailsList();  // 異步，立即返回
                        UpdateTileListAsync();        // 異步，立即返回
                        UpdateMapValidateButton();
                    }
                    long tileListMs = phaseStopwatch.ElapsedMilliseconds;  // 只計算啟動時間
                    long thumbnailStartMs = 0;  // 已合併到上面

                    totalStopwatch.Stop();
                    long totalMs = totalStopwatch.ElapsedMilliseconds;

                    // 計算各階段佔比
                    long sumMs = uiListMs + totalFileReadMs + totalParseMs + invokeOverheadMs + scrollSetupMs + viewportRenderMs + miniMapMs + tileListMs + thumbnailStartMs;
                    long unmeasuredMs = totalMs - sumMs;

                    // 顯示載入時間統計（群組縮圖在背景執行，完成後會更新自己的標籤）
                    string stats = $"Loaded ({_document.S32Files.Count} S32) | " +
                                   $"Total: {totalMs}ms | " +
                                   $"UI: {uiListMs}ms | " +
                                   $"FileRead: {totalFileReadMs}ms | " +
                                   $"Parse: {totalParseMs}ms | " +
                                   $"Viewport: {viewportRenderMs}ms | " +
                                   $"TileList: {tileListMs}ms | " +
                                   $"Thumbnails: background";

                    this.toolStripStatusLabel1.Text = stats;

                    // Console log detailed timing
                    Console.WriteLine("========================================");
                    Console.WriteLine($"[LOAD TIMING] Map: {mapId}, S32 Files: {_document.S32Files.Count}");
                    Console.WriteLine("========================================");
                    Console.WriteLine($"  UI List:        {uiListMs,6} ms  ({(uiListMs * 100.0 / totalMs),5:F1}%)");
                    Console.WriteLine($"  File Read:      {totalFileReadMs,6} ms  ({(totalFileReadMs * 100.0 / totalMs),5:F1}%)  [{s32FileItems.Count} files]");
                    Console.WriteLine($"  S32 Parse:      {totalParseMs,6} ms  ({(totalParseMs * 100.0 / totalMs),5:F1}%)");
                    Console.WriteLine($"  Invoke Wait:    {invokeOverheadMs,6} ms  ({(invokeOverheadMs * 100.0 / totalMs),5:F1}%)  [thread switch]");
                    Console.WriteLine($"  Scroll Setup:   {scrollSetupMs,6} ms  ({(scrollSetupMs * 100.0 / totalMs),5:F1}%)  [set center pos]");
                    Console.WriteLine($"  Viewport:       {viewportRenderMs,6} ms  ({(viewportRenderMs * 100.0 / totalMs),5:F1}%)");
                    Console.WriteLine($"  Mini Map:       {miniMapMs,6} ms  ({(miniMapMs * 100.0 / totalMs),5:F1}%)");
                    Console.WriteLine($"  Tile List:      {tileListMs,6} ms  ({(tileListMs * 100.0 / totalMs),5:F1}%)");
                    Console.WriteLine($"  Thumb Start:    {thumbnailStartMs,6} ms  ({(thumbnailStartMs * 100.0 / totalMs),5:F1}%)  [async start]");
                    Console.WriteLine($"  Unmeasured:     {unmeasuredMs,6} ms  ({(unmeasuredMs * 100.0 / totalMs),5:F1}%)");
                    Console.WriteLine("----------------------------------------");
                    Console.WriteLine($"  TOTAL:          {totalMs,6} ms  (thumbnails in background)");
                    Console.WriteLine("========================================");
                });
            });
        }

        // 分析第三層屬性類型
        private void AnalyzeLayer3Attributes()
        {
            // 統計 Attribute1 和 Attribute2 的所有不同值
            Dictionary<short, int> attr1Values = new Dictionary<short, int>();
            Dictionary<short, int> attr2Values = new Dictionary<short, int>();

            foreach (var s32Data in _document.S32Files.Values)
            {
                for (int y = 0; y < 64; y++)
                {
                    for (int x = 0; x < 64; x++)
                    {
                        var attr = s32Data.Layer3[y, x];
                        if (attr == null) continue;

                        // 統計 Attribute1
                        if (!attr1Values.ContainsKey(attr.Attribute1))
                            attr1Values[attr.Attribute1] = 0;
                        attr1Values[attr.Attribute1]++;

                        // 統計 Attribute2
                        if (!attr2Values.ContainsKey(attr.Attribute2))
                            attr2Values[attr.Attribute2] = 0;
                        attr2Values[attr.Attribute2]++;
                    }
                }
            }

            // 建立分析結果
            StringBuilder sb = new StringBuilder();
            sb.AppendLine($"地圖: {_document.MapId}");
            sb.AppendLine();

            sb.AppendLine("【左上邊 (Attribute1) 統計】");
            foreach (var kvp in attr1Values.OrderByDescending(x => x.Value).Take(15))
            {
                string flags = Layer3AttributeDecoder.GetAttributeFlags(kvp.Key);
                sb.AppendLine($"  0x{kvp.Key:X4}: {kvp.Value} 個 | {flags}");
            }
            if (attr1Values.Count > 15)
                sb.AppendLine($"  ... 還有 {attr1Values.Count - 15} 種其他值");

            sb.AppendLine();
            sb.AppendLine("【右上邊 (Attribute2) 統計】");
            foreach (var kvp in attr2Values.OrderByDescending(x => x.Value).Take(15))
            {
                string flags = Layer3AttributeDecoder.GetAttributeFlags(kvp.Key);
                sb.AppendLine($"  0x{kvp.Key:X4}: {kvp.Value} 個 | {flags}");
            }
            if (attr2Values.Count > 15)
                sb.AppendLine($"  ... 還有 {attr2Values.Count - 15} 種其他值");

            WinFormsMessageBox.Show(sb.ToString(), "第三層屬性分析", MessageBoxButtons.OK, MessageBoxIcon.Information);
        }

        // 取得屬性標記說明 - 已移至 Helper/Layer3AttributeDecoder.cs

        // s32 檔案選擇變更事件
        private void lstS32Files_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (lstS32Files.SelectedItem == null)
                return;

            var item = (S32FileItem)lstS32Files.SelectedItem;

            // 保存當前選擇的檔案資訊
            currentS32FileItem = item;

            // 載入並解析 s32 檔案
            LoadAndParseS32File(item.FilePath);
        }

        // S32 檔案清單繪製事件（自訂高亮）
        private void lstS32Files_DrawItem(object sender, DrawItemEventArgs e)
        {
            if (e.Index < 0 || e.Index >= lstS32Files.Items.Count)
                return;

            var item = lstS32Files.Items[e.Index] as S32FileItem;
            if (item == null)
                return;

            // 判斷是否需要高亮（選取區域涉及的 S32）
            bool isHighlighted = _highlightedS32Paths != null && _highlightedS32Paths.Contains(item.FilePath);
            bool isSelected = (e.State & DrawItemState.Selected) == DrawItemState.Selected;
            bool isChecked = lstS32Files.GetItemChecked(e.Index);

            // 繪製背景
            Color backColor;
            if (isSelected)
                backColor = SystemColors.Highlight;
            else if (isHighlighted)
                backColor = Color.FromArgb(255, 255, 200);  // 淡黃色高亮
            else
                backColor = SystemColors.Window;

            using (var brush = new SolidBrush(backColor))
            {
                e.Graphics.FillRectangle(brush, e.Bounds);
            }

            // 繪製勾選框
            int checkboxWidth = 16;
            Rectangle checkRect = new Rectangle(e.Bounds.X + 2, e.Bounds.Y + (e.Bounds.Height - 12) / 2, 12, 12);
            ControlPaint.DrawCheckBox(e.Graphics, checkRect,
                isChecked ? ButtonState.Checked : ButtonState.Normal);

            // 繪製文字
            Color textColor = isSelected ? SystemColors.HighlightText : SystemColors.WindowText;
            Font drawFont = e.Font ?? lstS32Files.Font;
            using (var brush = new SolidBrush(textColor))
            {
                Rectangle textRect = new Rectangle(e.Bounds.X + checkboxWidth + 4, e.Bounds.Y,
                    e.Bounds.Width - checkboxWidth - 4, e.Bounds.Height);

                var format = new StringFormat
                {
                    LineAlignment = StringAlignment.Center,
                    Trimming = StringTrimming.EllipsisCharacter
                };
                e.Graphics.DrawString(item.ToString(), drawFont, brush, textRect, format);
            }

            // 繪製焦點框
            if ((e.State & DrawItemState.Focus) == DrawItemState.Focus)
            {
                ControlPaint.DrawFocusRectangle(e.Graphics, e.Bounds);
            }
        }

        // S32 檔案清單右鍵跳轉
        private void lstS32Files_MouseUp(object sender, MouseEventArgs e)
        {
            if (e.Buttons != Eto.Forms.MouseButtons.Alternate)
                return;

            // 取得點擊位置的項目
            int index = lstS32Files.IndexFromPoint(e.Location.ToPoint());
            if (index < 0 || index >= lstS32Files.Items.Count)
                return;

            var item = lstS32Files.Items[index] as S32FileItem;
            if (item == null)
                return;

            // 選取該項目
            lstS32Files.SelectedIndex = index;

            // 建立右鍵選單
            ContextMenuStrip menu = new ContextMenuStrip();

            // 跳轉選項
            ToolStripMenuItem jumpItem = new ToolStripMenuItem("跳轉至此區塊");
            jumpItem.Click += (s, args) =>
            {
                JumpToS32Block(item);
            };
            menu.Items.Add(jumpItem);

            // 查看詳細選項
            ToolStripMenuItem detailItem = new ToolStripMenuItem("查看詳細資料");
            detailItem.Click += (s, args) =>
            {
                ShowS32Details(item);
            };
            menu.Items.Add(detailItem);

            menu.Items.Add(new ToolStripSeparator());

            // 匯出整張地圖
            ToolStripMenuItem exportMapItem = new ToolStripMenuItem("匯出整張地圖為 fs32 地圖包...");
            exportMapItem.Click += (s, args) => ExportCurrentMapAsFs32();
            menu.Items.Add(exportMapItem);

            // 匯出已勾選的 S32 檔案
            int checkedCount = lstS32Files.CheckedItems.Count;
            if (checkedCount > 0)
            {
                ToolStripMenuItem exportCheckedItem = new ToolStripMenuItem($"匯出已勾選的 {checkedCount} 個區塊為 fs32 地圖包...");
                exportCheckedItem.Click += (s, args) => ExportCheckedS32AsFs32();
                menu.Items.Add(exportCheckedItem);
            }

            menu.Items.Add(new ToolStripSeparator());

            // 匯入 fs32 地圖包
            ToolStripMenuItem importFs32Item = new ToolStripMenuItem("匯入 fs32 地圖包...");
            importFs32Item.Click += (s, args) => ImportFs32ToCurrentMap();
            menu.Items.Add(importFs32Item);

            menu.Items.Add(new ToolStripSeparator());

            // ⚠ 危險操作區
            // 清空 S32 資料
            ToolStripMenuItem clearS32Item = new ToolStripMenuItem("⚠ 清空此區塊資料...");
            clearS32Item.TextColor = Colors.Red;
            clearS32Item.Click += (s, args) => ClearS32Data(item);
            menu.Items.Add(clearS32Item);

            // 刪除 S32 檔案
            ToolStripMenuItem deleteS32Item = new ToolStripMenuItem("⚠ 刪除此區塊...");
            deleteS32Item.TextColor = Colors.Red;
            deleteS32Item.Click += (s, args) => DeleteS32File(item);
            menu.Items.Add(deleteS32Item);

            // 刪除已勾選的所有區塊
            if (checkedCount > 0)
            {
                ToolStripMenuItem deleteCheckedItem = new ToolStripMenuItem($"⚠ 刪除已勾選的 {checkedCount} 個區塊...");
                deleteCheckedItem.TextColor = Colors.Red;
                deleteCheckedItem.Click += (s, args) => DeleteCheckedS32Files();
                menu.Items.Add(deleteCheckedItem);
            }

            menu.Show(lstS32Files, e.Location);
        }

        // 清空 S32 區塊資料（危險操作）
        private void ClearS32Data(S32FileItem item)
        {
            if (item == null || !_document.S32Files.TryGetValue(item.FilePath, out var s32Data))
            {
                WinFormsMessageBox.Show("找不到指定的 S32 檔案", "錯誤", MessageBoxButtons.OK, MessageBoxIcon.Error);
                return;
            }

            string fileName = Path.GetFileName(item.FilePath);

            // 第一次確認
            var result1 = WinFormsMessageBox.Show(
                $"⚠ 警告：這是危險操作！\n\n" +
                $"確定要清空 [{fileName}] 的所有資料嗎？\n\n" +
                $"這將清除：\n" +
                $"• Layer1 (地板): {s32Data.Layer1?.Length ?? 0} 格\n" +
                $"• Layer2 (裝飾): {s32Data.Layer2?.Count ?? 0} 個\n" +
                $"• Layer3 (屬性): {s32Data.Layer3?.Length ?? 0} 格\n" +
                $"• Layer4 (物件): {s32Data.Layer4?.Count ?? 0} 個\n" +
                $"• Layer5 (透明): {s32Data.Layer5?.Count ?? 0} 個\n" +
                $"• Layer6 (光源): {s32Data.Layer6?.Count ?? 0} 個\n" +
                $"• Layer7 (傳送): {s32Data.Layer7?.Count ?? 0} 個\n" +
                $"• Layer8 (事件): {s32Data.Layer8?.Count ?? 0} 個\n\n" +
                $"此操作無法復原！",
                "⚠ 危險操作確認",
                MessageBoxButtons.YesNo,
                MessageBoxIcon.Warning,
                MessageBoxDefaultButton.Button2);

            if (result1 != DialogResult.Yes)
                return;

            // 第二次確認
            var result2 = WinFormsMessageBox.Show(
                $"⚠ 最後確認！\n\n" +
                $"真的要清空 [{fileName}] 的所有資料嗎？\n\n" +
                $"請輸入 [是] 繼續執行。",
                "⚠ 最終確認",
                MessageBoxButtons.YesNo,
                MessageBoxIcon.Stop,
                MessageBoxDefaultButton.Button2);

            if (result2 != DialogResult.Yes)
                return;

            // 執行清空
            // Layer1: 全部設為空 (2D array [64, 128])
            if (s32Data.Layer1 != null)
            {
                for (int y = 0; y < 64; y++)
                {
                    for (int x = 0; x < 128; x++)
                    {
                        s32Data.Layer1[y, x] = new TileCell { X = x, Y = y, TileId = 0, IndexId = 0 };
                    }
                }
            }

            // Layer2: 清空列表
            s32Data.Layer2?.Clear();

            // Layer3: 全部設為空 (2D array [64, 64])
            if (s32Data.Layer3 != null)
            {
                for (int y = 0; y < 64; y++)
                {
                    for (int x = 0; x < 64; x++)
                    {
                        s32Data.Layer3[y, x] = new MapAttribute { Attribute1 = 0, Attribute2 = 0 };
                    }
                }
            }

            // Layer4-8: 清空列表
            s32Data.Layer4?.Clear();
            s32Data.Layer5?.Clear();
            s32Data.Layer6?.Clear();
            s32Data.Layer7?.Clear();
            s32Data.Layer8?.Clear();

            s32Data.IsModified = true;

            // 重新渲染
            ClearS32BlockCache();
            RenderS32Map();
            lstS32Files.Invalidate(); // 刷新列表顯示

            WinFormsMessageBox.Show(
                $"已清空 [{fileName}] 的所有資料。\n\n請記得儲存變更。",
                "清空完成",
                MessageBoxButtons.OK,
                MessageBoxIcon.Information);
        }

        // 刪除 S32 檔案（危險操作）
        private void DeleteS32File(S32FileItem item)
        {
            if (item == null || !_document.S32Files.ContainsKey(item.FilePath))
            {
                WinFormsMessageBox.Show("找不到指定的 S32 檔案", "錯誤", MessageBoxButtons.OK, MessageBoxIcon.Error);
                return;
            }

            string fileName = Path.GetFileName(item.FilePath);

            // 第一次確認
            var result1 = WinFormsMessageBox.Show(
                $"⚠ 警告：這是危險操作！\n\n" +
                $"確定要刪除 [{fileName}] 嗎？\n\n" +
                $"這將從地圖中移除此區塊，並刪除磁碟上的檔案。\n\n" +
                $"此操作無法復原！",
                "⚠ 危險操作確認",
                MessageBoxButtons.YesNo,
                MessageBoxIcon.Warning,
                MessageBoxDefaultButton.Button2);

            if (result1 != DialogResult.Yes)
                return;

            // 第二次確認
            var result2 = WinFormsMessageBox.Show(
                $"⚠ 最後確認！\n\n" +
                $"真的要刪除 [{fileName}] 嗎？\n" +
                $"檔案路徑: {item.FilePath}\n\n" +
                $"請輸入 [是] 繼續執行。",
                "⚠ 最終確認",
                MessageBoxButtons.YesNo,
                MessageBoxIcon.Stop,
                MessageBoxDefaultButton.Button2);

            if (result2 != DialogResult.Yes)
                return;

            try
            {
                // 從記憶體中移除
                _document.S32Files.Remove(item.FilePath);
                _checkedS32Files.Remove(item.FilePath);

                // 刪除磁碟上的檔案
                if (File.Exists(item.FilePath))
                {
                    File.Delete(item.FilePath);
                }

                // 重新載入地圖（重新讀取所有 S32 檔案）
                ReloadCurrentMap();

                WinFormsMessageBox.Show(
                    $"已刪除 [{fileName}]。",
                    "刪除完成",
                    MessageBoxButtons.OK,
                    MessageBoxIcon.Information);
            }
            catch (Exception ex)
            {
                WinFormsMessageBox.Show(
                    $"刪除檔案時發生錯誤：\n{ex.Message}",
                    "錯誤",
                    MessageBoxButtons.OK,
                    MessageBoxIcon.Error);
            }
        }

        // 刪除已勾選的所有 S32 檔案（危險操作）
        private void DeleteCheckedS32Files()
        {
            // 收集已勾選的項目
            var checkedItems = new List<S32FileItem>();
            for (int i = 0; i < lstS32Files.Items.Count; i++)
            {
                if (lstS32Files.GetItemChecked(i) && lstS32Files.Items[i] is S32FileItem item)
                {
                    checkedItems.Add(item);
                }
            }

            if (checkedItems.Count == 0)
            {
                WinFormsMessageBox.Show("沒有已勾選的 S32 檔案", "提示", MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            // 建立檔案名稱清單（最多顯示 10 個）
            string fileListPreview = "";
            int showCount = Math.Min(checkedItems.Count, 10);
            for (int i = 0; i < showCount; i++)
            {
                fileListPreview += $"• {Path.GetFileName(checkedItems[i].FilePath)}\n";
            }
            if (checkedItems.Count > 10)
            {
                fileListPreview += $"... 還有 {checkedItems.Count - 10} 個\n";
            }

            // 第一次確認
            var result1 = WinFormsMessageBox.Show(
                $"⚠ 警告：這是危險操作！\n\n" +
                $"確定要刪除以下 {checkedItems.Count} 個區塊嗎？\n\n" +
                $"{fileListPreview}\n" +
                $"這將從地圖中移除這些區塊，並刪除磁碟上的檔案。\n\n" +
                $"此操作無法復原！",
                "⚠ 危險操作確認",
                MessageBoxButtons.YesNo,
                MessageBoxIcon.Warning,
                MessageBoxDefaultButton.Button2);

            if (result1 != DialogResult.Yes)
                return;

            // 第二次確認
            var result2 = WinFormsMessageBox.Show(
                $"⚠ 最後確認！\n\n" +
                $"真的要刪除這 {checkedItems.Count} 個區塊嗎？\n\n" +
                $"請輸入 [是] 繼續執行。",
                "⚠ 最終確認",
                MessageBoxButtons.YesNo,
                MessageBoxIcon.Stop,
                MessageBoxDefaultButton.Button2);

            if (result2 != DialogResult.Yes)
                return;

            try
            {
                int deletedCount = 0;
                var errors = new List<string>();

                foreach (var item in checkedItems)
                {
                    try
                    {
                        // 從記憶體中移除
                        _document.S32Files.Remove(item.FilePath);
                        _checkedS32Files.Remove(item.FilePath);

                        // 刪除磁碟上的檔案
                        if (File.Exists(item.FilePath))
                        {
                            File.Delete(item.FilePath);
                        }

                        deletedCount++;
                    }
                    catch (Exception ex)
                    {
                        errors.Add($"{Path.GetFileName(item.FilePath)}: {ex.Message}");
                    }
                }

                // 重新載入地圖
                ReloadCurrentMap();

                // 顯示結果
                string resultMessage = $"已刪除 {deletedCount} 個區塊。";
                if (errors.Count > 0)
                {
                    resultMessage += $"\n\n以下 {errors.Count} 個檔案刪除失敗：\n" + string.Join("\n", errors.Take(5));
                    if (errors.Count > 5)
                    {
                        resultMessage += $"\n... 還有 {errors.Count - 5} 個錯誤";
                    }
                }

                WinFormsMessageBox.Show(
                    resultMessage,
                    "刪除完成",
                    MessageBoxButtons.OK,
                    errors.Count > 0 ? MessageBoxIcon.Warning : MessageBoxIcon.Information);
            }
            catch (Exception ex)
            {
                WinFormsMessageBox.Show(
                    $"刪除檔案時發生錯誤：\n{ex.Message}",
                    "錯誤",
                    MessageBoxButtons.OK,
                    MessageBoxIcon.Error);
            }
        }

        // 匯出當前地圖為 fs32
        private void ExportCurrentMapAsFs32()
        {
            if (string.IsNullOrEmpty(_document.MapId) || _document.S32Files.Count == 0)
            {
                WinFormsMessageBox.Show("請先載入地圖", "提示", MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            using (var dialog = new L1MapViewer.Forms.ExportOptionsDialog(isFs3p: false, hasSelection: false))
            {
                if (dialog.ShowDialog(this) != DialogResult.Ok)
                    return;

                // 檢查異常（匯出不檢查 Tile 上限，若會移除 L8 擴展則不檢查）
                if (!CheckLayer5IssuesAndConfirm(_document.S32Files, "匯出", checkTileLimit: false, checkLayer8Extended: !dialog.StripLayer8Ext))
                    return;

                // 預先準備 Layer8 SPR 打包（在 SaveFileDialog 之前）
                var (sprListPath, sprIds) = PrepareLayer8SprPackaging(_document.S32Files.Values, dialog.LayerFlags);

                using (var saveDialog = new SaveFileDialog())
                {
                    saveDialog.Filter = "FS32 地圖包|*.fs32";
                    saveDialog.FileName = $"{_document.MapId}.fs32";

                    if (saveDialog.ShowDialog(this) != DialogResult.Ok)
                        return;

                    try
                    {
                        toolStripStatusLabel1.Text = $"正在匯出地圖...";
                        ApplicationHelper.DoEvents();

                        var fs32 = Fs32Writer.CreateFromMap(_document, dialog.LayerFlags, dialog.IncludeTiles, dialog.StripLayer8Ext);

                        // 共用處理（R版 tile 轉換 + Layer8 SPR 打包）
                        ProcessFs32BeforeSave(fs32, dialog.IncludeTiles, sprListPath, sprIds);

                        Fs32Writer.Write(fs32, saveDialog.FileName);

                        string resultMsg = $"已匯出至 {saveDialog.FileName}\n({fs32.Blocks.Count} 區塊, {fs32.Tiles.Count} 圖塊, {fs32.Sprs.Count} SPR)";
                        toolStripStatusLabel1.Text = resultMsg.Replace("\n", " ");
                        ShowAutoCloseMessage(resultMsg, "匯出完成");
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine($"[Export] Error: {ex}");
                        WinFormsMessageBox.Show($"匯出失敗: {ex.Message}\n\n{ex.StackTrace}", "錯誤", MessageBoxButtons.OK, MessageBoxIcon.Error);
                    }
                }
            }
        }

        // 匯出已勾選的 S32 為 fs32
        private void ExportCheckedS32AsFs32()
        {
            var checkedS32s = new Dictionary<string, S32Data>();
            for (int i = 0; i < lstS32Files.Items.Count; i++)
            {
                if (lstS32Files.GetItemChecked(i) && lstS32Files.Items[i] is S32FileItem item)
                {
                    if (_document.S32Files.TryGetValue(item.FilePath, out var s32Data))
                    {
                        checkedS32s[item.FilePath] = s32Data;
                    }
                }
            }

            if (checkedS32s.Count == 0)
            {
                WinFormsMessageBox.Show("沒有已勾選的 S32 檔案", "提示", MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            using (var dialog = new L1MapViewer.Forms.ExportOptionsDialog(isFs3p: false, hasSelection: true))
            {
                if (dialog.ShowDialog(this) != DialogResult.Ok)
                    return;

                // 檢查異常（匯出不檢查 Tile 上限，若會移除 L8 擴展則不檢查）
                if (!CheckLayer5IssuesAndConfirm(checkedS32s, "匯出", checkTileLimit: false, checkLayer8Extended: !dialog.StripLayer8Ext))
                    return;

                // 預先準備 Layer8 SPR 打包（在 SaveFileDialog 之前）
                var (sprListPath, sprIds) = PrepareLayer8SprPackaging(checkedS32s.Values, dialog.LayerFlags);

                using (var saveDialog = new SaveFileDialog())
                {
                    saveDialog.Filter = "FS32 地圖包|*.fs32";
                    saveDialog.FileName = $"{_document.MapId}_partial.fs32";

                    if (saveDialog.ShowDialog(this) != DialogResult.Ok)
                        return;

                    try
                    {
                        toolStripStatusLabel1.Text = $"正在匯出 {checkedS32s.Count} 個區塊...";
                        ApplicationHelper.DoEvents();

                        var fs32 = Fs32Writer.CreateFromS32List(checkedS32s.Values.ToList(), _document.MapId, dialog.LayerFlags, dialog.IncludeTiles, dialog.StripLayer8Ext);

                        // 共用處理（R版 tile 轉換 + Layer8 SPR 打包）
                        ProcessFs32BeforeSave(fs32, dialog.IncludeTiles, sprListPath, sprIds);

                        Fs32Writer.Write(fs32, saveDialog.FileName);

                        string resultMsg = $"已匯出至 {saveDialog.FileName}\n({fs32.Blocks.Count} 區塊, {fs32.Tiles.Count} 圖塊, {fs32.Sprs.Count} SPR)";
                        toolStripStatusLabel1.Text = resultMsg.Replace("\n", " ");
                        ShowAutoCloseMessage(resultMsg, "匯出完成");
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine($"[Export] Error: {ex}");
                        WinFormsMessageBox.Show($"匯出失敗: {ex.Message}\n\n{ex.StackTrace}", "錯誤", MessageBoxButtons.OK, MessageBoxIcon.Error);
                    }
                }
            }
        }

        // 匯出單一 S32 區塊為 fs32
        private void ExportSingleS32AsFs32(S32Data s32Data)
        {
            if (s32Data == null) return;

            using (var dialog = new L1MapViewer.Forms.ExportOptionsDialog(isFs3p: false, hasSelection: true))
            {
                if (dialog.ShowDialog(this) != DialogResult.Ok)
                    return;

                // 檢查異常
                var singleDict = new Dictionary<string, S32Data> { { s32Data.FilePath, s32Data } };
                if (!CheckLayer5IssuesAndConfirm(singleDict, "匯出", checkTileLimit: false, checkLayer8Extended: !dialog.StripLayer8Ext))
                    return;

                // 預先準備 Layer8 SPR 打包（在 SaveFileDialog 之前）
                var (sprListPath, sprIds) = PrepareLayer8SprPackaging(new[] { s32Data }, dialog.LayerFlags);

                using (var saveDialog = new SaveFileDialog())
                {
                    saveDialog.Filter = "FS32 地圖包|*.fs32";
                    string blockName = $"{s32Data.SegInfo.nBlockX:x4}{s32Data.SegInfo.nBlockY:x4}";
                    saveDialog.FileName = $"{_document.MapId}_{blockName}.fs32";

                    if (saveDialog.ShowDialog(this) != DialogResult.Ok)
                        return;

                    try
                    {
                        toolStripStatusLabel1.Text = "正在匯出區塊...";
                        ApplicationHelper.DoEvents();

                        var fs32 = Fs32Writer.CreateFromS32(s32Data, _document.MapId, dialog.LayerFlags, dialog.IncludeTiles, dialog.StripLayer8Ext);

                        // 使用共用方法處理 R版 tiles 和 Layer8 SPR
                        ProcessFs32BeforeSave(fs32, dialog.IncludeTiles, sprListPath, sprIds);

                        Fs32Writer.Write(fs32, saveDialog.FileName);

                        string resultMsg = $"已匯出至 {saveDialog.FileName}\n({fs32.Blocks.Count} 區塊, {fs32.Tiles.Count} 圖塊, {fs32.Sprs.Count} SPR)";
                        toolStripStatusLabel1.Text = resultMsg.Replace("\n", " ");
                        ShowAutoCloseMessage(resultMsg, "匯出完成");
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine($"[Export] Error: {ex}");
                        WinFormsMessageBox.Show($"匯出失敗: {ex.Message}\n\n{ex.StackTrace}", "錯誤", MessageBoxButtons.OK, MessageBoxIcon.Error);
                    }
                }
            }
        }

        // 匯入 fs32 地圖包到當前地圖
        private void ImportFs32ToCurrentMap()
        {
            if (string.IsNullOrEmpty(_document.MapId))
            {
                WinFormsMessageBox.Show("請先載入地圖", "提示", MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            string mapPath = Path.Combine(Share.LineagePath, "Map", _document.MapId);

            using (var openDialog = new OpenFileDialog())
            {
                openDialog.Filter = "FS32 地圖包|*.fs32|所有檔案|*.*";
                openDialog.Title = "選擇要匯入的 fs32 地圖包";

                if (openDialog.ShowDialog(this) != DialogResult.Ok)
                    return;

                try
                {
                    // 1. 載入 fs32
                    toolStripStatusLabel1.Text = "正在載入 fs32...";
                    ApplicationHelper.DoEvents();

                    var fs32 = Fs32Parser.ParseFile(openDialog.FileName);
                    if (fs32 == null || fs32.Blocks.Count == 0)
                    {
                        WinFormsMessageBox.Show("無效的 fs32 檔案或不包含任何區塊", "錯誤", MessageBoxButtons.OK, MessageBoxIcon.Error);
                        return;
                    }

                    // 2. 統計 Layer8 項目並顯示警告
                    int totalL8Items = 0;
                    HashSet<int> l8SprIds = new HashSet<int>();
                    foreach (var block in fs32.Blocks)
                    {
                        try
                        {
                            var tempS32 = S32Parser.Parse(block.S32Data);
                            if (tempS32?.Layer8 != null)
                            {
                                totalL8Items += tempS32.Layer8.Count;
                                foreach (var l8 in tempS32.Layer8)
                                    l8SprIds.Add(l8.SprId);
                            }
                        }
                        catch { }
                    }

                    if (totalL8Items > 0)
                    {
                        string l8Warning = $"⚠️ 警告：包含 {totalL8Items} 個 Layer8 項目 (使用 {l8SprIds.Count} 種 SPR)\n\n";
                        if (fs32.Sprs.Count > 0)
                        {
                            l8Warning += $"fs32 已包含 {fs32.Sprs.Count} 個 SPR 檔案\n";
                            l8Warning += "• spr/file/*.spr → 匯入至 Client\n";
                            l8Warning += "• spr/code/*.sprtxt → 加入您的 list.spr 編碼檔\n";
                        }
                        else
                        {
                            l8Warning += "fs32 不包含 SPR 檔案\n請自行準備對應的 SPR 編碼檔\n";
                        }
                        l8Warning += "\n否則可能導致遊戲閃退！\n\n確定要繼續匯入嗎？";

                        var l8Result = WinFormsMessageBox.Show(l8Warning, "Layer8 警告",
                            MessageBoxButtons.YesNo, MessageBoxIcon.Warning);
                        if (l8Result != DialogResult.Yes)
                            return;
                    }

                    // 3. 顯示匯入資訊並選擇匯入模式
                    string infoMessage = $"fs32 地圖包資訊：\n\n" +
                                         $"• 來源地圖: {fs32.SourceMapId}\n" +
                                         $"• 區塊數量: {fs32.Blocks.Count}\n" +
                                         $"• 圖塊數量: {fs32.Tiles.Count}\n" +
                                         $"• SPR 數量: {fs32.Sprs.Count}\n\n" +
                                         $"將匯入至當前地圖: {_document.MapId}";

                    var importModeResult = ShowImportModeDialog(infoMessage);

                    if (importModeResult == null)
                        return;

                    bool isFullReplace = importModeResult.Value;

                    // 全部取代需要二次確認
                    if (isFullReplace)
                    {
                        var warningResult = WinFormsMessageBox.Show(
                            "⚠️ 警告：全部取代模式 ⚠️\n\n" +
                            "這將會刪除當前地圖的所有既有區塊！\n" +
                            "整張地圖可能會消失，只剩下匯入的區塊。\n\n" +
                            "此操作無法復原！\n\n" +
                            "確定要繼續嗎？",
                            "危險操作確認",
                            MessageBoxButtons.YesNo,
                            MessageBoxIcon.Warning,
                            MessageBoxDefaultButton.Button2);

                        if (warningResult != DialogResult.Yes)
                            return;
                    }

                    // 3. 處理 Tiles（如果有）
                    TileMappingResult tileMapping = null;
                    if (fs32.Tiles.Count > 0)
                    {
                        tileMapping = ProcessFs32Tiles(fs32);
                        if (tileMapping == null)
                        {
                            // 用戶取消
                            return;
                        }
                    }

                    // 4. 全部取代模式：刪除既有 S32 檔案
                    int deletedCount = 0;
                    if (isFullReplace)
                    {
                        toolStripStatusLabel1.Text = "正在刪除既有區塊...";
                        ApplicationHelper.DoEvents();

                        var existingS32Files = Directory.GetFiles(mapPath, "*.s32");
                        foreach (var file in existingS32Files)
                        {
                            try
                            {
                                File.Delete(file);
                                deletedCount++;
                                Console.WriteLine($"[ImportFs32] Deleted: {Path.GetFileName(file)}");
                            }
                            catch (Exception ex)
                            {
                                Console.WriteLine($"[ImportFs32] Failed to delete {Path.GetFileName(file)}: {ex.Message}");
                            }
                        }
                        Console.WriteLine($"[ImportFs32] Deleted {deletedCount} existing S32 files");
                    }

                    // 5. 解析並寫入 S32 區塊
                    toolStripStatusLabel1.Text = "正在匯入區塊...";
                    ApplicationHelper.DoEvents();

                    int importedCount = 0;
                    int skippedCount = 0;
                    var errors = new List<string>();

                    // 取得 MapInfo（可能為 null，需要從現有 S32 推算）
                    int mapMinBlockX = 0x7FFF;
                    int mapMinBlockY = 0x7FFF;
                    int mapBlockCountX = 1;

                    if (_document.MapInfo != null)
                    {
                        mapMinBlockX = _document.MapInfo.nMinBlockX;
                        mapMinBlockY = _document.MapInfo.nMinBlockY;
                        mapBlockCountX = _document.MapInfo.nBlockCountX;
                    }
                    else if (_document.S32Files.Count > 0)
                    {
                        // 從現有 S32 推算
                        var firstS32 = _document.S32Files.Values.First();
                        if (firstS32.SegInfo != null)
                        {
                            mapMinBlockX = firstS32.SegInfo.nMapMinBlockX;
                            mapMinBlockY = firstS32.SegInfo.nMapMinBlockY;
                            mapBlockCountX = firstS32.SegInfo.nMapBlockCountX;
                        }
                    }

                    Console.WriteLine($"[ImportFs32] MapInfo: MinBlockX={mapMinBlockX:X4}, MinBlockY={mapMinBlockY:X4}, BlockCountX={mapBlockCountX}");

                    foreach (var block in fs32.Blocks)
                    {
                        try
                        {
                            Console.WriteLine($"[ImportFs32] Processing block {block.BlockX:X4}{block.BlockY:X4}, data size={block.S32Data?.Length ?? 0}");

                            // 解析 S32 資料
                            if (block.S32Data == null || block.S32Data.Length == 0)
                            {
                                errors.Add($"區塊 {block.BlockX:X4}{block.BlockY:X4}: 資料為空");
                                skippedCount++;
                                continue;
                            }

                            var s32Data = S32Parser.Parse(block.S32Data);
                            if (s32Data == null)
                            {
                                errors.Add($"區塊 {block.BlockX:X4}{block.BlockY:X4}: 解析失敗");
                                skippedCount++;
                                continue;
                            }

                            Console.WriteLine($"[ImportFs32] Parsed OK: Layer1={s32Data.Layer1 != null}, Layer2={s32Data.Layer2?.Count ?? 0}, Layer4={s32Data.Layer4?.Count ?? 0}");

                            // 設置 SegInfo
                            var segInfo = new Struct.L1MapSeg(block.BlockX, block.BlockY, true);
                            segInfo.nMapMinBlockX = mapMinBlockX;
                            segInfo.nMapMinBlockY = mapMinBlockY;
                            segInfo.nMapBlockCountX = mapBlockCountX;
                            s32Data.SegInfo = segInfo;

                            // 如果有 Tile Mapping，套用到 S32
                            if (tileMapping != null && tileMapping.IdMapping.Count > 0)
                            {
                                ApplyTileMappingToS32(s32Data, tileMapping);
                            }

                            // 寫入 S32 到目標地圖資料夾
                            string s32FileName = $"{block.BlockX:x4}{block.BlockY:x4}.s32";
                            string s32FilePath = Path.Combine(mapPath, s32FileName);

                            Console.WriteLine($"[ImportFs32] Writing to {s32FilePath}");
                            S32Writer.Write(s32Data, s32FilePath);
                            importedCount++;
                            Console.WriteLine($"[ImportFs32] Block {block.BlockX:X4}{block.BlockY:X4} done");
                        }
                        catch (Exception ex)
                        {
                            Console.WriteLine($"[ImportFs32] Error in block {block.BlockX:X4}{block.BlockY:X4}: {ex}");
                            errors.Add($"區塊 {block.BlockX:X4}{block.BlockY:X4}: {ex.Message}");
                            skippedCount++;
                        }
                    }

                    // 6. 顯示結果
                    string resultMessage = $"匯入完成！\n\n" +
                                           $"• 匯入模式: {(isFullReplace ? "全部取代" : "部份取代")}\n";

                    if (isFullReplace && deletedCount > 0)
                    {
                        resultMessage += $"• 已刪除既有區塊: {deletedCount} 個\n";
                    }

                    resultMessage += $"• 成功匯入: {importedCount} 個區塊\n";

                    if (tileMapping != null)
                    {
                        resultMessage += $"• 匯入圖塊: {tileMapping.ImportedCount} 個\n" +
                                         $"• 重用圖塊: {tileMapping.ReuseCount} 個\n" +
                                         $"• 重新編號: {tileMapping.RemappedCount} 個\n";
                    }

                    if (skippedCount > 0)
                    {
                        resultMessage += $"\n跳過 {skippedCount} 個區塊";
                        if (errors.Count > 0 && errors.Count <= 5)
                        {
                            resultMessage += ":\n" + string.Join("\n", errors);
                        }
                    }

                    WinFormsMessageBox.Show(resultMessage, "匯入完成", MessageBoxButtons.OK, MessageBoxIcon.Information);

                    // 7. 重新載入地圖
                    ReloadCurrentMap();
                    toolStripStatusLabel1.Text = $"已匯入 {importedCount} 個區塊";
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"[ImportFs32] Error: {ex}");
                    WinFormsMessageBox.Show($"匯入失敗: {ex.Message}", "錯誤", MessageBoxButtons.OK, MessageBoxIcon.Error);
                }
            }
        }

        // 重疊處理方式列舉
        private enum OverlapHandling
        {
            Overwrite,  // 覆蓋現有區塊
            Skip        // 跳過重疊區塊
        }

        // 在指定位置匯入 fs32
        private void ImportFs32AtPosition(Point worldPos, Struct.L1Map currentMap)
        {
            if (string.IsNullOrEmpty(_document.MapId))
            {
                WinFormsMessageBox.Show("請先載入地圖", "提示", MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            if (_document.S32Files.Count == 0)
            {
                WinFormsMessageBox.Show("請先載入至少一個 S32 區塊以供座標參考", "提示", MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            // 1. 計算目標 Block 座標
            var (targetBlockX, targetBlockY) = EstimateBlockCoordinates(worldPos, currentMap);

            string mapPath = Path.Combine(Share.LineagePath, "Map", _document.MapId);

            using (var openDialog = new OpenFileDialog())
            {
                openDialog.Filter = "FS32 地圖包|*.fs32|所有檔案|*.*";
                openDialog.Title = "選擇要匯入的 fs32 地圖包";

                if (openDialog.ShowDialog(this) != DialogResult.Ok)
                    return;

                try
                {
                    // 2. 載入 fs32
                    toolStripStatusLabel1.Text = "正在載入 fs32...";
                    ApplicationHelper.DoEvents();

                    var fs32 = Fs32Parser.ParseFile(openDialog.FileName);
                    if (fs32 == null || fs32.Blocks.Count == 0)
                    {
                        WinFormsMessageBox.Show("無效的 fs32 檔案或不包含任何區塊", "錯誤", MessageBoxButtons.OK, MessageBoxIcon.Error);
                        return;
                    }

                    // 3. 計算 fs32 的基準點（最小 BlockX/BlockY）
                    var (baseBlockX, baseBlockY) = GetFs32BaseBlock(fs32);

                    // 4. 計算偏移量
                    int offsetX = targetBlockX - baseBlockX;
                    int offsetY = targetBlockY - baseBlockY;

                    Console.WriteLine($"[ImportFs32AtPosition] Target: ({targetBlockX:X4}, {targetBlockY:X4})");
                    Console.WriteLine($"[ImportFs32AtPosition] Base: ({baseBlockX:X4}, {baseBlockY:X4})");
                    Console.WriteLine($"[ImportFs32AtPosition] Offset: ({offsetX}, {offsetY})");

                    // 5. 檢查重疊區塊
                    var overlappingBlocks = FindOverlappingBlocks(fs32, offsetX, offsetY, mapPath);
                    OverlapHandling? overlapHandling = null;

                    if (overlappingBlocks.Count > 0)
                    {
                        overlapHandling = ShowOverlapConflictDialog(overlappingBlocks, offsetX, offsetY);
                        if (overlapHandling == null)
                        {
                            // 使用者取消
                            toolStripStatusLabel1.Text = "已取消匯入";
                            return;
                        }
                    }

                    // 6. 顯示確認對話框
                    string confirmMessage = $"fs32 地圖包資訊：\n\n" +
                                            $"• 來源地圖: {fs32.SourceMapId}\n" +
                                            $"• 區塊數量: {fs32.Blocks.Count}\n" +
                                            $"• 圖塊數量: {fs32.Tiles.Count}\n" +
                                            $"• SPR 數量: {fs32.Sprs.Count}\n\n" +
                                            $"目標位置: ({targetBlockX:X4}, {targetBlockY:X4})\n" +
                                            $"偏移量: ({offsetX}, {offsetY})\n";

                    if (overlappingBlocks.Count > 0)
                    {
                        confirmMessage += $"\n⚠️ 有 {overlappingBlocks.Count} 個重疊區塊將被" +
                                          (overlapHandling == OverlapHandling.Overwrite ? "覆蓋" : "跳過");
                    }

                    confirmMessage += "\n\n確定要匯入嗎？";

                    if (WinFormsMessageBox.Show(confirmMessage, "確認匯入", MessageBoxButtons.YesNo, MessageBoxIcon.Question) != DialogResult.Yes)
                    {
                        toolStripStatusLabel1.Text = "已取消匯入";
                        return;
                    }

                    // 7. 統計 Layer8 項目並顯示警告
                    int totalL8Items = 0;
                    HashSet<int> l8SprIds = new HashSet<int>();
                    foreach (var block in fs32.Blocks)
                    {
                        try
                        {
                            var tempS32 = S32Parser.Parse(block.S32Data);
                            if (tempS32?.Layer8 != null)
                            {
                                totalL8Items += tempS32.Layer8.Count;
                                foreach (var l8 in tempS32.Layer8)
                                    l8SprIds.Add(l8.SprId);
                            }
                        }
                        catch { }
                    }

                    if (totalL8Items > 0)
                    {
                        string l8Warning = $"⚠️ 警告：包含 {totalL8Items} 個 Layer8 項目 (使用 {l8SprIds.Count} 種 SPR)\n\n";
                        if (fs32.Sprs.Count > 0)
                        {
                            l8Warning += $"fs32 已包含 {fs32.Sprs.Count} 個 SPR 檔案\n";
                            l8Warning += "• spr/file/*.spr → 匯入至 Client\n";
                            l8Warning += "• spr/code/*.sprtxt → 加入您的 list.spr 編碼檔\n";
                        }
                        else
                        {
                            l8Warning += "fs32 不包含 SPR 檔案\n請自行準備對應的 SPR 編碼檔\n";
                        }
                        l8Warning += "\n否則可能導致遊戲閃退！\n\n確定要繼續匯入嗎？";

                        var l8Result = WinFormsMessageBox.Show(l8Warning, "Layer8 警告",
                            MessageBoxButtons.YesNo, MessageBoxIcon.Warning);
                        if (l8Result != DialogResult.Yes)
                            return;
                    }

                    // 8. 處理 Tiles（如果有）
                    TileMappingResult tileMapping = null;
                    if (fs32.Tiles.Count > 0)
                    {
                        tileMapping = ProcessFs32Tiles(fs32);
                        if (tileMapping == null)
                        {
                            // 用戶取消
                            return;
                        }
                    }

                    // 9. 取得 MapInfo
                    int mapMinBlockX = 0x7FFF;
                    int mapMinBlockY = 0x7FFF;
                    int mapBlockCountX = 1;

                    if (_document.MapInfo != null)
                    {
                        mapMinBlockX = _document.MapInfo.nMinBlockX;
                        mapMinBlockY = _document.MapInfo.nMinBlockY;
                        mapBlockCountX = _document.MapInfo.nBlockCountX;
                    }
                    else if (_document.S32Files.Count > 0)
                    {
                        var firstS32 = _document.S32Files.Values.First();
                        if (firstS32.SegInfo != null)
                        {
                            mapMinBlockX = firstS32.SegInfo.nMapMinBlockX;
                            mapMinBlockY = firstS32.SegInfo.nMapMinBlockY;
                            mapBlockCountX = firstS32.SegInfo.nMapBlockCountX;
                        }
                    }

                    // 10. 解析並寫入 S32 區塊（帶偏移）
                    toolStripStatusLabel1.Text = "正在匯入區塊...";
                    ApplicationHelper.DoEvents();

                    int importedCount = 0;
                    int skippedCount = 0;
                    var errors = new List<string>();

                    foreach (var block in fs32.Blocks)
                    {
                        try
                        {
                            // 計算新座標
                            int newBlockX = block.BlockX + offsetX;
                            int newBlockY = block.BlockY + offsetY;

                            string s32FileName = $"{newBlockX:x4}{newBlockY:x4}.s32";
                            string s32FilePath = Path.Combine(mapPath, s32FileName);

                            // 檢查重疊
                            bool isOverlapping = File.Exists(s32FilePath) ||
                                _document.S32Files.Keys.Any(k => k.EndsWith(s32FileName, StringComparison.OrdinalIgnoreCase));

                            if (isOverlapping && overlapHandling == OverlapHandling.Skip)
                            {
                                Console.WriteLine($"[ImportFs32AtPosition] Skipping overlapping block {newBlockX:X4}{newBlockY:X4}");
                                skippedCount++;
                                continue;
                            }

                            Console.WriteLine($"[ImportFs32AtPosition] Processing block {block.BlockX:X4}{block.BlockY:X4} -> {newBlockX:X4}{newBlockY:X4}");

                            // 解析 S32 資料
                            if (block.S32Data == null || block.S32Data.Length == 0)
                            {
                                errors.Add($"區塊 {block.BlockX:X4}{block.BlockY:X4}: 資料為空");
                                skippedCount++;
                                continue;
                            }

                            var s32Data = S32Parser.Parse(block.S32Data);
                            if (s32Data == null)
                            {
                                errors.Add($"區塊 {block.BlockX:X4}{block.BlockY:X4}: 解析失敗");
                                skippedCount++;
                                continue;
                            }

                            // 設置 SegInfo（使用新座標）
                            var segInfo = new Struct.L1MapSeg(newBlockX, newBlockY, true);
                            segInfo.nMapMinBlockX = mapMinBlockX;
                            segInfo.nMapMinBlockY = mapMinBlockY;
                            segInfo.nMapBlockCountX = mapBlockCountX;
                            s32Data.SegInfo = segInfo;

                            // 如果有 Tile Mapping，套用到 S32
                            if (tileMapping != null && tileMapping.IdMapping.Count > 0)
                            {
                                ApplyTileMappingToS32(s32Data, tileMapping);
                            }

                            // 寫入 S32
                            Console.WriteLine($"[ImportFs32AtPosition] Writing to {s32FilePath}");
                            S32Writer.Write(s32Data, s32FilePath);
                            importedCount++;
                        }
                        catch (Exception ex)
                        {
                            Console.WriteLine($"[ImportFs32AtPosition] Error in block {block.BlockX:X4}{block.BlockY:X4}: {ex}");
                            errors.Add($"區塊 {block.BlockX:X4}{block.BlockY:X4}: {ex.Message}");
                            skippedCount++;
                        }
                    }

                    // 11. 顯示結果
                    string resultMessage = $"匯入完成！\n\n" +
                                           $"• 目標位置: ({targetBlockX:X4}, {targetBlockY:X4})\n" +
                                           $"• 成功匯入: {importedCount} 個區塊\n";

                    if (tileMapping != null)
                    {
                        resultMessage += $"• 匯入圖塊: {tileMapping.ImportedCount} 個\n" +
                                         $"• 重用圖塊: {tileMapping.ReuseCount} 個\n" +
                                         $"• 重新編號: {tileMapping.RemappedCount} 個\n";
                    }

                    if (skippedCount > 0)
                    {
                        resultMessage += $"\n跳過 {skippedCount} 個區塊";
                        if (errors.Count > 0 && errors.Count <= 5)
                        {
                            resultMessage += ":\n" + string.Join("\n", errors);
                        }
                    }

                    WinFormsMessageBox.Show(resultMessage, "匯入完成", MessageBoxButtons.OK, MessageBoxIcon.Information);

                    // 12. 重新載入地圖
                    ReloadCurrentMap();
                    toolStripStatusLabel1.Text = $"已匯入 {importedCount} 個區塊至 ({targetBlockX:X4}, {targetBlockY:X4})";
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"[ImportFs32AtPosition] Error: {ex}");
                    WinFormsMessageBox.Show($"匯入失敗: {ex.Message}", "錯誤", MessageBoxButtons.OK, MessageBoxIcon.Error);
                }
            }
        }

        // 取得 fs32 的基準點（最小 BlockX/BlockY）
        private (int minBlockX, int minBlockY) GetFs32BaseBlock(Fs32Data fs32)
        {
            int minX = int.MaxValue;
            int minY = int.MaxValue;

            foreach (var block in fs32.Blocks)
            {
                if (block.BlockX < minX) minX = block.BlockX;
                if (block.BlockY < minY) minY = block.BlockY;
            }

            return (minX, minY);
        }

        // 檢查重疊區塊
        private List<Fs32Block> FindOverlappingBlocks(Fs32Data fs32, int offsetX, int offsetY, string mapPath)
        {
            var overlapping = new List<Fs32Block>();

            foreach (var block in fs32.Blocks)
            {
                int newBlockX = block.BlockX + offsetX;
                int newBlockY = block.BlockY + offsetY;
                string fileName = $"{newBlockX:x4}{newBlockY:x4}.s32";
                string filePath = Path.Combine(mapPath, fileName);

                if (File.Exists(filePath) ||
                    _document.S32Files.Keys.Any(k => k.EndsWith(fileName, StringComparison.OrdinalIgnoreCase)))
                {
                    overlapping.Add(block);
                }
            }

            return overlapping;
        }

        // 顯示重疊處理對話框
        private OverlapHandling? ShowOverlapConflictDialog(List<Fs32Block> overlapping, int offsetX, int offsetY)
        {
            using (var dialog = new Form())
            {
                dialog.Text = "區塊重疊警告";
                dialog.Size = new Size(400, 250);
                dialog.SetStartPosition(FormStartPosition.CenterParent);
                dialog.SetFormBorderStyle(FormBorderStyle.FixedDialog);
                dialog.SetMaximizeBox(false);
                dialog.SetMinimizeBox(false);

                var label = new Label
                {
                    Text = $"⚠️ 發現 {overlapping.Count} 個區塊將與現有區塊重疊：\n\n",
                    Location = new Point(20, 20),
                    Size = new Size(350, 40),
                    AutoSize = false
                };
                dialog.GetControls().Add(label);

                // 顯示前幾個重疊的區塊名稱
                string blockList = "";
                int showCount = Math.Min(overlapping.Count, 5);
                for (int i = 0; i < showCount; i++)
                {
                    var block = overlapping[i];
                    int newBlockX = block.BlockX + offsetX;
                    int newBlockY = block.BlockY + offsetY;
                    blockList += $"• {newBlockX:x4}{newBlockY:x4}.s32\n";
                }
                if (overlapping.Count > 5)
                {
                    blockList += $"... 還有 {overlapping.Count - 5} 個\n";
                }

                var listLabel = new Label
                {
                    Text = blockList,
                    Location = new Point(20, 60),
                    Size = new Size(350, 80),
                    AutoSize = false
                };
                dialog.GetControls().Add(listLabel);

                var questionLabel = new Label
                {
                    Text = "請選擇處理方式：",
                    Location = new Point(20, 145),
                    AutoSize = true
                };
                dialog.GetControls().Add(questionLabel);

                OverlapHandling? result = null;

                var overwriteBtn = new Button
                {
                    Text = "覆蓋現有區塊",
                    Location = new Point(20, 170),
                    Size = new Size(110, 30),
                    DialogResult = DialogResult.Ok
                };
                overwriteBtn.Click += (s, e) => { result = OverlapHandling.Overwrite; };
                dialog.GetControls().Add(overwriteBtn);

                var skipBtn = new Button
                {
                    Text = "跳過重疊區塊",
                    Location = new Point(140, 170),
                    Size = new Size(110, 30),
                    DialogResult = DialogResult.Ok
                };
                skipBtn.Click += (s, e) => { result = OverlapHandling.Skip; };
                dialog.GetControls().Add(skipBtn);

                var cancelBtn = new Button
                {
                    Text = "取消",
                    Location = new Point(260, 170),
                    Size = new Size(110, 30),
                    DialogResult = DialogResult.Cancel
                };
                dialog.GetControls().Add(cancelBtn);

                dialog.AcceptButton = overwriteBtn;
                dialog.CancelButton = cancelBtn;

                if (dialog.ShowDialog(this) == DialogResult.Cancel)
                    return null;

                return result;
            }
        }

        // 處理 fs32 中的 Tiles（類似 fs3p 的邏輯）
        private TileMappingResult ProcessFs32Tiles(Fs32Data fs32)
        {
            // 先進行預覽分析
            var previewResult = PreviewTileImport(fs32.Tiles);

            // 如果所有 tiles 都可以重用，靜默處理
            if (previewResult.NeedImportCount == 0 && previewResult.NeedRemapCount == 0)
            {
                return BuildMappingWithoutImport(fs32.Tiles);
            }

            // 需要匯入新 tiles，顯示對話框讓使用者確認
            string message = $"地圖包包含 {fs32.Tiles.Count} 個圖塊：\n\n" +
                             $"• 可重用 (MD5 相符): {previewResult.ReuseCount} 個\n" +
                             $"• 需重新編號 (ID 衝突): {previewResult.NeedRemapCount} 個\n" +
                             $"• 需新增匯入: {previewResult.NeedImportCount} 個\n\n" +
                             $"請輸入新圖塊的起始編號：";

            using (var dialog = new Form())
            {
                dialog.Text = "圖塊匯入設定";
                dialog.Size = new Size(420, 220);
                dialog.SetStartPosition(FormStartPosition.CenterParent);
                dialog.SetFormBorderStyle(FormBorderStyle.FixedDialog);
                dialog.SetMaximizeBox(false);
                dialog.SetMinimizeBox(false);

                var lblMessage = new Label
                {
                    Text = message,
                    Location = new Point(15, 15),
                    Size = new Size(380, 100),
                    AutoSize = false
                };
                dialog.GetControls().Add(lblMessage);

                var lblStartId = new Label
                {
                    Text = "起始編號：",
                    Location = new Point(15, 125),
                    Size = new Size(75, 20)
                };
                dialog.GetControls().Add(lblStartId);

                var txtStartId = new TextBox
                {
                    Text = "10000",
                    Location = new Point(95, 122),
                    Size = new Size(100, 23)
                };
                dialog.GetControls().Add(txtStartId);

                var btnOK = new Button
                {
                    Text = "確定匯入",
                    DialogResult = DialogResult.Ok,
                    Location = new Point(220, 145),
                    Size = new Size(85, 28)
                };
                dialog.GetControls().Add(btnOK);

                var btnCancel = new Button
                {
                    Text = "取消",
                    DialogResult = DialogResult.Cancel,
                    Location = new Point(310, 145),
                    Size = new Size(85, 28)
                };
                dialog.GetControls().Add(btnCancel);

                dialog.AcceptButton = btnOK;
                dialog.CancelButton = btnCancel;

                if (dialog.ShowDialog(this) != DialogResult.Ok)
                    return null;

                if (!int.TryParse(txtStartId.Text, out int startId) || startId < 1)
                {
                    WinFormsMessageBox.Show("請輸入有效的起始編號 (大於 0)", "錯誤", MessageBoxButtons.OK, MessageBoxIcon.Error);
                    return null;
                }

                // 執行實際匯入
                var importer = new TileImportManager { StartSearchId = startId };
                var result = importer.ProcessTilesBatch(fs32.Tiles);

                // 檢查是否有 Tile ID 超過上限
                CheckAndExpandTileLimit(result);

                return result;
            }
        }

        // 將 Tile Mapping 套用到 S32 的各圖層
        private void ApplyTileMappingToS32(S32Data s32Data, TileMappingResult mapping)
        {
            // Layer1
            if (s32Data.Layer1 != null)
            {
                for (int y = 0; y < 64; y++)
                {
                    for (int x = 0; x < 128; x++)
                    {
                        var cell = s32Data.Layer1[y, x];
                        if (cell != null && cell.TileId > 0)
                        {
                            cell.TileId = mapping.GetNewTileId(cell.TileId);
                        }
                    }
                }
            }

            // Layer2
            foreach (var item in s32Data.Layer2)
            {
                if (item.TileId > 0)
                {
                    item.TileId = (ushort)mapping.GetNewTileId(item.TileId);
                }
            }

            // Layer4
            foreach (var obj in s32Data.Layer4)
            {
                if (obj.TileId > 0)
                {
                    obj.TileId = mapping.GetNewTileId(obj.TileId);
                }
            }
        }

        // [JumpToS32Block 已移至 MapForm.Coordinates.cs]

        // 顯示 S32 詳細資料
        private void ShowS32Details(S32FileItem item)
        {
            if (!_document.S32Files.TryGetValue(item.FilePath, out S32Data s32Data))
            {
                WinFormsMessageBox.Show("無法載入 S32 資料", "錯誤", MessageBoxButtons.OK, MessageBoxIcon.Error);
                return;
            }

            // 統計各層資料
            int layer1Count = 0;
            for (int y = 0; y < 64; y++)
            {
                for (int x = 0; x < 128; x++)
                {
                    var cell = s32Data.Layer1[y, x];
                    if (cell != null && cell.TileId > 0)
                        layer1Count++;
                }
            }

            int layer2Count = s32Data.Layer2.Count;

            int layer3Count = 0;
            for (int y = 0; y < 64; y++)
            {
                for (int x = 0; x < 64; x++)
                {
                    var attr = s32Data.Layer3[y, x];
                    if (attr != null && (attr.Attribute1 != 0 || attr.Attribute2 != 0))
                        layer3Count++;
                }
            }

            int layer4Count = s32Data.Layer4.Count;
            int layer4GroupCount = s32Data.Layer4.Select(o => o.GroupId).Distinct().Count();

            int layer5Count = s32Data.Layer5.Count;
            int layer6Count = s32Data.Layer6.Count;
            int layer7Count = s32Data.Layer7.Count;
            int layer8Count = s32Data.Layer8.Count;

            // 建立詳細資訊視窗
            Form detailForm = new Form();
            detailForm.Text = $"S32 詳細資料 - {item.DisplayName}";
            detailForm.Size = new Size(450, 420);
            detailForm.SetFormBorderStyle(FormBorderStyle.FixedDialog);
            detailForm.SetStartPosition(FormStartPosition.CenterParent);
            detailForm.SetMaximizeBox(false);
            detailForm.SetMinimizeBox(false);

            // 檔案資訊
            GroupBox gbFile = new GroupBox { Text = "檔案資訊", Location = new Point(10, 10), Size = new Size(410, 80) };
            gbFile.GetControls().Add(new Label { Text = $"檔案路徑: {item.FilePath}", Location = new Point(10, 20), Size = new Size(390, 20), AutoEllipsis = true });
            gbFile.GetControls().Add(new Label { Text = $"區塊座標: ({item.SegInfo.nBlockX}, {item.SegInfo.nBlockY})", Location = new Point(10, 40), Size = new Size(190, 20) });
            gbFile.GetControls().Add(new Label { Text = $"遊戲座標: ({item.SegInfo.nLinBeginX}~{item.SegInfo.nLinEndX}, {item.SegInfo.nLinBeginY}~{item.SegInfo.nLinEndY})", Location = new Point(200, 40), Size = new Size(200, 20) });
            detailForm.GetControls().Add(gbFile);

            // 各層統計
            GroupBox gbLayers = new GroupBox { Text = "各層資料統計", Location = new Point(10, 100), Size = new Size(410, 230) };

            ListView lvLayers = new ListView();
            lvLayers.SetLocation(new Point(10, 20));
            lvLayers.Size = new Size(390, 200);
            lvLayers.View = View.Details;
            lvLayers.FullRowSelect = true;
            lvLayers.GridLines = true;
            lvLayers.Columns.Add("層級", 80);
            lvLayers.Columns.Add("說明", 150);
            lvLayers.Columns.Add("數量", 80);
            lvLayers.Columns.Add("備註", 70);

            lvLayers.Items.Add(new ListViewItem(new[] { "Layer1", "地板圖塊", layer1Count.ToString(), $"/{64 * 128}" }));
            lvLayers.Items.Add(new ListViewItem(new[] { "Layer2", "第二層資料", layer2Count.ToString(), "" }));
            lvLayers.Items.Add(new ListViewItem(new[] { "Layer3", "地圖屬性", layer3Count.ToString(), $"/{64 * 64}" }));
            lvLayers.Items.Add(new ListViewItem(new[] { "Layer4", "物件", layer4Count.ToString(), $"{layer4GroupCount} 群組" }));
            lvLayers.Items.Add(new ListViewItem(new[] { "Layer5", "事件", layer5Count.ToString(), "" }));
            lvLayers.Items.Add(new ListViewItem(new[] { "Layer6", "使用的 TileId", layer6Count.ToString(), "" }));
            lvLayers.Items.Add(new ListViewItem(new[] { "Layer7", "傳送點", layer7Count.ToString(), "" }));
            lvLayers.Items.Add(new ListViewItem(new[] { "Layer8", "特效", layer8Count.ToString(), s32Data.Layer8HasExtendedData ? "擴展" : "" }));

            gbLayers.GetControls().Add(lvLayers);
            detailForm.GetControls().Add(gbLayers);

            // 按鈕
            Button btnClose = new Button { Text = "關閉", Location = new Point(350, 340), Size = new Size(80, 30) };
            btnClose.Click += (s, args) => detailForm.Close();
            detailForm.GetControls().Add(btnClose);

            Button btnJump = new Button { Text = "跳轉至此", Location = new Point(260, 340), Size = new Size(80, 30) };
            btnJump.Click += (s, args) =>
            {
                JumpToS32Block(item);
                detailForm.Close();
            };
            detailForm.GetControls().Add(btnJump);

            detailForm.ShowDialog(this);
        }

        // S32 清單勾選狀態變更事件
        private void lstS32Files_ItemCheck(object sender, ItemCheckEventArgs e)
        {
            // 更新項目的勾選狀態
            if (lstS32Files.Items[e.Index] is S32FileItem item)
            {
                item.IsChecked = (e.NewValue == CheckState.Checked);

                // 更新勾選檔案快取
                if (e.NewValue == CheckState.Checked)
                    _checkedS32Files.Add(item.FilePath);
                else
                    _checkedS32Files.Remove(item.FilePath);

                // 延遲觸發重新渲染（因為 ItemCheck 在狀態變更前觸發）
                if (!_isBatchCheckUpdate)
                {
                    this.BeginInvoke((MethodInvoker)delegate
                    {
                        SyncCheckedS32FilesToDocument();
                        RenderS32Map();
                        UpdateMiniMap();
                    });
                }
            }
        }

        // 批次勾選更新標記（避免每次勾選都觸發渲染）
        private bool _isBatchCheckUpdate = false;

        // 全選 S32 檔案
        private void btnS32SelectAll_Click(object sender, EventArgs e)
        {
            _isBatchCheckUpdate = true;
            for (int i = 0; i < lstS32Files.Items.Count; i++)
            {
                lstS32Files.SetItemChecked(i, true);
            }
            _isBatchCheckUpdate = false;
            SyncCheckedS32FilesToDocument();
            RenderS32Map();
            UpdateMiniMap();
        }

        // 全不選 S32 檔案
        private void btnS32SelectNone_Click(object sender, EventArgs e)
        {
            _isBatchCheckUpdate = true;
            for (int i = 0; i < lstS32Files.Items.Count; i++)
            {
                lstS32Files.SetItemChecked(i, false);
            }
            _isBatchCheckUpdate = false;
            SyncCheckedS32FilesToDocument();
            RenderS32Map();
            UpdateMiniMap();
        }

        // 純粹的 S32 檔案解析方法（不涉及 UI）
        private S32Data ParseS32File(byte[] data)
        {
            S32Data s32Data = new S32Data();

            // 保存原始文件數據（直接使用，不複製，因為 data 已經是獨立的副本）
            s32Data.OriginalFileData = data;

            using (BinaryReader br = new BinaryReader(new MemoryStream(data)))
            {
                // 記錄第一層偏移
                s32Data.Layer1Offset = (int)br.BaseStream.Position;

                // 第一層（地板）- 64x128
                for (int y = 0; y < 64; y++)
                {
                    for (int x = 0; x < 128; x++)
                    {
                        int id = br.ReadByte();
                        int til = br.ReadUInt16();
                        int nk = br.ReadByte();

                        s32Data.Layer1[y, x] = new TileCell
                        {
                            X = x,
                            Y = y,
                            TileId = til,
                            IndexId = id
                        };

                        // 收集使用的 tile（第一層）
                        if (!s32Data.UsedTiles.ContainsKey(til))
                        {
                            s32Data.UsedTiles[til] = new TileInfo
                            {
                                TileId = til,
                                IndexId = id,
                                UsageCount = 1,
                                Thumbnail = null
                            };
                        }
                        else
                        {
                            s32Data.UsedTiles[til].UsageCount++;
                        }
                    }
                }

                // 記錄第二層偏移
                s32Data.Layer2Offset = (int)br.BaseStream.Position;

                // 第二層
                int layer2Count = br.ReadUInt16();
                for (int i = 0; i < layer2Count; i++)
                {
                    s32Data.Layer2.Add(new Layer2Item
                    {
                        X = br.ReadByte(),
                        Y = br.ReadByte(),
                        IndexId = br.ReadByte(),
                        TileId = br.ReadUInt16(),
                        UK = br.ReadByte()
                    });
                }

                // 記錄第三層偏移
                s32Data.Layer3Offset = (int)br.BaseStream.Position;

                // 第三層（地圖屬性）- 64x64
                for (int y = 0; y < 64; y++)
                {
                    for (int x = 0; x < 64; x++)
                    {
                        s32Data.Layer3[y, x] = new MapAttribute
                        {
                            Attribute1 = br.ReadInt16(),
                            Attribute2 = br.ReadInt16()
                        };
                    }
                }

                // 記錄第四層偏移
                s32Data.Layer4Offset = (int)br.BaseStream.Position;

                // 第四層（物件）
                int layer4GroupCount = br.ReadInt32();
                for (int i = 0; i < layer4GroupCount; i++)
                {
                    int groupId = br.ReadInt16();
                    int blockCount = br.ReadUInt16();

                    for (int j = 0; j < blockCount; j++)
                    {
                        int x = br.ReadByte();
                        int y = br.ReadByte();

                        // 檢查是否為 dummy 資料 (0xCD 0xCD)
                        if (x == 0xCD && y == 0xCD)
                        {
                            // 跳過 5 bytes dummy 資料
                            br.ReadBytes(5);
                            j--;
                            blockCount--;
                            continue;
                        }

                        int layer = br.ReadByte();  // h (圖層高度)
                        uint tileData = br.ReadUInt32();  // tiledata
                        int indexId = (int)(tileData & 0xFF);
                        int tileId = (int)((tileData >> 8) & 0xFFFFFF);

                        var objTile = new ObjectTile
                        {
                            GroupId = groupId,
                            X = x,
                            Y = y,
                            Layer = layer,
                            IndexId = indexId,
                            TileId = tileId
                        };

                        s32Data.Layer4.Add(objTile);

                        // 收集使用的 tile（第四層）
                        if (!s32Data.UsedTiles.ContainsKey(tileId))
                        {
                            s32Data.UsedTiles[tileId] = new TileInfo
                            {
                                TileId = tileId,
                                IndexId = indexId,
                                UsageCount = 1,
                                Thumbnail = null
                            };
                        }
                        else
                        {
                            s32Data.UsedTiles[tileId].UsageCount++;
                        }
                    }
                }

                // 記錄第四層結束位置（後面可能還有第5-8層等未知數據）
                s32Data.Layer4EndOffset = (int)br.BaseStream.Position;

                // 讀取第5-8層的原始資料
                int remainingLength = (int)(br.BaseStream.Length - br.BaseStream.Position);
                if (remainingLength > 0)
                {
                    s32Data.Layer5to8Data = br.ReadBytes(remainingLength);

                    // 解析第5-8層
                    using (var layerStream = new MemoryStream(s32Data.Layer5to8Data))
                    using (var layerReader = new BinaryReader(layerStream))
                    {
                        try
                        {
                            // 第五層 - 事件
                            if (layerStream.Position + 4 <= layerStream.Length)
                            {
                                int lv5Count = layerReader.ReadInt32();
                                for (int i = 0; i < lv5Count && layerStream.Position + 5 <= layerStream.Length; i++)
                                {
                                    s32Data.Layer5.Add(new Layer5Item
                                    {
                                        X = layerReader.ReadByte(),
                                        Y = layerReader.ReadByte(),
                                        ObjectIndex = layerReader.ReadUInt16(),
                                        Type = layerReader.ReadByte()
                                    });
                                }
                            }

                            // 第六層 - 使用的 til
                            if (layerStream.Position + 4 <= layerStream.Length)
                            {
                                int lv6Count = layerReader.ReadInt32();
                                for (int i = 0; i < lv6Count && layerStream.Position + 4 <= layerStream.Length; i++)
                                {
                                    int til = layerReader.ReadInt32();
                                    s32Data.Layer6.Add(til);
                                }
                            }

                            // 第七層 - 傳送點、入口點
                            if (layerStream.Position + 2 <= layerStream.Length)
                            {
                                int lv7Count = layerReader.ReadUInt16();
                                for (int i = 0; i < lv7Count && layerStream.Position + 1 <= layerStream.Length; i++)
                                {
                                    byte len = layerReader.ReadByte();
                                    if (layerStream.Position + len + 8 > layerStream.Length) break;

                                    string name = Encoding.Default.GetString(layerReader.ReadBytes(len));
                                    s32Data.Layer7.Add(new Layer7Item
                                    {
                                        Name = name,
                                        X = layerReader.ReadByte(),
                                        Y = layerReader.ReadByte(),
                                        TargetMapId = layerReader.ReadUInt16(),
                                        PortalId = layerReader.ReadInt32()
                                    });
                                }
                            }

                            // 第八層 - 特效、裝飾品
                            if (layerStream.Position + 2 <= layerStream.Length)
                            {
                                ushort lv8Num = layerReader.ReadUInt16();
                                bool hasExtendedData = (lv8Num >= 0x8000);
                                if (hasExtendedData)
                                {
                                    lv8Num = (ushort)(lv8Num & 0x7FFF);  // 取消高位
                                }
                                s32Data.Layer8HasExtendedData = hasExtendedData;

                                int itemSize = hasExtendedData ? 10 : 6;  // 6 bytes 基本, +4 bytes 擴展
                                for (int i = 0; i < lv8Num && layerStream.Position + itemSize <= layerStream.Length; i++)
                                {
                                    s32Data.Layer8.Add(new Layer8Item
                                    {
                                        SprId = layerReader.ReadUInt16(),
                                        X = layerReader.ReadUInt16(),
                                        Y = layerReader.ReadUInt16(),
                                        ExtendedData = hasExtendedData ? layerReader.ReadInt32() : 0
                                    });
                                }
                            }
                        }
                        catch (EndOfStreamException)
                        {
                            // 忽略讀取超出範圍的錯誤
                        }
                    }
                }
                else
                {
                    s32Data.Layer5to8Data = new byte[0];
                }
            }

            return s32Data;
        }

        // 載入並解析 s32 檔案（帶 UI 更新）
        private void LoadAndParseS32File(string filePath)
        {
            try
            {
                // S32 檔案已經在 LoadS32FileList() 中載入，這裡只更新UI顯示
                if (!_document.S32Files.ContainsKey(filePath))
                {
                    this.toolStripStatusLabel1.Text = "選中的 S32 檔案不在記憶體中";
                    return;
                }

                S32Data s32Data = _document.S32Files[filePath];

                this.toolStripStatusLabel1.Text = $"已選擇 {Path.GetFileName(filePath)} - 第1層:{64*128}格, 第2層:{s32Data.Layer2.Count}項, 第3層:{64*64}格, 第4層:{s32Data.Layer4.Count}物件, 此檔案使用{s32Data.UsedTiles.Count}種Tile";

                // 注意：不需要重新渲染地圖，因為整張地圖已經在顯示了
                // 如果需要高亮顯示當前選中的 S32 區域，可以在這裡添加
            }
            catch (Exception ex)
            {
                WinFormsMessageBox.Show($"顯示 s32 檔案資訊失敗: {ex.Message}", "錯誤", MessageBoxButtons.OK, MessageBoxIcon.Error);
            }
        }

        // 層選擇變更事件
        private void S32Layer_CheckedChanged(object sender, EventArgs e)
        {
            var sw = Stopwatch.StartNew();
            var senderName = (sender as CheckBox)?.Text ?? sender?.GetType().Name ?? "unknown";
            _logger.Debug($"[LAYER] S32Layer_CheckedChanged triggered by: {senderName}");

            // 同步 ViewState
            if (sender == chkShowSafeZones)
            {
                _viewState.ShowSafeZones = chkShowSafeZones.Checked == true;
            }
            else if (sender == chkShowCombatZones)
            {
                _viewState.ShowCombatZones = chkShowCombatZones.Checked == true;
            }

            // 同步到浮動面板的 CheckBox（避免無限遞迴）
            if (sender == chkLayer1 && chkFloatLayer1.Checked != chkLayer1.Checked)
            {
                chkFloatLayer1.Checked = chkLayer1.Checked;
            }
            else if (sender == chkLayer2 && chkFloatLayer2.Checked != chkLayer2.Checked)
            {
                chkFloatLayer2.Checked = chkLayer2.Checked;
            }
            else if (sender == chkLayer4 && chkFloatLayer4.Checked != chkLayer4.Checked)
            {
                chkFloatLayer4.Checked = chkLayer4.Checked;
            }
            else if (sender == chkShowPassable && chkFloatPassable.Checked != chkShowPassable.Checked)
            {
                chkFloatPassable.Checked = chkShowPassable.Checked;
            }
            else if (sender == chkShowGrid && chkFloatGrid.Checked != chkShowGrid.Checked)
            {
                chkFloatGrid.Checked = chkShowGrid.Checked;
            }
            else if (sender == chkShowS32Boundary && chkFloatS32Boundary.Checked != chkShowS32Boundary.Checked)
            {
                chkFloatS32Boundary.Checked = chkShowS32Boundary.Checked;
            }
            else if (sender == chkShowLayer5 && chkFloatLayer5.Checked != chkShowLayer5.Checked)
            {
                chkFloatLayer5.Checked = chkShowLayer5.Checked;
            }
            else if (sender == chkShowSafeZones && chkFloatSafeZones.Checked != chkShowSafeZones.Checked)
            {
                chkFloatSafeZones.Checked = chkShowSafeZones.Checked;
            }
            else if (sender == chkShowCombatZones && chkFloatCombatZones.Checked != chkShowCombatZones.Checked)
            {
                chkFloatCombatZones.Checked = chkShowCombatZones.Checked;
            }

            // 更新圖示顯示狀態
            UpdateLayerIconText();

            // 清除快取（因為快取的 bitmap 是用特定圖層設定渲染的）
            _logger.Debug("[LAYER] Clearing S32 block cache");
            ClearS32BlockCache();

            // 使用防抖Timer，避免快速切換時多次渲染
            _logger.Debug($"[LAYER] Starting debounce timer (interval={renderDebounceTimer.Interval}ms)");
            renderDebounceTimer.Stop();
            renderDebounceTimer.Start();
            _logger.Debug($"[LAYER] S32Layer_CheckedChanged complete in {sw.ElapsedMilliseconds}ms");
        }


        // 浮動圖層面板選項變更
        private void chkFloatLayer_CheckedChanged(object sender, EventArgs e)
        {
            // 同步到原本的 CheckBox（會觸發 S32Layer_CheckedChanged）
            if (sender == chkFloatLayer1)
            {
                chkLayer1.Checked = chkFloatLayer1.Checked;
            }
            else if (sender == chkFloatLayer2)
            {
                chkLayer2.Checked = chkFloatLayer2.Checked;
            }
            else if (sender == chkFloatLayer4)
            {
                chkLayer4.Checked = chkFloatLayer4.Checked;
            }
            else if (sender == chkFloatPassable)
            {
                chkShowPassable.Checked = chkFloatPassable.Checked;
            }
            else if (sender == chkFloatGrid)
            {
                chkShowGrid.Checked = chkFloatGrid.Checked;
            }
            else if (sender == chkFloatS32Boundary)
            {
                chkShowS32Boundary.Checked = chkFloatS32Boundary.Checked;
            }
            else if (sender == chkFloatLayer5)
            {
                chkShowLayer5.Checked = chkFloatLayer5.Checked;
            }
            else if (sender == chkFloatSafeZones)
            {
                chkShowSafeZones.Checked = chkFloatSafeZones.Checked;
            }
            else if (sender == chkFloatCombatZones)
            {
                chkShowCombatZones.Checked = chkFloatCombatZones.Checked;
            }
            else if (sender == chkFloatLayer8Spr)
            {
                // Layer8 SPR 顯示控制
                _viewState.ShowLayer8Spr = chkFloatLayer8Spr.Checked == true;
                // 重新渲染地圖
                RenderS32Map();
            }
            else if (sender == chkFloatLayer8Marker)
            {
                // Layer8 輔助標記顯示控制
                _viewState.ShowLayer8Marker = chkFloatLayer8Marker.Checked == true;
                // 重新渲染地圖
                RenderS32Map();
            }

            // 更新圖示顯示狀態
            UpdateLayerIconText();
        }

        // 更新浮動圖層圖示文字（顯示目前啟用的層）
        private void UpdateLayerIconText()
        {
            // 圖示用不同顏色表示狀態 - 根據啟用層數量
            int enabledCount = 0;
            if (chkFloatLayer1.Checked == true) enabledCount++;
            if (chkFloatLayer2.Checked == true) enabledCount++;
            if (chkFloatLayer4.Checked == true) enabledCount++;
            if (chkFloatPassable.Checked == true) enabledCount++;
            if (chkFloatGrid.Checked == true) enabledCount++;
            if (chkFloatS32Boundary.Checked == true) enabledCount++;
            if (chkFloatLayer5.Checked == true) enabledCount++;
            if (chkFloatSafeZones.Checked == true) enabledCount++;
            if (chkFloatCombatZones.Checked == true) enabledCount++;
            if (chkFloatLayer8Spr.Checked == true) enabledCount++;
            if (chkFloatLayer8Marker.Checked == true) enabledCount++;

            if (enabledCount == 0)
            {
                lblLayerIcon.TextColor = Colors.Gray;
            }
            else if (enabledCount == 11)
            {
                lblLayerIcon.TextColor = Colors.LightGreen;
            }
            else
            {
                lblLayerIcon.TextColor = Colors.Yellow;
            }
        }

        // s32EditorPanel 大小變更時調整浮動面板位置
        private void s32EditorPanel_Resize(object sender, EventArgs e)
        {
            // 將浮動面板放在 s32MapPanel 區域的右上角（相對於 s32EditorPanel）
            int rightMargin = 10;
            int topMargin = 10;
            // s32MapPanel 的起點是 s32LayerControlPanel 下方
            int mapPanelTop = s32MapPanel.Top;
            int mapPanelRight = s32MapPanel.Right;
            layerFloatPanel.SetLocation(new Point(mapPanelRight - layerFloatPanel.Width - rightMargin - 20, mapPanelTop + topMargin));
        }

        // 同步浮動面板與原本 CheckBox 的狀態
        private void SyncFloatPanelCheckboxes()
        {
            chkFloatLayer1.Checked = chkLayer1.Checked;
            chkFloatLayer2.Checked = chkLayer2.Checked;
            chkFloatLayer4.Checked = chkLayer4.Checked;
            chkFloatPassable.Checked = chkShowPassable.Checked;
            chkFloatGrid.Checked = chkShowGrid.Checked;
            chkFloatS32Boundary.Checked = chkShowS32Boundary.Checked;
            chkFloatLayer5.Checked = chkShowLayer5.Checked;
            chkFloatSafeZones.Checked = chkShowSafeZones.Checked;
            chkFloatCombatZones.Checked = chkShowCombatZones.Checked;
            UpdateLayerIconText();
        }

        // 複製設定按鈕點擊事件
        private void btnCopySettings_Click(object sender, EventArgs e)
        {
            using (var dialog = new CopySettingsDialog(copySettingLayer1, copySettingLayer2, copySettingLayer3, copySettingLayer4, copySettingLayer5, copySettingLayer7, copySettingLayer8))
            {
                if (dialog.ShowDialog(this) == DialogResult.Ok)
                {
                    copySettingLayer1 = dialog.CopyLayer1;
                    copySettingLayer2 = dialog.CopyLayer2;
                    copySettingLayer3 = dialog.CopyLayer3;
                    copySettingLayer4 = dialog.CopyLayer4;
                    copySettingLayer5 = dialog.CopyLayer5;
                    copySettingLayer7 = dialog.CopyLayer7;
                    copySettingLayer8 = dialog.CopyLayer8;

                    // 更新按鈕文字顯示目前設定
                    var layers = new List<string>();
                    if (copySettingLayer1) layers.Add("L1");
                    if (copySettingLayer2) layers.Add("L2");
                    if (copySettingLayer3) layers.Add("L3");
                    if (copySettingLayer4) layers.Add("L4");
                    if (copySettingLayer5) layers.Add("L5");
                    if (copySettingLayer7) layers.Add("L7");
                    if (copySettingLayer8) layers.Add("L8");
                    string layerInfo = layers.Count > 0 ? string.Join(",", layers) : "無";

                    this.toolStripStatusLabel1.Text = $"複製/刪除設定已更新: {layerInfo}";
                }
            }
        }

        // 複製地圖座標按鈕點擊事件
        private void btnCopyMapCoords_Click(object sender, EventArgs e)
        {
            if (string.IsNullOrEmpty(_document.MapId) || !Share.MapDataList.ContainsKey(_document.MapId))
            {
                WinFormsMessageBox.Show("請先載入地圖", "提示", MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            Struct.L1Map currentMap = Share.MapDataList[_document.MapId];

            // 取得地圖的遊戲座標範圍
            int startX = currentMap.nLinBeginX;
            int endX = currentMap.nLinEndX;
            int startY = currentMap.nLinBeginY;
            int endY = currentMap.nLinEndY;

            // 格式化為 SQL UPDATE 語句
            string coordText = $"UPDATE mapids SET startX={startX}, endX={endX}, startY={startY}, endY={endY} WHERE mapid = {_document.MapId}";

            // 複製到剪貼簿
            ClipboardHelper.SetText(coordText);

            this.toolStripStatusLabel1.Text = $"已複製: {coordText}";
        }

        // 匯入地圖包按鈕點擊事件
        private void btnImportFs32_Click(object sender, EventArgs e)
        {
            ImportFs32ToCurrentMap();
        }

        // 通行編輯按鈕點擊事件
        private void btnEditPassable_Click(object sender, EventArgs e)
        {
            if (currentPassableEditMode == PassableEditMode.Editing)
            {
                // 取消模式
                currentPassableEditMode = PassableEditMode.None;
                btnEditPassable.BackgroundColor = SystemColors.Control;
                this.toolStripStatusLabel1.Text = "已取消通行編輯模式";
                UpdatePassabilityHelpLabel();
            }
            else
            {
                // 啟用通行編輯模式
                currentPassableEditMode = PassableEditMode.Editing;
                btnEditPassable.BackgroundColor = Colors.LightBlue;
                // 取消 Layer5 編輯模式
                _editState.IsLayer5EditMode = false;
                btnEditLayer5.BackgroundColor = SystemColors.Control;
                UpdateLayer5HelpLabel();
                // 取消區域編輯模式
                currentRegionEditMode = RegionEditMode.None;
                btnRegionEdit.BackgroundColor = SystemColors.Control;
                UpdateRegionHelpLabel();
                // 自動顯示通行性覆蓋層
                EnsurePassabilityLayerVisible();
                this.toolStripStatusLabel1.Text = "通行編輯模式：左鍵選取區域，右鍵設定通行性";
                UpdatePassabilityHelpLabel();
            }
        }

        // 戰鬥區域設置按鈕點擊事件
        private void btnRegionEdit_Click(object sender, EventArgs e)
        {
            if (currentRegionEditMode == RegionEditMode.SetRegion)
            {
                // 取消區域編輯模式
                currentRegionEditMode = RegionEditMode.None;
                btnRegionEdit.BackgroundColor = SystemColors.Control;
                this.toolStripStatusLabel1.Text = "已取消區域設置模式";
                UpdateRegionHelpLabel();
            }
            else
            {
                // 啟用區域編輯模式
                currentRegionEditMode = RegionEditMode.SetRegion;
                btnRegionEdit.BackgroundColor = Colors.LightBlue;
                // 取消其他編輯模式
                currentPassableEditMode = PassableEditMode.None;
                btnEditPassable.BackgroundColor = SystemColors.Control;
                UpdatePassabilityHelpLabel();
                _editState.IsLayer5EditMode = false;
                btnEditLayer5.BackgroundColor = SystemColors.Control;
                UpdateLayer5HelpLabel();
                // 自動顯示區域覆蓋層
                EnsureRegionsLayerVisible();
                this.toolStripStatusLabel1.Text = $"區域設置模式 ({GetRegionTypeName(currentRegionType)})：左鍵拖曳選取，右鍵套用 | 1=一般 2=安全 3=戰鬥";
                UpdateRegionHelpLabel();
            }
        }

        // 確保通行性圖層可見
        private void EnsurePassabilityLayerVisible()
        {
            if (chkShowPassable.Checked != true)
            {
                chkShowPassable.Checked = true;
                chkFloatPassable.Checked = true;
                UpdateLayerIconText();
                RenderS32Map();
            }
        }

        // 確保區域覆蓋層可見
        private void EnsureRegionsLayerVisible()
        {
            bool needRender = false;
            if (chkShowSafeZones.Checked != true)
            {
                chkShowSafeZones.Checked = true;
                chkFloatSafeZones.Checked = true;
                needRender = true;
            }
            if (chkShowCombatZones.Checked != true)
            {
                chkShowCombatZones.Checked = true;
                chkFloatCombatZones.Checked = true;
                needRender = true;
            }
            if (needRender)
            {
                UpdateLayerIconText();
                RenderS32Map();
            }
        }

        // 取得區域類型名稱
        private string GetRegionTypeName(RegionType regionType)
        {
            switch (regionType)
            {
                case RegionType.Normal:
                    return "一般區域";
                case RegionType.Safe:
                    return "安全區域";
                case RegionType.Combat:
                    return "戰鬥區域";
                default:
                    return "未知";
            }
        }

        // 取得區域類型顏色
        private Color GetRegionTypeColor(RegionType regionType)
        {
            switch (regionType)
            {
                case RegionType.Normal:
                    return Colors.LightGreen;
                case RegionType.Safe:
                    return Colors.LightBlue;
                case RegionType.Combat:
                    return Colors.Orange;
                default:
                    return Colors.Gray;
            }
        }

        // 檢測格子的區域類型
        private RegionType GetCellRegionType(S32Data s32Data, int cellX, int cellY)
        {
            // 計算第三層座標
            int layer3X = cellX / 2;
            if (layer3X >= 64) layer3X = 63;

            if (s32Data.Layer3[cellY, layer3X] == null)
                return RegionType.Normal;

            var attr = s32Data.Layer3[cellY, layer3X];

            // 根據 MapTool 邏輯檢查區域類型
            // 低4位: 0-3=一般, 4-7/C-F=安全(bit2), 8-B=戰鬥(bit3且非bit2)
            int val1 = attr.Attribute1 & 0x0F;
            int val2 = attr.Attribute2 & 0x0F;

            bool isSafe = (val1 & 0x04) != 0 || (val2 & 0x04) != 0;
            bool isCombat = (val1 & 0x0C) == 0x08 || (val2 & 0x0C) == 0x08;

            if (isCombat) return RegionType.Combat;
            if (isSafe) return RegionType.Safe;
            return RegionType.Normal;
        }

        // 設定格子的區域類型
        private void SetCellRegionType(S32Data s32Data, int cellX, int cellY, RegionType regionType)
        {
            // 計算第三層座標
            int layer3X = cellX / 2;
            if (layer3X >= 64) layer3X = 63;

            // 計算遊戲座標
            int gameX = s32Data.SegInfo.nLinBeginX + layer3X;
            int gameY = s32Data.SegInfo.nLinBeginY + cellY;

            // 確保屬性存在
            if (s32Data.Layer3[cellY, layer3X] == null)
            {
                s32Data.Layer3[cellY, layer3X] = new MapAttribute { Attribute1 = 0, Attribute2 = 0 };
            }

            var attr = s32Data.Layer3[cellY, layer3X];

            // 先清除現有的區域標記（根據 MapTool 邏輯，清除 bit 2 和 bit 3）
            attr.Attribute1 = (short)(attr.Attribute1 & ~0x0C); // 清除 0x04 和 0x08 位元
            attr.Attribute2 = (short)(attr.Attribute2 & ~0x0C); // 清除 0x04 和 0x08 位元

            // 根據區域類型設定標記（MapTool 邏輯）
            switch (regionType)
            {
                case RegionType.Safe:
                    attr.Attribute1 = (short)(attr.Attribute1 | 0x04); // 設定 bit 2 = 安全區域
                    attr.Attribute2 = (short)(attr.Attribute2 | 0x04);
                    this.toolStripStatusLabel1.Text = $"已設定 ({gameX},{gameY}) 為安全區域";
                    break;
                case RegionType.Combat:
                    attr.Attribute1 = (short)(attr.Attribute1 | 0x08); // 設定 bit 3 = 戰鬥區域
                    attr.Attribute2 = (short)(attr.Attribute2 | 0x08);
                    this.toolStripStatusLabel1.Text = $"已設定 ({gameX},{gameY}) 為戰鬥區域";
                    break;
                case RegionType.Normal:
                default:
                    // 一般區域不需要特殊標記（已在上面清除）
                    this.toolStripStatusLabel1.Text = $"已設定 ({gameX},{gameY}) 為一般區域";
                    break;
            }

            s32Data.IsModified = true;
            ClearS32BlockCache();
            RenderS32Map();
        }

        // 批量設定選取區域的區域類型
        private void SetSelectedCellsRegionType(RegionType regionType)
        {
            if (_editState.SelectedCells.Count == 0) return;

            int count = 0;
            HashSet<S32Data> modifiedS32s = new HashSet<S32Data>();

            // 建立 Undo 記錄
            var undoAction = new UndoAction
            {
                Description = $"設定 {_editState.SelectedCells.Count} 個格子為{GetRegionTypeName(regionType)}"
            };

            foreach (var cell in _editState.SelectedCells)
            {
                if (cell.S32Data == null) continue;

                int layer3X = cell.LocalX / 2;
                if (layer3X >= 64) layer3X = 63;

                // 確保座標在有效範圍內
                if (cell.LocalY < 0 || cell.LocalY >= 64) continue;

                // 確保屬性存在
                if (cell.S32Data.Layer3[cell.LocalY, layer3X] == null)
                {
                    cell.S32Data.Layer3[cell.LocalY, layer3X] = new MapAttribute { Attribute1 = 0, Attribute2 = 0 };
                }

                var attr = cell.S32Data.Layer3[cell.LocalY, layer3X];

                // 記錄舊值
                short oldAttr1 = attr.Attribute1;
                short oldAttr2 = attr.Attribute2;

                // 清除現有的區域標記（MapTool 邏輯）
                attr.Attribute1 = (short)(attr.Attribute1 & ~0x0C);
                attr.Attribute2 = (short)(attr.Attribute2 & ~0x0C);

                // 設定新的區域標記（MapTool 邏輯）
                switch (regionType)
                {
                    case RegionType.Safe:
                        attr.Attribute1 = (short)(attr.Attribute1 | 0x04);
                        attr.Attribute2 = (short)(attr.Attribute2 | 0x04);
                        break;
                    case RegionType.Combat:
                        attr.Attribute1 = (short)(attr.Attribute1 | 0x08);
                        attr.Attribute2 = (short)(attr.Attribute2 | 0x08);
                        break;
                }

                // 記錄到 Undo
                undoAction.ModifiedLayer3.Add(new UndoLayer3Info
                {
                    S32FilePath = cell.S32Data.FilePath,
                    LocalX = layer3X,
                    LocalY = cell.LocalY,
                    OldAttribute1 = oldAttr1,
                    OldAttribute2 = oldAttr2,
                    NewAttribute1 = attr.Attribute1,
                    NewAttribute2 = attr.Attribute2
                });

                cell.S32Data.IsModified = true;
                modifiedS32s.Add(cell.S32Data);
                count++;
            }

            // 儲存 Undo 記錄
            if (undoAction.ModifiedLayer3.Count > 0)
            {
                PushUndoAction(undoAction);
            }

            this.toolStripStatusLabel1.Text = $"已將 {count} 個格子設定為{GetRegionTypeName(regionType)} (Ctrl+Z 可還原)";

            // 清除選取區域
            _editState.SelectedCells.Clear();

            ClearS32BlockCache();
            RenderS32Map();
        }

        // 透明編輯按鈕點擊事件
        private void btnEditLayer5_Click(object sender, EventArgs e)
        {
            _logger.Debug($"[Layer5Edit] btnEditLayer5_Click: current IsLayer5EditMode={_editState.IsLayer5EditMode}");
            if (_editState.IsLayer5EditMode)
            {
                // 取消模式
                _editState.IsLayer5EditMode = false;
                btnEditLayer5.BackgroundColor = SystemColors.Control;
                this.toolStripStatusLabel1.Text = "已取消透明編輯模式";
                UpdateLayer5HelpLabel();
                _logger.Debug("[Layer5Edit] Disabled, calling RenderS32Map");
                RenderS32Map();  // 重新渲染以移除群組覆蓋層
            }
            else
            {
                // 啟用透明編輯模式
                _editState.IsLayer5EditMode = true;
                btnEditLayer5.BackgroundColor = Color.FromArgb(100, 180, 255);
                // 取消通行性編輯模式
                currentPassableEditMode = PassableEditMode.None;
                btnEditPassable.BackgroundColor = SystemColors.Control;
                UpdatePassabilityHelpLabel();
                // 自動顯示 Layer5 覆蓋層
                _logger.Debug("[Layer5Edit] Enabled, calling EnsureLayer5Visible");
                EnsureLayer5Visible();
                this.toolStripStatusLabel1.Text = "透明編輯模式：左鍵添加/右鍵刪除透明設定";
                UpdateLayer5HelpLabel();
                _logger.Debug("[Layer5Edit] Calling RenderS32Map");
                RenderS32Map();  // 重新渲染以顯示群組覆蓋層
            }
            _logger.Debug($"[Layer5Edit] btnEditLayer5_Click done: IsLayer5EditMode={_editState.IsLayer5EditMode}");
        }

        // 確保 Layer5 圖層可見
        private void EnsureLayer5Visible()
        {
            if (chkShowLayer5.Checked != true)
            {
                chkShowLayer5.Checked = true;
                chkFloatLayer5.Checked = true;
                UpdateLayerIconText();
                // 不需要在這裡呼叫 RenderS32Map，因為：
                // 1. chkShowLayer5.Checked 會觸發 S32Layer_CheckedChanged，它會啟動 debounce timer
                // 2. btnEditLayer5_Click 最後會呼叫 RenderS32Map
                // 移除多餘呼叫以避免多個渲染任務競爭
            }
        }

        // 更新 Layer5 編輯操作說明標籤
        private void UpdateLayer5HelpLabel()
        {
            _logger.Debug("[UpdateLayer5HelpLabel] Start");
            try
            {
                // lblLayer5Help 現在在表單初始化時已創建，不需要動態創建

                if (!_editState.IsLayer5EditMode)
                {
                    _logger.Debug("[UpdateLayer5HelpLabel] Not in edit mode, hiding");
                    lblLayer5Help.Visible = false;
                    UpdateDefaultHintVisibility();
                    return;
                }

                _logger.Debug("[UpdateLayer5HelpLabel] Setting text and location");
                lblLayer5Help.Text = "【透明編輯模式】\n" +
                                     "• 左鍵：選取地圖格子\n" +
                                     "• 查看右側【附近群組】\n" +
                                     "• 右鍵：設定半透明/消失\n" +
                                     "  紫色 = 半透明區塊\n" +
                                     "  紅色 = 消失區塊\n" +
                                     "• 再按按鈕：取消模式";
                lblLayer5Help.SetLocation(new Point(10, 10));

                _logger.Debug("[UpdateLayer5HelpLabel] Setting Visible = true");
                lblLayer5Help.Visible = true;
                lblLayer5Help.BringToFront();

                lblDefaultHint.Visible = false;
                _logger.Debug("[UpdateLayer5HelpLabel] Done");
            }
            catch (Exception ex)
            {
                _logger.Error(ex, "[UpdateLayer5HelpLabel] Exception occurred");
            }
        }

        // 更新通行性編輯操作說明標籤
        private void UpdatePassabilityHelpLabel()
        {
            if (currentPassableEditMode == PassableEditMode.None)
            {
                lblPassabilityHelp.Visible = false;
                UpdateDefaultHintVisibility();
                return;
            }

            lblPassabilityHelp.Text = "【通行編輯模式】\n" +
                                      "• 左鍵拖曳選取區域\n" +
                                      "• 右鍵：設定通行性\n" +
                                      "  - 左上 可/不可通行\n" +
                                      "  - 右上 可/不可通行\n" +
                                      "  - 整格 可/不可通行\n" +
                                      "• 再按按鈕：取消模式";
            lblPassabilityHelp.TextColor = Colors.LightBlue;
            lblPassabilityHelp.Visible = true;
            lblPassabilityHelp.BringToFront();
            lblDefaultHint.Visible = false;
        }

        // 通行性設定目標
        private enum PassabilityTarget
        {
            LeftTop,     // 只設定 Attr1 (左上)
            RightTop,    // 只設定 Attr2 (右上)
            LeftBottom,  // 只設定左下（實際是左下格子的 Attr2）
            RightBottom, // 只設定右下（實際是右下格子的 Attr1）
            All          // 設定整格（全部四個邊）
        }

        // 批次設定選取區域的通行性
        private void SetSelectedCellsPassability(PassabilityTarget target, bool passable)
        {
            if (_editState.SelectedCells.Count == 0) return;

            _logger.Debug($"[Passability] SetSelectedCellsPassability: target={target}, passable={passable}, cellCount={_editState.SelectedCells.Count}");

            // 記錄選取區域的範圍（用於診斷）
            if (_editState.SelectedCells.Count > 0)
            {
                var gameCoords = _editState.SelectedCells
                    .Where(c => c.S32Data != null)
                    .Select(c => {
                        int l3x = c.LocalX / 2;
                        int l3y = c.LocalY;
                        return (
                            gameX: c.S32Data.SegInfo.nLinBeginX + l3x,
                            gameY: c.S32Data.SegInfo.nLinBeginY + l3y,
                            s32: Path.GetFileName(c.S32Data.FilePath),
                            localX: c.LocalX,
                            localY: c.LocalY,
                            layer3X: l3x,
                            layer3Y: l3y
                        );
                    }).ToList();

                int minGameX = gameCoords.Min(c => c.gameX);
                int maxGameX = gameCoords.Max(c => c.gameX);
                int minGameY = gameCoords.Min(c => c.gameY);
                int maxGameY = gameCoords.Max(c => c.gameY);

                _logger.Info($"[Passability] ========== 選取區域摘要 ==========");
                _logger.Info($"[Passability] 遊戲座標範圍: X=[{minGameX}~{maxGameX}], Y=[{minGameY}~{maxGameY}]");
                _logger.Info($"[Passability] 預期格子數: {(maxGameX - minGameX + 1) * (maxGameY - minGameY + 1)}");
                _logger.Info($"[Passability] 實際選取格子數: {gameCoords.Count}");

                // 按 S32 分組統計
                var byS32 = gameCoords.GroupBy(c => c.s32).OrderBy(g => g.Key);
                foreach (var grp in byS32)
                {
                    var minL3X = grp.Min(c => c.layer3X);
                    var maxL3X = grp.Max(c => c.layer3X);
                    var minL3Y = grp.Min(c => c.layer3Y);
                    var maxL3Y = grp.Max(c => c.layer3Y);
                    var outOfRange = grp.Count(c => c.layer3X >= 64 || c.layer3Y >= 64);
                    _logger.Info($"[Passability] {grp.Key}: {grp.Count()} 格, Layer3=({minL3X}~{maxL3X}, {minL3Y}~{maxL3Y}), 超出範圍={outOfRange}");
                }
                _logger.Info($"[Passability] =====================================");
            }

            int modifiedCount = 0;
            HashSet<S32Data> modifiedS32s = new HashSet<S32Data>();
            // 追蹤已處理的 Layer3 座標，避免重複設定
            var processedCoords = new HashSet<(string s32Path, int layer3X, int layer3Y)>();
            // Undo 記錄：key = (s32Path, layer3X, layer3Y), value = (oldAttr1, oldAttr2, newAttr1, newAttr2)
            var undoRecords = new Dictionary<(string, int, int), (short oldAttr1, short oldAttr2, short newAttr1, short newAttr2)>();

            // 輔助函數：記錄修改前的值（如果尚未記錄）
            void RecordOldValue(S32Data s32, int layer3X, int layer3Y)
            {
                if (layer3X < 0 || layer3X >= 64 || layer3Y < 0 || layer3Y >= 64) return;
                var key = (s32.FilePath, layer3X, layer3Y);
                if (!undoRecords.ContainsKey(key))
                {
                    var attr = s32.Layer3[layer3Y, layer3X];
                    short oldAttr1 = attr?.Attribute1 ?? 0;
                    short oldAttr2 = attr?.Attribute2 ?? 0;
                    undoRecords[key] = (oldAttr1, oldAttr2, oldAttr1, oldAttr2); // 初始時 new = old
                }
            }

            // 輔助函數：記錄修改後的值
            void RecordNewValue(S32Data s32, int layer3X, int layer3Y)
            {
                if (layer3X < 0 || layer3X >= 64 || layer3Y < 0 || layer3Y >= 64) return;
                var key = (s32.FilePath, layer3X, layer3Y);
                if (undoRecords.ContainsKey(key))
                {
                    var attr = s32.Layer3[layer3Y, layer3X];
                    var record = undoRecords[key];
                    undoRecords[key] = (record.oldAttr1, record.oldAttr2, attr?.Attribute1 ?? 0, attr?.Attribute2 ?? 0);
                }
            }

            // 輔助函數：設定單一格子的屬性
            void SetPassabilityBit(S32Data s32, int layer3X, int layer3Y, bool isAttr1, bool pass)
            {
                _logger.Debug($"[Passability] SetPassabilityBit: s32={Path.GetFileName(s32.FilePath)}, layer3=({layer3X},{layer3Y}), isAttr1={isAttr1}, pass={pass}");
                if (layer3X < 0 || layer3X >= 64 || layer3Y < 0 || layer3Y >= 64)
                {
                    _logger.Debug($"[Passability] SetPassabilityBit: OUT OF RANGE, skipping");
                    return;
                }
                // 記錄修改前的值
                RecordOldValue(s32, layer3X, layer3Y);

                if (s32.Layer3[layer3Y, layer3X] == null)
                {
                    _logger.Debug($"[Passability] SetPassabilityBit: Creating new MapAttribute");
                    s32.Layer3[layer3Y, layer3X] = new MapAttribute { Attribute1 = 0, Attribute2 = 0 };
                }
                var attr = s32.Layer3[layer3Y, layer3X];
                short oldValue = isAttr1 ? attr.Attribute1 : attr.Attribute2;
                if (isAttr1)
                {
                    attr.Attribute1 = pass ? (short)(attr.Attribute1 & ~0x01) : (short)(attr.Attribute1 | 0x01);
                }
                else
                {
                    attr.Attribute2 = pass ? (short)(attr.Attribute2 & ~0x01) : (short)(attr.Attribute2 | 0x01);
                }
                short newValue = isAttr1 ? attr.Attribute1 : attr.Attribute2;
                _logger.Debug($"[Passability] SetPassabilityBit: {(isAttr1 ? "Attr1" : "Attr2")} changed from {oldValue} to {newValue}");

                // 記錄修改後的值
                RecordNewValue(s32, layer3X, layer3Y);
                modifiedS32s.Add(s32);
            }

            // 輔助函數：查找鄰近格子的 S32（可能跨 S32 邊界）
            S32Data FindNeighborS32(S32Data currentS32, int gameX, int gameY)
            {
                // 檢查是否在當前 S32 範圍內
                if (gameX >= currentS32.SegInfo.nLinBeginX && gameX < currentS32.SegInfo.nLinBeginX + 64 &&
                    gameY >= currentS32.SegInfo.nLinBeginY && gameY < currentS32.SegInfo.nLinBeginY + 64)
                {
                    return currentS32;
                }
                // 查找其他 S32
                foreach (var s32 in _document.S32Files.Values)
                {
                    if (gameX >= s32.SegInfo.nLinBeginX && gameX < s32.SegInfo.nLinBeginX + 64 &&
                        gameY >= s32.SegInfo.nLinBeginY && gameY < s32.SegInfo.nLinBeginY + 64)
                    {
                        return s32;
                    }
                }
                return null;
            }

            foreach (var cell in _editState.SelectedCells)
            {
                // 使用 SelectedCell 的 GetLayer3Info 方法取得正確的 S32 和本地座標
                var layer3Info = cell.GetLayer3Info(_document.S32Files);
                if (layer3Info == null)
                {
                    _logger.Debug($"[Passability] No S32 found for cell LocalX={cell.LocalX}, LocalY={cell.LocalY}, skipping");
                    continue;
                }

                int gameX = layer3Info.GameX;
                int gameY = layer3Info.GameY;
                var targetS32 = layer3Info.S32Data;
                int targetLocalX = layer3Info.LocalX;
                int targetLocalY = layer3Info.LocalY;

                _logger.Debug($"[Passability] Processing cell: LocalX={cell.LocalX}, LocalY={cell.LocalY}, gameX={gameX}, gameY={gameY}, targetS32={Path.GetFileName(targetS32.FilePath)}, targetLocal=({targetLocalX},{targetLocalY})");

                // 跳過已處理的遊戲座標（避免重複處理同一個格子）
                // 使用遊戲座標而非本地座標，因為跨 S32 邊界時同一個遊戲座標可能來自不同的本地座標
                var coordKey = ("game", gameX, gameY);
                if (processedCoords.Contains(coordKey))
                {
                    _logger.Debug($"[Passability] Skipping duplicate game coord: ({gameX},{gameY})");
                    continue;
                }
                processedCoords.Add(coordKey);

                // 根據目標設定對應的屬性
                if (target == PassabilityTarget.LeftTop || target == PassabilityTarget.All)
                {
                    _logger.Debug($"[Passability] Setting LeftTop (Attr1) for ({targetLocalX},{targetLocalY})");
                    SetPassabilityBit(targetS32, targetLocalX, targetLocalY, true, passable);
                }

                if (target == PassabilityTarget.RightTop || target == PassabilityTarget.All)
                {
                    SetPassabilityBit(targetS32, targetLocalX, targetLocalY, false, passable);
                }

                // 左下：設定 (gameX-1, gameY) 的 Attr2（左邊格子的右上）
                if (target == PassabilityTarget.LeftBottom || target == PassabilityTarget.All)
                {
                    _logger.Debug($"[Passability] LeftBottom: looking for neighbor at game({gameX - 1},{gameY})");
                    var neighborS32 = FindNeighborS32(cell.S32Data, gameX - 1, gameY);
                    if (neighborS32 != null)
                    {
                        int neighborLocalX = gameX - 1 - neighborS32.SegInfo.nLinBeginX;
                        int neighborLocalY = gameY - neighborS32.SegInfo.nLinBeginY;
                        _logger.Debug($"[Passability] LeftBottom: found neighbor in {Path.GetFileName(neighborS32.FilePath)}, local=({neighborLocalX},{neighborLocalY})");
                        SetPassabilityBit(neighborS32, neighborLocalX, neighborLocalY, false, passable);
                    }
                    else
                    {
                        _logger.Debug($"[Passability] LeftBottom: NO neighbor found for game({gameX - 1},{gameY})");
                    }
                }

                // 右下：設定 (gameX, gameY+1) 的 Attr1（下方格子的左上）
                if (target == PassabilityTarget.RightBottom || target == PassabilityTarget.All)
                {
                    _logger.Debug($"[Passability] RightBottom: looking for neighbor at game({gameX},{gameY + 1})");
                    var neighborS32 = FindNeighborS32(cell.S32Data, gameX, gameY + 1);
                    if (neighborS32 != null)
                    {
                        int neighborLocalX = gameX - neighborS32.SegInfo.nLinBeginX;
                        int neighborLocalY = gameY + 1 - neighborS32.SegInfo.nLinBeginY;
                        _logger.Debug($"[Passability] RightBottom: found neighbor in {Path.GetFileName(neighborS32.FilePath)}, local=({neighborLocalX},{neighborLocalY})");
                        SetPassabilityBit(neighborS32, neighborLocalX, neighborLocalY, true, passable);
                    }
                    else
                    {
                        _logger.Debug($"[Passability] RightBottom: NO neighbor found for game({gameX},{gameY + 1})");
                    }
                }

                modifiedCount++;
            }

            // 標記所有修改過的 S32 為已修改
            foreach (var s32 in modifiedS32s)
            {
                s32.IsModified = true;
            }

            // 記錄實際處理結果摘要
            _logger.Info($"[Passability] ========== 處理結果摘要 ==========");
            _logger.Info($"[Passability] 實際處理格子數: {modifiedCount}");
            _logger.Info($"[Passability] 處理過的座標數: {processedCoords.Count}");
            _logger.Info($"[Passability] 修改過的 S32 數: {modifiedS32s.Count}");
            foreach (var s32 in modifiedS32s)
            {
                _logger.Info($"[Passability] 修改的 S32: {Path.GetFileName(s32.FilePath)}");
            }
            _logger.Info($"[Passability] =====================================");

            // 建立 Undo 記錄（只有實際有修改的才記錄）
            var actualChanges = undoRecords.Where(kvp =>
                kvp.Value.oldAttr1 != kvp.Value.newAttr1 ||
                kvp.Value.oldAttr2 != kvp.Value.newAttr2).ToList();

            if (actualChanges.Count > 0)
            {
                string targetName = target switch
                {
                    PassabilityTarget.LeftTop => "左上",
                    PassabilityTarget.RightTop => "右上",
                    PassabilityTarget.LeftBottom => "左下",
                    PassabilityTarget.RightBottom => "右下",
                    PassabilityTarget.All => "整格",
                    _ => ""
                };
                string passableText = passable ? "可通行" : "不可通行";

                var undoAction = new UndoAction
                {
                    Description = $"設定 {actualChanges.Count} 格 {targetName} {passableText}"
                };

                foreach (var kvp in actualChanges)
                {
                    undoAction.ModifiedLayer3.Add(new UndoLayer3Info
                    {
                        S32FilePath = kvp.Key.Item1,
                        LocalX = kvp.Key.Item2,
                        LocalY = kvp.Key.Item3,
                        OldAttribute1 = kvp.Value.oldAttr1,
                        OldAttribute2 = kvp.Value.oldAttr2,
                        NewAttribute1 = kvp.Value.newAttr1,
                        NewAttribute2 = kvp.Value.newAttr2
                    });
                }

                PushUndoAction(undoAction);
                _logger.Debug($"[Passability] Created undo action with {actualChanges.Count} changes");
            }

            // 重繪（保留選取狀態）
            ClearS32BlockCache();
            RenderS32Map();

            // 顯示結果
            string targetNameResult = target switch
            {
                PassabilityTarget.LeftTop => "左上",
                PassabilityTarget.RightTop => "右上",
                PassabilityTarget.LeftBottom => "左下",
                PassabilityTarget.RightBottom => "右下",
                PassabilityTarget.All => "整格",
                _ => ""
            };
            string passableTextResult = passable ? "可通行" : "不可通行";
            this.toolStripStatusLabel1.Text = $"已設定 {modifiedCount} 格的 {targetNameResult} 為{passableTextResult} (Ctrl+Z 可還原)";
        }

        // 更新區域編輯操作說明標籤
        private void UpdateRegionHelpLabel()
        {
            if (currentRegionEditMode == RegionEditMode.None)
            {
                lblRegionHelp.Visible = false;
                btnRegionNormal.Visible = false;
                btnRegionSafe.Visible = false;
                btnRegionCombat.Visible = false;
                UpdateDefaultHintVisibility();
                return;
            }

            string regionTypeName = GetRegionTypeName(currentRegionType);
            Color regionColor = GetRegionTypeColor(currentRegionType);

            lblRegionHelp.Text = $"【區域設置模式】\n" +
                                 "• 左鍵拖曳選取，右鍵套用\n" +
                                 "• 再按按鈕：取消模式";
            lblRegionHelp.TextColor = regionColor;
            lblRegionHelp.Visible = true;
            lblRegionHelp.BringToFront();
            lblDefaultHint.Visible = false;

            // 顯示區域類型按鈕並更新狀態
            btnRegionNormal.Visible = true;
            btnRegionSafe.Visible = true;
            btnRegionCombat.Visible = true;
            btnRegionNormal.BringToFront();
            btnRegionSafe.BringToFront();
            btnRegionCombat.BringToFront();

            // 高亮當前選中的類型
            btnRegionNormal.BackgroundColor = currentRegionType == RegionType.Normal ? Colors.White : Color.FromArgb(80, 80, 80);
            btnRegionSafe.BackgroundColor = currentRegionType == RegionType.Safe ? Color.FromArgb(0, 150, 255) : Color.FromArgb(60, 60, 80);
            btnRegionCombat.BackgroundColor = currentRegionType == RegionType.Combat ? Color.FromArgb(180, 0, 255) : Color.FromArgb(70, 50, 80);

            btnRegionNormal.TextColor = currentRegionType == RegionType.Normal ? Colors.Black : Colors.White;
            btnRegionSafe.TextColor = Colors.White;
            btnRegionCombat.TextColor = Colors.White;
        }

        // 更新預設操作提示的顯示狀態
        private void UpdateDefaultHintVisibility()
        {
            // 如果沒有任何編輯模式啟動，顯示預設提示
            bool anyModeActive = currentPassableEditMode != PassableEditMode.None ||
                                 currentRegionEditMode != RegionEditMode.None ||
                                 _editState.IsLayer5EditMode ||
                                 _pendingMaterial != null;  // 素材貼上模式

            lblDefaultHint.Visible = !anyModeActive;
            if (lblDefaultHint.Visible)
            {
                lblDefaultHint.BringToFront();
            }
        }

        // 重新載入按鈕點擊事件
        private void btnReloadMap_Click(object sender, EventArgs e)
        {
            ReloadCurrentMap();
        }

        // 渲染 S32 地圖（Viewport 渲染 - 只渲染可見區域）
        private void RenderS32Map()
        {
            var totalSw = Stopwatch.StartNew();
            _logger.Debug("[RENDER] RenderS32Map called");
            try
            {
                if (_document.S32Files.Count == 0 || string.IsNullOrEmpty(_document.MapId))
                {
                    lblS32Info.Text = "請選擇一個地圖";
                    _logger.Debug("[RENDER] No S32 files or MapId");
                    return;
                }

                if (!Share.MapDataList.ContainsKey(_document.MapId))
                {
                    lblS32Info.Text = "地圖資料不存在";
                    _logger.Debug("[RENDER] MapId not found in MapDataList");
                    return;
                }

                // 清除小地圖快取（viewport 移動時需要更新紅框）
                // 注意：S32 Block Cache 不在這裡清除，只在地圖切換或編輯時清除


                Struct.L1Map currentMap = Share.MapDataList[_document.MapId];

                // 計算整張地圖的大小（使用與 L1MapHelper 相同的公式）
                // 每個 block 的像素大小: BMP_W = 64 * 24 * 2 = 3072, BMP_H = 64 * 12 * 2 = 1536
                int blockWidth = 64 * 24 * 2;  // 3072
                int blockHeight = 64 * 12 * 2; // 1536

                // 地圖像素大小
                // 注意：由於菱形地圖的特性，右邊界 = (maxBlockX + maxBlockY) * (blockWidth/2) + blockWidth
                // 額外加一個 S32 區塊寬度，確保最右邊的內容完整顯示
                int mapWidth = (currentMap.nBlockCountX + currentMap.nBlockCountY) * blockWidth / 2 + blockWidth;
                int mapHeight = (currentMap.nBlockCountX + currentMap.nBlockCountY) * blockHeight / 2 + blockHeight;

                // 更新 ViewState 的地圖大小
                _viewState.MapWidth = mapWidth;
                _viewState.MapHeight = mapHeight;
                _viewState.ViewportWidth = s32MapPanel.Width;
                _viewState.ViewportHeight = s32MapPanel.Height;
                // ZoomLevel 已經在 _viewState 中，不需要同步

                // 更新捲動限制（保留現有的捲動位置，ViewState.ScrollX/ScrollY 會在限制範圍內調整）
                _viewState.UpdateScrollLimits(mapWidth, mapHeight);

                // 取得需要渲染的世界座標範圍（含緩衝區）
                Rectangle renderRect = _viewState.GetRenderWorldRect();
                LogPerf($"[RENDER-MAP] ScrollX={_viewState.ScrollX}, ScrollY={_viewState.ScrollY}, renderRect=({renderRect.X},{renderRect.Y},{renderRect.Width},{renderRect.Height})");

                // 渲染 Viewport（使用快取的勾選檔案清單）
                RenderViewport(renderRect, currentMap, _checkedS32Files);

                // 統計勾選的 S32 數量和物件數量
                int checkedCount = _checkedS32Files.Count;
                int totalObjects = _document.S32Files.Values
                    .Where(s => _checkedS32Files.Contains(s.FilePath))
                    .Sum(s => s.Layer4.Count);

                lblS32Info.Text = $"已渲染 {checkedCount}/{_document.S32Files.Count} 個S32檔案 | 地圖: {mapWidth}x{mapHeight} | Viewport: {renderRect.Width}x{renderRect.Height} | 第1層:{(chkLayer1.Checked == true ? "顯示" : "隱藏")} 第3層:{(chkLayer3.Checked == true ? "顯示" : "隱藏")} 第4層:{(chkLayer4.Checked == true ? "顯示" : "隱藏")} ({totalObjects}個物件)";
                _logger.Debug($"[RENDER] RenderS32Map complete in {totalSw.ElapsedMilliseconds}ms");
            }
            catch (Exception ex)
            {
                _logger.Error(ex, "[RENDER] RenderS32Map failed");
                lblS32Info.Text = $"渲染失敗: {ex.Message}";
            }
        }

        // Viewport 渲染取消 token
        private System.Threading.CancellationTokenSource _viewportRenderCts = null;
        private readonly object _viewportRenderLock = new object();
        private volatile bool _isRendering = false;
        private volatile int _renderRequestId = 0;

        // 渲染指定範圍的 Viewport（非同步背景渲染）
        private void RenderViewport(Rectangle worldRect, Struct.L1Map currentMap, HashSet<string> checkedFilePaths)
        {
            _logger.Debug($"[RENDER] RenderViewport called: worldRect={worldRect.Width}x{worldRect.Height}");
            // 取消之前的渲染任務
            int currentRequestId;
            lock (_viewportRenderLock)
            {
                if (_viewportRenderCts != null)
                {
                    _viewportRenderCts.Cancel();
                    _viewportRenderCts.Dispose();
                }
                _viewportRenderCts = new System.Threading.CancellationTokenSource();
                currentRequestId = ++_renderRequestId;
            }
            var cancellationToken = _viewportRenderCts.Token;

            // 預先讀取 UI 狀態（在 UI Thread）
            bool showLayer1 = chkLayer1.Checked == true;
            bool showLayer2 = chkLayer2.Checked == true;
            bool showLayer4 = chkLayer4.Checked == true;
            bool showLayer3 = chkLayer3.Checked == true;
            bool showPassable = chkShowPassable.Checked == true;
            bool showGrid = chkShowGrid.Checked == true;
            bool showS32Boundary = chkShowS32Boundary.Checked == true;
            bool showLayer5 = chkShowLayer5.Checked == true;
            bool isLayer5Edit = _editState.IsLayer5EditMode;
            bool hasHighlight = _editState.HighlightedS32Data != null && _editState.HighlightedCellX >= 0 && _editState.HighlightedCellY >= 0;
            int panelWidth = s32MapPanel.Width;
            int panelHeight = s32MapPanel.Height;

            // Capture highlight 狀態（供 background thread 使用）
            var highlightedS32Data = _editState.HighlightedS32Data;
            int highlightedCellX = _editState.HighlightedCellX;
            int highlightedCellY = _editState.HighlightedCellY;

            // Capture 其他需要的狀態
            bool showSafeZones = _viewState.ShowSafeZones;
            bool showCombatZones = _viewState.ShowCombatZones;
            var groupHighlightCells = _editState.GroupHighlightCells.Count > 0
                ? new List<(int, int)>(_editState.GroupHighlightCells)
                : null;

            // 複製需要的資料（避免跨執行緒存取）
            var s32FilesSnapshot = _document.S32Files.ToDictionary(kvp => kvp.Key, kvp => kvp.Value);
            var checkedFilesSnapshot = new HashSet<string>(checkedFilePaths);

            // MapViewerControl 使用 Dock=Fill，不需要手動設定大小
            s32MapPanel.AutoScroll = false;

            // 不使用增量渲染，每次完整重新渲染（避免多執行緒 bitmap 存取問題）

            // 背景執行渲染
            _logger.Debug("[RENDER] Starting background Task.Run");
            Task.Run(() =>
            {
                // 檢查是否已經被更新的請求取代
                if (cancellationToken.IsCancellationRequested || currentRequestId != _renderRequestId)
                {
                    _logger.Debug("[RENDER] Task cancelled before start");
                    return;
                }

                // 標記正在渲染
                _isRendering = true;
                var renderSw = Stopwatch.StartNew();
                _logger.Debug($"[RENDER] Background render started: worldRect={worldRect.Width}x{worldRect.Height}");
                LogPerf($"[RENDER-START] worldRect={worldRect.Width}x{worldRect.Height}");

                int blockWidth = 64 * 24 * 2;  // 3072
                int blockHeight = 64 * 12 * 2; // 1536

                // 創建新的 Viewport SKBitmap（使用 RGB565 格式，與 Tile 資料相同，可直接使用 RenderBlockDirect）
                var createBmpSw = Stopwatch.StartNew();
                _logger.Debug($"[RENDER-SK] Creating SKBitmap: {worldRect.Width}x{worldRect.Height}, Rgb565");
                var skBitmap = new SKBitmap(worldRect.Width, worldRect.Height, SKColorType.Rgb565, SKAlphaType.Opaque);
                _logger.Debug($"[RENDER-SK] SKBitmap created: IsNull={skBitmap == null}, Info={skBitmap?.Info}");
                createBmpSw.Stop();
                long createBmpMs = createBmpSw.ElapsedMilliseconds;
                HashSet<string> newRenderedBlocks = new HashSet<string>();
                int renderedCount = 0;
                int skippedCount = 0;
                long totalGetBlockMs = 0;
                long totalDrawImageMs = 0;

                // 使用空間索引快速查找與 worldRect 相交的 S32 檔案
                var candidateFiles = GetS32FilesInRect(worldRect);
                LogPerf($"[SPATIAL-QUERY] worldRect=({worldRect.X},{worldRect.Y},{worldRect.Width},{worldRect.Height}), candidates={candidateFiles.Count}, total={s32FilesSnapshot.Count}");

                // 使用與原始 L1MapHelper.LoadMap 完全相同的排序方式（Utils.SortDesc）
                var sortedFilePaths = Utils.SortDesc(candidateFiles.ToList());

                // 1. 篩選需要渲染的區塊
                var blocksToRender = new List<(S32Data s32Data, string filePath, int drawX, int drawY)>();
                foreach (object filePathObj in sortedFilePaths)
                {
                    string filePath = filePathObj as string;
                    if (filePath == null || !s32FilesSnapshot.ContainsKey(filePath)) continue;
                    if (!checkedFilePaths.Contains(filePath)) continue;

                    var s32Data = s32FilesSnapshot[filePath];
                    int[] loc = s32Data.SegInfo.GetLoc(1.0);
                    int mx = loc[0];
                    int my = loc[1];

                    Rectangle blockRect = new Rectangle(mx, my, blockWidth, blockHeight);
                    if (!blockRect.IntersectsWith(worldRect))
                    {
                        skippedCount++;
                        continue;
                    }

                    int drawX = mx - worldRect.X;
                    int drawY = my - worldRect.Y;
                    blocksToRender.Add((s32Data, filePath, drawX, drawY));
                    newRenderedBlocks.Add(filePath);
                }

                // 檢查取消
                if (cancellationToken.IsCancellationRequested)
                {
                    LogPerf($"[RENDER-CANCELLED] before parallel render");
                    _isRendering = false;
                    skBitmap.Dispose();
                    LogPerf($"[RENDER-VIEWMAP DISPOSED]");

                    return;
                }

                // 2. 收集所有 Layer 物件並計算絕對像素位置（全域 Layer 排序）
                var getBlockSw = Stopwatch.StartNew();
                var allTiles = new List<(int pixelX, int pixelY, int layer, int tileId, int indexId)>();

                foreach (var (s32Data, filePath, offsetX, offsetY) in blocksToRender)
                {
                    // Layer 1 (地板) - layer 值設為 -2 確保最先繪製
                    if (showLayer1)
                    {
                        for (int y = 0; y < 64; y++)
                        {
                            for (int x = 0; x < 128; x++)
                            {
                                var cell = s32Data.Layer1[y, x];
                                if (cell != null && cell.TileId >= 0)
                                {
                                    int halfX = x / 2;
                                    int baseX = -24 * halfX;
                                    int baseY = 63 * 12 - 12 * halfX;
                                    int pixelX = offsetX + baseX + x * 24 + y * 24;
                                    int pixelY = offsetY + baseY + y * 12;

                                    allTiles.Add((pixelX, pixelY, -2, cell.TileId, cell.IndexId));
                                }
                            }
                        }
                    }

                    // Layer 2 - layer 值設為 -1 確保在 Layer1 之後、Layer4 之前繪製
                    if (showLayer2)
                    {
                        foreach (var item in s32Data.Layer2)
                        {
                            if (item.TileId > 0)
                            {
                                int x = item.X;
                                int y = item.Y;
                                int halfX = x / 2;
                                int baseX = -24 * halfX;
                                int baseY = 63 * 12 - 12 * halfX;
                                int pixelX = offsetX + baseX + x * 24 + y * 24;
                                int pixelY = offsetY + baseY + y * 12;

                                allTiles.Add((pixelX, pixelY, -1, item.TileId, item.IndexId));
                            }
                        }
                    }

                    // Layer 4 (物件) - 使用原始 Layer 值
                    if (showLayer4)
                    {
                        foreach (var obj in s32Data.Layer4)
                        {
                            int halfX = obj.X / 2;
                            int baseX = -24 * halfX;
                            int baseY = 63 * 12 - 12 * halfX;
                            int pixelX = offsetX + baseX + obj.X * 24 + obj.Y * 24;
                            int pixelY = offsetY + baseY + obj.Y * 12;

                            allTiles.Add((pixelX, pixelY, obj.Layer, obj.TileId, obj.IndexId));
                        }
                    }
                }
                getBlockSw.Stop();
                totalGetBlockMs = getBlockSw.ElapsedMilliseconds;
                renderedCount = blocksToRender.Count;

                // 檢查取消
                if (cancellationToken.IsCancellationRequested)
                {
                    LogPerf($"[RENDER-CANCELLED] after collecting tiles");
                    _isRendering = false;
                    skBitmap.Dispose();
                    return;
                }

                // 3. 按 Layer 全域排序後繪製（直接寫入 SKBitmap pixels）
                var drawSw = Stopwatch.StartNew();
                var sortedTiles = allTiles.OrderBy(t => t.layer).ToList();
                _logger.Debug($"[RENDER-SK] Sorted tiles: count={sortedTiles.Count}");

                // SKBitmap 使用 GetPixels() 取得 pointer，stride = width * bytesPerPixel (BGRA8888 = 4 bytes)
                int rowpix = skBitmap.RowBytes;
                _logger.Debug($"[RENDER-SK] RowBytes={rowpix}, Width={skBitmap.Width}, Height={skBitmap.Height}");

                int drawnCount = 0;
                int errorCount = 0;
                try
                {
                    unsafe
                    {
                        byte* ptr = (byte*)skBitmap.GetPixels().ToPointer();
                        _logger.Debug($"[RENDER-SK] Got pixel pointer, starting tile loop");

                        foreach (var tile in sortedTiles)
                        {
                            try
                            {
                                // 使用 RGB565 版本的繪製函數（直接使用 Lin.Helper.Core 的 RenderBlockDirect）
                                DrawTilToBufferDirect565(tile.pixelX, tile.pixelY, tile.tileId, tile.indexId,
                                    rowpix, ptr, skBitmap.Width, skBitmap.Height);
                                drawnCount++;
                            }
                            catch (Exception tileEx)
                            {
                                errorCount++;
                                if (errorCount <= 5) // 只記錄前 5 個錯誤
                                {
                                    _logger.Error(tileEx, $"[RENDER-SK] Error drawing tile: px={tile.pixelX}, py={tile.pixelY}, tileId={tile.tileId}, indexId={tile.indexId}");
                                }
                            }
                        }
                    }
                }
                catch (Exception ex)
                {
                    _logger.Error(ex, $"[RENDER-SK] Critical error in tile drawing loop");
                }
                _logger.Debug($"[RENDER-SK] Tile loop done: drawn={drawnCount}, errors={errorCount}");
                // SKBitmap 不需要 UnlockBits
                drawSw.Stop();
                totalDrawImageMs = drawSw.ElapsedMilliseconds;
                _logger.Debug($"[RENDER-SK] Tiles drawn: count={sortedTiles.Count}, drawTime={totalDrawImageMs}ms");
                renderSw.Stop();
                _logger.Debug($"[RENDER] Background render done: total={renderSw.ElapsedMilliseconds}ms, createBmp={createBmpMs}ms, getBlock={totalGetBlockMs}ms, drawImage={totalDrawImageMs}ms, blocks={renderedCount}");
                LogPerf($"[RENDER] total={renderSw.ElapsedMilliseconds}ms | createBmp={createBmpMs}ms, getBlock={totalGetBlockMs}ms, drawImage={totalDrawImageMs}ms | blocks={renderedCount}, cacheHit={_renderCache.CacheHits}, cacheMiss={_renderCache.CacheMisses}");
                _renderCache.CacheHits = 0;
                _renderCache.CacheMisses = 0;

                // 更新已渲染的 S32 清單
                lock (_renderedS32Blocks)
                {
                    _renderedS32Blocks.Clear();
                    foreach (var path in newRenderedBlocks)
                        _renderedS32Blocks.Add(path);
                }

                if (cancellationToken.IsCancellationRequested)
                {
                    skBitmap.Dispose();
                    return;
                }

                // 繪製覆蓋層（使用 SKCanvas 直接繪製，避免 Eto.Graphics.Dispose 的效能問題）
                // 使用快照資料避免跨執行緒存取問題
                var s32ValuesSnapshot = s32FilesSnapshot.Values;
                _logger.Debug($"[RENDER-OVERLAY] s32ValuesSnapshot.Count={s32ValuesSnapshot.Count}, checkedFilesSnapshot.Count={checkedFilesSnapshot.Count}");
                _logger.Debug($"[RENDER-OVERLAY] showLayer3={showLayer3}, showPassable={showPassable}, showSafeZones={showSafeZones}, showCombatZones={showCombatZones}");
                _logger.Debug($"[RENDER-OVERLAY] showGrid={showGrid}, showS32Boundary={showS32Boundary}, showLayer5={showLayer5}, isLayer5Edit={isLayer5Edit}");
                var overlaySw = Stopwatch.StartNew();
                try
                {
                    using (var skCanvas = new SKCanvas(skBitmap))
                    {
                        _logger.Debug($"[RENDER-OVERLAY] SKCanvas created in {overlaySw.ElapsedMilliseconds}ms");

                        if (showLayer3)
                        {
                            try
                            {
                                var sw = Stopwatch.StartNew();
                                DrawLayer3AttributesViewportSK(skCanvas, currentMap, worldRect, s32ValuesSnapshot);
                                _logger.Debug($"[RENDER-OVERLAY] Layer3 took {sw.ElapsedMilliseconds}ms");
                            }
                            catch (Exception ex)
                            {
                                _logger.Error(ex, "[RENDER-OVERLAY] Layer3 failed");
                            }
                        }

                        if (showPassable)
                        {
                            try
                            {
                                var sw = Stopwatch.StartNew();
                                DrawPassableOverlayViewportSK(skCanvas, currentMap, worldRect, s32ValuesSnapshot);
                                _logger.Debug($"[RENDER-OVERLAY] Passable took {sw.ElapsedMilliseconds}ms");
                            }
                            catch (Exception ex)
                            {
                                _logger.Error(ex, "[RENDER-OVERLAY] Passable failed");
                            }
                        }

                        if (showSafeZones || showCombatZones)
                        {
                            try
                            {
                                var sw = Stopwatch.StartNew();
                                DrawRegionsOverlayViewportSK(skCanvas, currentMap, worldRect, showSafeZones, showCombatZones, s32ValuesSnapshot);
                                _logger.Debug($"[RENDER-OVERLAY] Regions took {sw.ElapsedMilliseconds}ms");
                            }
                            catch (Exception ex)
                            {
                                _logger.Error(ex, "[RENDER-OVERLAY] Regions failed");
                            }
                        }

                        if (showGrid)
                        {
                            try
                            {
                                var sw = Stopwatch.StartNew();
                                DrawS32GridViewportSK(skCanvas, currentMap, worldRect, s32ValuesSnapshot);
                                DrawCoordinateLabelsViewportSK(skCanvas, currentMap, worldRect, s32ValuesSnapshot);
                                _logger.Debug($"[RENDER-OVERLAY] Grid took {sw.ElapsedMilliseconds}ms");
                            }
                            catch (Exception ex)
                            {
                                _logger.Error(ex, "[RENDER-OVERLAY] Grid failed");
                            }
                        }

                        if (showS32Boundary)
                        {
                            try
                            {
                                var sw = Stopwatch.StartNew();
                                DrawS32BoundaryOnlyViewportSK(skCanvas, currentMap, worldRect, s32ValuesSnapshot);
                                _logger.Debug($"[RENDER-OVERLAY] S32Boundary took {sw.ElapsedMilliseconds}ms");
                            }
                            catch (Exception ex)
                            {
                                _logger.Error(ex, "[RENDER-OVERLAY] S32Boundary failed");
                            }
                        }

                        if (showLayer5)
                        {
                            try
                            {
                                var sw = Stopwatch.StartNew();
                                _logger.Debug($"[RENDER-OVERLAY] Layer5 starting: isLayer5Edit={isLayer5Edit}");
                                DrawLayer5OverlayViewportSK(skCanvas, currentMap, worldRect, isLayer5Edit, s32ValuesSnapshot, checkedFilesSnapshot);
                                _logger.Debug($"[RENDER-OVERLAY] Layer5 took {sw.ElapsedMilliseconds}ms");
                            }
                            catch (Exception ex)
                            {
                                _logger.Error(ex, "[RENDER-OVERLAY] Layer5 failed");
                            }
                        }

                        // 繪製群組高亮覆蓋層（綠色）
                        if (groupHighlightCells != null && groupHighlightCells.Count > 0)
                        {
                            try
                            {
                                var sw = Stopwatch.StartNew();
                                DrawGroupHighlightOverlaySK(skCanvas, worldRect, groupHighlightCells, s32ValuesSnapshot);
                                _logger.Debug($"[RENDER-OVERLAY] GroupHighlight took {sw.ElapsedMilliseconds}ms");
                            }
                            catch (Exception ex)
                            {
                                _logger.Error(ex, "[RENDER-OVERLAY] GroupHighlight failed");
                            }
                        }

                        // 黃色高亮已移除（用戶要求）

                        _logger.Debug($"[RENDER-OVERLAY] All overlays done, before SKCanvas dispose: {overlaySw.ElapsedMilliseconds}ms");
                    } // skCanvas dispose here (should be fast)
                }
                catch (Exception ex)
                {
                    _logger.Error(ex, "[RENDER-OVERLAY] Critical error in overlay rendering");
                }
                _logger.Debug($"[RENDER-OVERLAY] Total overlay time (after SKCanvas dispose): {overlaySw.ElapsedMilliseconds}ms");

                if (cancellationToken.IsCancellationRequested)
                {
                    skBitmap.Dispose();
                    return;
                }

                // 直接傳遞 SKBitmap 給 MapViewerControl（不在 background thread 轉換）
                // MapViewerControl 會在 Paint 時才轉換，並快取結果

                // 回到 UI Thread 更新
                var queueTime = DateTime.UtcNow;
                _logger.Debug($"[RENDER] Queuing BeginInvoke at {queueTime:HH:mm:ss.fff}");
                LogPerf($"[RENDER-INVOKE] queuing BeginInvoke from thread {System.Threading.Thread.CurrentThread.ManagedThreadId}");
                try
                {
                    // 安全檢查：確保 Form 還存在
                    if (this.IsDisposed || !this.IsHandleCreated)
                    {
                        _isRendering = false;
                        skBitmap.Dispose();
                        return;
                    }
                    this.BeginInvoke((MethodInvoker)delegate
                    {
                        var executeTime = DateTime.UtcNow;
                        var waitMs = (executeTime - queueTime).TotalMilliseconds;
                        var invokeSw = Stopwatch.StartNew();
                        _logger.Debug($"[RENDER] BeginInvoke callback start - waited {waitMs:F0}ms in queue");
                        LogPerf($"[RENDER-INVOKE] callback start");
                        _isRendering = false;  // 渲染完成

                        // 安全檢查
                        if (this.IsDisposed)
                        {
                            skBitmap.Dispose();
                            return;
                        }

                        if (cancellationToken.IsCancellationRequested)
                        {
                            skBitmap.Dispose();
                            LogPerf($"[RENDER-INVOKE] cancelled, total={invokeSw.ElapsedMilliseconds}ms");
                            return;
                        }

                        _logger.Debug($"[RENDER] After safety check: {invokeSw.ElapsedMilliseconds}ms");

                        // Highlight 已移到 background thread 的 SKCanvas 區塊

                        // Layer8 標記和 SPR 動畫統一在 overlay 繪製（PaintOverlay 事件）
                        // 這樣 marker 和動畫可以一起更新，不需要等完整重繪

                        // 保存渲染結果元數據
                        _logger.Debug($"[RENDER-SK] Before SetRenderResult: worldRect=({worldRect.X},{worldRect.Y},{worldRect.Width},{worldRect.Height})");
                        _viewState.SetRenderResult(worldRect.X, worldRect.Y, worldRect.Width, worldRect.Height, _viewState.ZoomLevel);
                        _logger.Debug($"[RENDER-SK] After SetRenderResult: RenderWidth={_viewState.RenderWidth}, RenderHeight={_viewState.RenderHeight}");

                        _logger.Debug($"[RENDER] After SetRenderResult: {invokeSw.ElapsedMilliseconds}ms");

                        invokeSw.Stop();
                        _logger.Debug($"[RENDER] BeginInvoke callback complete: invokeTime={invokeSw.ElapsedMilliseconds}ms, bmpSize={skBitmap.Width}x{skBitmap.Height}");
                        LogPerf($"[RENDER-COMPLETE] size={skBitmap.Width}x{skBitmap.Height}, invokeTime={invokeSw.ElapsedMilliseconds}ms");

                        // 傳遞 SKBitmap 給 MapViewerControl（MapViewerControl 取得所有權並負責 dispose）
                        _logger.Debug($"[RENDER-SK] Calling SetExternalBitmap: skBitmap={skBitmap.Width}x{skBitmap.Height}");
                        _mapViewerControl.SetExternalBitmap(skBitmap);
                    });
                }
                catch
                {
                    _isRendering = false;  // 發生錯誤也要重置
                    skBitmap.Dispose();
                }
            });
        }

        // 檢查是否需要重新渲染並執行
        private void CheckAndRerenderIfNeeded()
        {
            LogPerf($"[CHECK-RERENDER] start, s32Count={_document.S32Files.Count}, isDragging={_interaction.IsMainMapDragging}");

            if (_document.S32Files.Count == 0 || string.IsNullOrEmpty(_document.MapId))
                return;

            // 拖曳中不重新渲染，只更新顯示
            if (_interaction.IsMainMapDragging)
            {
                _mapViewerControl.Refresh();
                return;
            }

            // 更新 Viewport 大小到 ViewState（ZoomLevel 已經在 _viewState 中）
            _viewState.ViewportWidth = s32MapPanel.Width;
            _viewState.ViewportHeight = s32MapPanel.Height;
            // ScrollX/ScrollY 已經在拖曳時更新了，這裡不需要再設定

            // 檢查是否需要重新渲染
            bool needsRerender = _viewState.NeedsRerender();

            if (needsRerender)
            {
                LogPerf($"[RERENDER-TRIGGERED] ScrollX={_viewState.ScrollX}, ScrollY={_viewState.ScrollY}");
                RenderS32Map();
            }
            else
            {
                // 只需要重繪（不需要重新渲染）
                _mapViewerControl.Refresh();
            }
        }

        /// <summary>
        /// 取得快取的 S32 Block 或渲染新的（用於 Viewport 渲染）
        /// </summary>
        private Bitmap GetOrRenderS32Block(S32Data s32Data, bool showLayer1, bool showLayer2, bool showLayer4)
        {
            // 只有 Layer1+Layer2+Layer4 都開啟時才使用快取
            if (showLayer1 && showLayer2 && showLayer4)
            {
                string cacheKey = s32Data.FilePath;
                if (_renderCache.S32BlockCache.TryGetValue(cacheKey, out Bitmap cached))
                {
                    _renderCache.CacheHits++;
                    return cached;
                }

                _renderCache.CacheMisses++;
                // 渲染並快取
                Bitmap rendered = RenderS32Block(s32Data, showLayer1, showLayer2, showLayer4);
                _renderCache.S32BlockCache.TryAdd(cacheKey, rendered);
                return rendered;
            }

            // 其他情況直接渲染（不快取）
            return RenderS32Block(s32Data, showLayer1, showLayer2, showLayer4);
        }

        /// <summary>
        /// 同步 _checkedS32Files 到 _document.CheckedS32Files，並更新地圖尺寸
        /// </summary>
        private void SyncCheckedS32FilesToDocument()
        {
            // 同步 checked files
            _document.CheckedS32Files.Clear();
            foreach (var filePath in _checkedS32Files)
            {
                _document.CheckedS32Files.Add(filePath);
            }

            // 同步地圖尺寸
            _document.SetMapPixelSize(_viewState.MapWidth, _viewState.MapHeight);
        }

        /// <summary>
        /// 清除 S32 Block 快取（地圖變更或編輯時呼叫）
        /// </summary>
        private void ClearS32BlockCache()
        {
            foreach (var bmp in _renderCache.S32BlockCache.Values)
            {
                bmp?.Dispose();
            }
            _renderCache.S32BlockCache.Clear();
            lock (_renderedS32Blocks)
            {
                _renderedS32Blocks.Clear();
            }
            // 注意：不重置 _viewState.RenderResult，讓舊的 viewport bitmap 繼續顯示
            // 直到新的渲染完成後由 RenderViewport 更新
        }

        /// <summary>
        /// 清除單個 S32 Block 的快取（編輯後呼叫）
        /// </summary>
        private void InvalidateS32BlockCache(string filePath)
        {
            if (_renderCache.S32BlockCache.TryRemove(filePath, out Bitmap bmp))
            {
                bmp?.Dispose();
            }
            lock (_renderedS32Blocks)
            {
                _renderedS32Blocks.Remove(filePath);
            }
        }

        // 渲染單個 S32 區塊為 bitmap（與 L1MapHelper.s32FileToBmp 相同的方式）
        private Bitmap RenderS32Block(S32Data s32Data, bool showLayer1, bool showLayer2, bool showLayer4)
        {
            int blockWidth = 64 * 24 * 2;  // 3072
            int blockHeight = 64 * 12 * 2; // 1536

            Bitmap result = new Bitmap(blockWidth, blockHeight, PixelFormat.Format16bppRgb555);

            Rectangle rect = new Rectangle(0, 0, result.Width, result.Height);
            BitmapData bmpData = result.LockBits(rect, ImageLockMode.ReadWrite, result.PixelFormat);
            int rowpix = bmpData.Stride;

            unsafe
            {
                byte* ptr = (byte*)bmpData.Scan0;

                // 第一層（地板）- 與 drawTilBlock 完全相同的座標計算
                if (showLayer1)
                {
                    for (int y = 0; y < 64; y++)
                    {
                        for (int x = 0; x < 128; x++)
                        {
                            var cell = s32Data.Layer1[y, x];
                            if (cell != null && cell.TileId >= 0)
                            {
                                // 與 L1MapHelper.drawTilBlock 完全相同的座標計算
                                int baseX = 0;
                                int baseY = 63 * 12;
                                baseX -= 24 * (x / 2);
                                baseY -= 12 * (x / 2);

                                int pixelX = baseX + x * 24 + y * 24;
                                int pixelY = baseY + y * 12;

                                DrawTilToBufferDirect555(pixelX, pixelY, cell.TileId, cell.IndexId, rowpix, ptr, blockWidth, blockHeight);
                            }
                        }
                    }
                }

                // 第二層 - 與第一層渲染方式相同
                if (showLayer2)
                {
                    foreach (var item in s32Data.Layer2)
                    {
                        if (item.TileId > 0)
                        {
                            int x = item.X;
                            int y = item.Y;

                            int baseX = 0;
                            int baseY = 63 * 12;
                            baseX -= 24 * (x / 2);
                            baseY -= 12 * (x / 2);

                            int pixelX = baseX + x * 24 + y * 24;
                            int pixelY = baseY + y * 12;

                            DrawTilToBufferDirect555(pixelX, pixelY, item.TileId, item.IndexId, rowpix, ptr, blockWidth, blockHeight);
                        }
                    }
                }

                // 第四層（物件）
                if (showLayer4)
                {
                    var sortedObjects = s32Data.Layer4.OrderBy(o => o.Layer).ToList();

                    foreach (var obj in sortedObjects)
                    {
                        int baseX = 0;
                        int baseY = 63 * 12;
                        baseX -= 24 * (obj.X / 2);
                        baseY -= 12 * (obj.X / 2);

                        int pixelX = baseX + obj.X * 24 + obj.Y * 24;
                        int pixelY = baseY + obj.Y * 12;

                        DrawTilToBufferDirect555(pixelX, pixelY, obj.TileId, obj.IndexId, rowpix, ptr, blockWidth, blockHeight);
                    }
                }
            }

            result.UnlockBits(bmpData);
            return result;
        }

        // 設定初始捲動位置到地圖中央（不渲染，用於載入時先設定位置）
        private void SetInitialScrollToCenter(Struct.L1Map currentMap)
        {
            // 計算地圖像素大小
            // 注意：菱形地圖的邊界取決於 (blockX + blockY)，額外加一個 S32 區塊確保完整顯示
            int blockWidth = 64 * 24 * 2;  // 3072
            int blockHeight = 64 * 12 * 2; // 1536
            int mapWidth = (currentMap.nBlockCountX + currentMap.nBlockCountY) * blockWidth / 2 + blockWidth;
            int mapHeight = (currentMap.nBlockCountX + currentMap.nBlockCountY) * blockHeight / 2 + blockHeight;

            // 更新 ViewState（RenderS32Map 會用到）
            _viewState.MapWidth = mapWidth;
            _viewState.MapHeight = mapHeight;
            _viewState.ViewportWidth = s32MapPanel.Width;
            _viewState.ViewportHeight = s32MapPanel.Height;
            // ZoomLevel 已經在地圖選擇時重置為 1.0
            _viewState.UpdateScrollLimits(mapWidth, mapHeight);

            if (_document.S32Files.Count == 0)
            {
                _viewState.SetScrollSilent(0, 0);
                return;
            }

            // 取得所有 S32 的遊戲座標範圍
            int minGameX = int.MaxValue, minGameY = int.MaxValue;
            int maxGameX = int.MinValue, maxGameY = int.MinValue;
            foreach (var s32Data in _document.S32Files.Values)
            {
                int beginX = s32Data.SegInfo.nLinBeginX;
                int beginY = s32Data.SegInfo.nLinBeginY;
                int endX = beginX + 64;
                int endY = beginY + 64;

                minGameX = Math.Min(minGameX, beginX);
                minGameY = Math.Min(minGameY, beginY);
                maxGameX = Math.Max(maxGameX, endX);
                maxGameY = Math.Max(maxGameY, endY);
            }

            // 計算遊戲座標中心點
            int centerGameX = (minGameX + maxGameX) / 2;
            int centerGameY = (minGameY + maxGameY) / 2;

            LogPerf($"[SCROLL-CENTER] GameCoord range=({minGameX},{minGameY})-({maxGameX},{maxGameY}), center=({centerGameX},{centerGameY})");

            // 直接跳轉到遊戲座標中心點
            JumpToGameCoordinate(centerGameX, centerGameY);
        }

        // 捲動到地圖中央（含重新渲染）
        private void ScrollToMapCenter()
        {
            int mapWidth = _viewState.MapWidth;
            int mapHeight = _viewState.MapHeight;

            if (mapWidth <= 0 || mapHeight <= 0)
                return;

            // 計算中央位置（世界座標）
            int viewportWidthWorld = (int)(s32MapPanel.Width / _viewState.ZoomLevel);
            int viewportHeightWorld = (int)(s32MapPanel.Height / _viewState.ZoomLevel);
            int centerX = mapWidth / 2 - viewportWidthWorld / 2;
            int centerY = mapHeight / 2 - viewportHeightWorld / 2;

            // 限制在有效範圍內（使用 ViewState 的限制，含緩衝區）
            centerX = Math.Max(_viewState.MinScrollX, Math.Min(centerX, _viewState.MaxScrollX));
            centerY = Math.Max(_viewState.MinScrollY, Math.Min(centerY, _viewState.MaxScrollY));

            // 設定 ViewState 的捲動位置
            _viewState.SetScrollSilent(centerX, centerY);

            // 重新渲染並更新小地圖紅框
            CheckAndRerenderIfNeeded();
            UpdateMiniMapViewportRect();
        }

        // 繪製第三層（地圖屬性）- 用邊線顯示屬性
        // Attribute1 = 左半邊, Attribute2 = 右半邊
        private void DrawLayer3Attributes(Bitmap bitmap, Struct.L1Map currentMap)
        {
            using (Graphics g = GraphicsHelper.FromImage(bitmap))
            {
                g.SetSmoothingMode(SmoothingMode.AntiAlias);

                // 遍歷所有 S32 檔案
                foreach (var s32Data in _document.S32Files.Values)
                {
                    // 使用與 RenderS32Map 相同的座標計算方式
                    int[] loc = s32Data.SegInfo.GetLoc(1.0);
                    int mx = loc[0];
                    int my = loc[1];

                    // Layer3 是 64x64，每個 Layer3 格子對應 Layer1 的 x*2 和 x*2+1
                    for (int y = 0; y < 64; y++)
                    {
                        for (int x = 0; x < 64; x++)  // Layer3 座標 (0-63)
                        {
                            var attr = s32Data.Layer3[y, x];
                            if (attr == null) continue;

                            // 只有當兩個屬性都為0時才跳過
                            if (attr.Attribute1 == 0 && attr.Attribute2 == 0) continue;

                            // 第3層的一個格子對應第1層的兩個格子（X方向）
                            int x1 = x * 2;

                            // 與 drawTilBlock 相同的像素計算
                            int localBaseX = 0;
                            int localBaseY = 63 * 12;
                            localBaseX -= 24 * (x1 / 2);
                            localBaseY -= 12 * (x1 / 2);

                            int X = mx + localBaseX + x1 * 24 + y * 24;
                            int Y = my + localBaseY + y * 12;

                            // 菱形的四個頂點
                            Point pTop = new Point(X + 24, Y + 0);
                            Point pRight = new Point(X + 48, Y + 12);
                            Point pBottom = new Point(X + 24, Y + 24);
                            Point pLeft = new Point(X + 0, Y + 12);
                            Point pCenter = new Point(X + 24, Y + 12);

                            // 左半邊 - 使用 Attribute1
                            if (attr.Attribute1 != 0)
                            {
                                Color color1 = GetAttributeColor(attr.Attribute1);
                                using (Pen pen = new Pen(color1, 3))
                                {
                                    g.DrawLine(pen, pLeft, pTop);
                                    g.DrawLine(pen, pTop, pCenter);
                                    g.DrawLine(pen, pCenter, pBottom);
                                    g.DrawLine(pen, pBottom, pLeft);
                                }
                            }

                            // 右半邊 - 使用 Attribute2
                            if (attr.Attribute2 != 0)
                            {
                                Color color2 = GetAttributeColor(attr.Attribute2);
                                using (Pen pen = new Pen(color2, 3))
                                {
                                    g.DrawLine(pen, pTop, pRight);
                                    g.DrawLine(pen, pRight, pBottom);
                                    g.DrawLine(pen, pBottom, pCenter);
                                    g.DrawLine(pen, pCenter, pTop);
                                }
                            }
                        }
                    }
                }
            }
        }

        // 繪製通行性覆蓋層 - 用邊線顯示屬性
        // Attribute1 = 左上邊線, Attribute2 = 右上邊線
        // 顏色分類（考慮組合情況）：
        //   紅色 = 不可通行 (0x01)
        //   深紅 = 不可通行+安全區 (0x01+0x02)
        //   橘色 = 不可通行+戰鬥區 (0x01+0x04)
        //   藍色 = 安全區 (0x02)
        //   黃色 = 戰鬥區 (0x04)
        //   綠色 = 安全區+戰鬥區 (0x02+0x04)
        //   灰色 = 其他屬性
        // 繪製通行性覆蓋層 - 用邊線顯示可通行/不可通行
        // Attribute1 = 左半邊, Attribute2 = 右半邊
        private void DrawPassableOverlay(Bitmap bitmap, Struct.L1Map currentMap)
        {
            using (Graphics g = GraphicsHelper.FromImage(bitmap))
            {
                g.SetSmoothingMode(SmoothingMode.AntiAlias);

                // 定義畫筆 - 使用明顯區分的顏色 (不透明避免重疊混色)
                using (Pen penImpassable = new Pen(Color.FromArgb(255, 128, 0, 128), 3))  // 不可通行 - 深紫色粗線
                using (Pen penPassable = new Pen(Color.FromArgb(255, 50, 200, 255), 2))   // 可通行 - 天藍色
                {
                    // 遍歷所有 S32 檔案
                    foreach (var s32Data in _document.S32Files.Values)
                    {
                        // 使用 GetLoc 計算區塊位置
                        int[] loc = s32Data.SegInfo.GetLoc(1.0);
                        int mx = loc[0];
                        int my = loc[1];

                        // Layer3 是 64x64，每個 Layer3 格子對應 Layer1 的 x*2 和 x*2+1
                        for (int y = 0; y < 64; y++)
                        {
                            for (int x = 0; x < 64; x++)  // Layer3 座標 (0-63)
                            {
                                var attr = s32Data.Layer3[y, x];
                                if (attr == null) continue;

                                // 第3層的一個格子對應第1層的兩個格子（X方向）
                                int x1 = x * 2;

                                // 使用 GetLoc + drawTilBlock 公式計算像素位置
                                int localBaseX = 0;
                                int localBaseY = 63 * 12;
                                localBaseX -= 24 * (x1 / 2);
                                localBaseY -= 12 * (x1 / 2);

                                int X = mx + localBaseX + x1 * 24 + y * 24;
                                int Y = my + localBaseY + y * 12;

                                // 菱形的頂點
                                Point pTop = new Point(X + 24, Y + 0);
                                Point pRight = new Point(X + 48, Y + 12);
                                Point pLeft = new Point(X + 0, Y + 12);

                                // 左上邊線 - 使用 Attribute1 判斷
                                Pen pen1 = (attr.Attribute1 & 0x01) != 0 ? penImpassable : penPassable;
                                g.DrawLine(pen1, pLeft, pTop);

                                // 右上邊線 - 使用 Attribute2 判斷
                                Pen pen2 = (attr.Attribute2 & 0x01) != 0 ? penImpassable : penPassable;
                                g.DrawLine(pen2, pTop, pRight);
                            }
                        }
                    }
                }
            }
        }
        
        // 根據屬性值取得對應的顏色（不同值 = 不同顏色）
        private Color GetAttributeColor(short attrValue)
        {
            return Color.FromArgb(230, 200, 200, 200);
            // 根據不同的值返回不同的顏色
            switch (attrValue)
            {
                case 0x0001: return Color.FromArgb(230, 255, 0, 0);       // 紅色
                case 0x0002: return Color.FromArgb(230, 0, 100, 255);     // 藍色
                case 0x0003: return Color.FromArgb(230, 180, 0, 180);     // 紫色
                case 0x0004: return Color.FromArgb(230, 255, 200, 0);     // 黃色
                case 0x0005: return Color.FromArgb(230, 255, 100, 0);     // 橘色
                case 0x0006: return Color.FromArgb(230, 0, 200, 100);     // 綠色
                case 0x0007: return Color.FromArgb(230, 0, 200, 200);     // 青色
                case 0x0008: return Color.FromArgb(230, 200, 100, 50);    // 棕色
                case 0x0009: return Color.FromArgb(230, 255, 150, 150);   // 粉紅
                case 0x000A: return Color.FromArgb(230, 150, 255, 150);   // 淺綠
                case 0x000B: return Color.FromArgb(230, 150, 150, 255);   // 淺藍
                case 0x000C: return Color.FromArgb(230, 255, 255, 100);   // 淺黃
                case 0x000D: return Color.FromArgb(230, 255, 100, 255);   // 洋紅
                case 0x000E: return Color.FromArgb(230, 100, 255, 255);   // 淺青
                case 0x000F: return Color.FromArgb(230, 200, 200, 200);   // 淺灰
                default:
                    // 對於其他值，根據值生成顏色
                    int r = (attrValue * 37) % 200 + 55;
                    int g = (attrValue * 73) % 200 + 55;
                    int b = (attrValue * 113) % 200 + 55;
                    return Color.FromArgb(230, r, g, b);
            }
        }

        // 繪製選中格子的高亮
        private void DrawHighlightedCell(Bitmap bitmap, Struct.L1Map currentMap)
        {
            if (_editState.HighlightedS32Data == null) return;

            using (Graphics g = GraphicsHelper.FromImage(bitmap))
            {
                g.SetSmoothingMode(SmoothingMode.AntiAlias);

                // 使用 GetLoc 計算區塊位置
                int[] loc = _editState.HighlightedS32Data.SegInfo.GetLoc(1.0);
                int mx = loc[0];
                int my = loc[1];

                // 使用 GetLoc + drawTilBlock 公式計算像素位置
                int localBaseX = 0;
                int localBaseY = 63 * 12;
                localBaseX -= 24 * (_editState.HighlightedCellX / 2);
                localBaseY -= 12 * (_editState.HighlightedCellX / 2);

                int X = mx + localBaseX + _editState.HighlightedCellX * 24 + _editState.HighlightedCellY * 24;
                int Y = my + localBaseY + _editState.HighlightedCellY * 12;

                // 菱形的四個頂點（24x24 的菱形）
                Point p1 = new Point(X + 0, Y + 12);   // 左
                Point p2 = new Point(X + 12, Y + 0);   // 上
                Point p3 = new Point(X + 24, Y + 12);  // 右
                Point p4 = new Point(X + 12, Y + 24);  // 下

                // 填充半透明黃色
                using (SolidBrush brush = new SolidBrush(Color.FromArgb(120, 255, 255, 0)))
                {
                    g.FillPolygon(brush, new Point[] { p1, p2, p3, p4 });
                }

                // 繪製亮黃色邊框
                using (Pen pen = new Pen(Color.FromArgb(255, 255, 200, 0), 3))
                {
                    g.DrawPolygon(pen, new Point[] { p1, p2, p3, p4 });
                }
            }
        }

        // 只繪製 S32 邊界框（用於除錯對齊），四個角落內側顯示座標
        private void DrawS32BoundaryOnly(Bitmap bitmap, Struct.L1Map currentMap)
        {
            using (Graphics g = GraphicsHelper.FromImage(bitmap))
            {
                g.SetSmoothingMode(SmoothingMode.AntiAlias);
                g.SetTextRenderingHint(TextRenderingHint.ClearTypeGridFit);

                Font font = new Font("Arial", 9, FontStyle.Bold);
                Pen boundaryPen = new Pen(Colors.Cyan, 2);

                foreach (var s32Data in _document.S32Files.Values)
                {
                    int[] loc = s32Data.SegInfo.GetLoc(1.0);
                    int mx = loc[0];
                    int my = loc[1];

                    // 用 Layer3 座標系
                    // 邊界框的四個角落直接用 (x3, y) = (0,0), (64,0), (64,64), (0,64)
                    // 這樣下一個 S32 的 (0,0) 就會和這個 S32 的 (0,64) 或 (64,0) 重疊
                    Point[] corners = new Point[4];

                    int[][] cornerCoords = new int[][] {
                        new int[] { 0, 0 },    // 左上
                        new int[] { 64, 0 },   // 右上
                        new int[] { 64, 64 },  // 右下
                        new int[] { 0, 64 }    // 左下
                    };

                    for (int i = 0; i < 4; i++)
                    {
                        int x3 = cornerCoords[i][0];
                        int y = cornerCoords[i][1];
                        int x = x3 * 2;

                        int localBaseX = 0 - 24 * (x / 2);
                        int localBaseY = 63 * 12 - 12 * (x / 2);
                        int X = mx + localBaseX + x * 24 + y * 24;
                        int Y = my + localBaseY + y * 12;

                        // 所有角落都取「上頂點」位置，並往左下移一格 (-24, +12)
                        corners[i] = new Point(X, Y + 12);
                    }

                    // 繪製邊界框
                    g.DrawLine(boundaryPen, corners[0], corners[1]);
                    g.DrawLine(boundaryPen, corners[1], corners[2]);
                    g.DrawLine(boundaryPen, corners[2], corners[3]);
                    g.DrawLine(boundaryPen, corners[3], corners[0]);

                    // 在中心顯示 GetLoc 值和座標範圍
                    int centerX = (corners[0].X + corners[2].X) / 2;
                    int centerY = (corners[0].Y + corners[2].Y) / 2;
                    string centerText = $"GetLoc({mx},{my})\n{s32Data.SegInfo.nLinBeginX},{s32Data.SegInfo.nLinBeginY}~{s32Data.SegInfo.nLinEndX},{s32Data.SegInfo.nLinEndY}";
                    using (SolidBrush cb = new SolidBrush(ColorExtensions.FromArgb(200, Colors.Black)))
                    using (SolidBrush ct = new SolidBrush(Colors.Lime))
                    {
                        SizeF cs = g.MeasureString(centerText, font);
                        g.FillRectangle(cb, centerX - cs.Width/2 - 2, centerY - cs.Height/2 - 1, cs.Width + 4, cs.Height + 2);
                        g.DrawString(centerText, font, ct, centerX - cs.Width/2, centerY - cs.Height/2);
                    }

                    // 四個角落的遊戲座標
                    int bx = s32Data.SegInfo.nLinBeginX;
                    int by = s32Data.SegInfo.nLinBeginY;
                    int ex = s32Data.SegInfo.nLinEndX;
                    int ey = s32Data.SegInfo.nLinEndY;

                    // 在四個角落內側繪製座標（包含螢幕座標以便除錯）
                    using (SolidBrush bgBrush = new SolidBrush(ColorExtensions.FromArgb(200, Colors.Black)))
                    using (SolidBrush textBrush = new SolidBrush(Colors.Yellow))
                    {
                        string[] texts = new string[] {
                            $"{bx},{by}\n({corners[0].X},{corners[0].Y})",   // 左上
                            $"{ex},{by}\n({corners[1].X},{corners[1].Y})",   // 右上
                            $"{ex},{ey}\n({corners[2].X},{corners[2].Y})",   // 右下
                            $"{bx},{ey}\n({corners[3].X},{corners[3].Y})"    // 左下
                        };

                        // 偏移量讓文字在邊界內側
                        int[][] offsets = new int[][] {
                            new int[] { 5, 5 },      // 左上：往右下
                            new int[] { -90, 5 },    // 右上：往左下
                            new int[] { -90, -35 },  // 右下：往左上
                            new int[] { 5, -35 }     // 左下：往右上
                        };

                        for (int i = 0; i < 4; i++)
                        {
                            SizeF size = g.MeasureString(texts[i], font);
                            int tx = corners[i].X + offsets[i][0];
                            int ty = corners[i].Y + offsets[i][1];
                            g.FillRectangle(bgBrush, tx - 2, ty - 1, size.Width + 4, size.Height + 2);
                            g.DrawString(texts[i], font, textBrush, tx, ty);
                        }
                    }
                }

                font.Dispose();
                boundaryPen.Dispose();
            }
        }

        // 繪製 S32 格子網格線 - 基於 Layer3 繪製格線
        // 擴展範圍: X 0-255, Y 0-127 (原始範圍的 2 倍，支援超出邊界的物件)
        private void DrawS32Grid(Bitmap bitmap, Struct.L1Map currentMap)
        {
            // 預先收集所有 S32 的正常範圍 (遊戲座標)，用於判斷擴展區域是否被覆蓋
            var normalCoverage = new HashSet<(int gameX, int gameY)>();
            foreach (var s32Data in _document.S32Files.Values)
            {
                for (int y = 0; y < 64; y++)
                {
                    for (int x3 = 0; x3 < 64; x3++)
                    {
                        int gameX = s32Data.SegInfo.nLinBeginX + x3;
                        int gameY = s32Data.SegInfo.nLinBeginY + y;
                        normalCoverage.Add((gameX, gameY));
                    }
                }
            }

            // 記錄已繪製的擴展區域格子，避免重複繪製
            var drawnExtended = new HashSet<(int gameX, int gameY)>();

            using (Graphics g = GraphicsHelper.FromImage(bitmap))
            {
                using (Pen gridPen = new Pen(ColorExtensions.FromArgb(100, Colors.Red), 2)) // 半透明紅色
                using (Pen extendedGridPen = new Pen(ColorExtensions.FromArgb(60, Colors.Blue), 1)) // 擴展區域用淡藍色
                {
                    // 遍歷所有 S32 檔案
                    foreach (var s32Data in _document.S32Files.Values)
                    {
                        // 使用與 RenderS32Map 相同的座標計算方式
                        int[] loc = s32Data.SegInfo.GetLoc(1.0);
                        int mx = loc[0];
                        int my = loc[1];

                        // 繪製格線 - 擴展範圍 Y: 0-127, X3: 0-127 (Layer1 X: 0-255)
                        for (int y = 0; y < 128; y++)
                        {
                            for (int x3 = 0; x3 < 128; x3++)  // Layer3 座標 (0-127)
                            {
                                // 判斷是否在原始範圍內 (0-63, 0-63)
                                bool isExtended = (x3 >= 64 || y >= 64);

                                // 計算遊戲座標
                                int gameX = s32Data.SegInfo.nLinBeginX + x3;
                                int gameY = s32Data.SegInfo.nLinBeginY + y;

                                if (isExtended)
                                {
                                    // 擴展區域：檢查是否被其他 S32 的正常範圍覆蓋
                                    if (normalCoverage.Contains((gameX, gameY)))
                                        continue; // 已被其他 S32 正常範圍覆蓋，不畫藍線

                                    // 檢查是否已經畫過
                                    if (drawnExtended.Contains((gameX, gameY)))
                                        continue; // 已畫過，不重複畫

                                    drawnExtended.Add((gameX, gameY));
                                }

                                // Layer3 座標轉 Layer1 座標（取偶數 x）
                                int x = x3 * 2;

                                // 與 drawTilBlock 相同的像素計算
                                int localBaseX = 0;
                                int localBaseY = 63 * 12;
                                localBaseX -= 24 * (x / 2);
                                localBaseY -= 12 * (x / 2);

                                int X = mx + localBaseX + x * 24 + y * 24;
                                int Y = my + localBaseY + y * 12;

                                Pen currentPen = isExtended ? extendedGridPen : gridPen;

                                // Layer3 菱形的四個頂點（48x24，覆蓋兩個 Layer1 格子）
                                Point p1 = new Point(X, Y + 12);       // 左
                                Point p2 = new Point(X + 24, Y);       // 上
                                Point p3 = new Point(X + 48, Y + 12);  // 右
                                Point p4 = new Point(X + 24, Y + 24);  // 下

                                // 繪製菱形的四條邊
                                g.DrawLine(currentPen, p1, p2);  // 左上邊
                                g.DrawLine(currentPen, p2, p3);  // 右上邊
                                g.DrawLine(currentPen, p3, p4);  // 右下邊
                                g.DrawLine(currentPen, p4, p1);  // 左下邊
                            }
                        }
                    }
                }
            }
        }

        // 繪製座標標籤 - 渲染整張地圖的所有 S32
        private void DrawCoordinateLabels(Bitmap bitmap, Struct.L1Map currentMap)
        {
            using (Graphics g = GraphicsHelper.FromImage(bitmap))
            {
                g.SetSmoothingMode(SmoothingMode.AntiAlias);
                g.SetTextRenderingHint(TextRenderingHint.ClearTypeGridFit);

                Font font = new Font("Arial", 8, FontStyle.Bold);

                // 每隔 10 格顯示一次座標（可調整間隔）
                int interval = 10;

                // 遍歷所有 S32 檔案
                foreach (var s32Data in _document.S32Files.Values)
                {
                    // 使用 GetLoc 計算區塊位置
                    int[] loc = s32Data.SegInfo.GetLoc(1.0);
                    int mx = loc[0];
                    int my = loc[1];

                    for (int y = 0; y < 64; y += interval)
                    {
                        for (int x = 0; x < 128; x += interval)
                        {
                            // 使用 GetLoc + drawTilBlock 公式計算像素位置
                            int localBaseX = 0;
                            int localBaseY = 63 * 12;
                            localBaseX -= 24 * (x / 2);
                            localBaseY -= 12 * (x / 2);

                            int X = mx + localBaseX + x * 24 + y * 24;
                            int Y = my + localBaseY + y * 12;

                            // 計算實際遊戲座標 (Layer1 座標轉遊戲座標)
                            int gameX = s32Data.SegInfo.nLinBeginX + x / 2;
                            int gameY = s32Data.SegInfo.nLinBeginY + y;

                            // 繪製座標文字
                            string coordText = $"{gameX},{gameY}";
                            SizeF textSize = g.MeasureString(coordText, font);

                            // 繪製背景（半透明白色）
                            int textX = X + 12 - (int)textSize.Width / 2;
                            int textY = Y + 12 - (int)textSize.Height / 2;

                            using (SolidBrush bgBrush = new SolidBrush(ColorExtensions.FromArgb(180, Colors.White)))
                            {
                                g.FillRectangle(bgBrush, textX - 2, textY - 1, textSize.Width + 4, textSize.Height + 2);
                            }

                            // 繪製座標文字（藍色）
                            using (SolidBrush textBrush = new SolidBrush(Colors.Blue))
                            {
                                g.DrawString(coordText, font, textBrush, textX, textY);
                            }
                        }
                    }
                }

                font.Dispose();
            }
        }

        #region Viewport 版本的繪圖方法

        // 繪製第三層屬性（Viewport 版本）
        // 根據客戶端邏輯，整個格子使用 Attribute1 判斷
        private void DrawLayer3AttributesViewport(Graphics g, Struct.L1Map currentMap, Rectangle worldRect)
        {
            g.SetSmoothingMode(SmoothingMode.AntiAlias);

            foreach (var s32Data in _document.S32Files.Values)
            {
                int[] loc = s32Data.SegInfo.GetLoc(1.0);
                int mx = loc[0];
                int my = loc[1];

                for (int y = 0; y < 64; y++)
                {
                    for (int x = 0; x < 64; x++)
                    {
                        var attr = s32Data.Layer3[y, x];
                        if (attr == null) continue;
                        // 只有當兩個屬性都為0時才跳過
                        if (attr.Attribute1 == 0 && attr.Attribute2 == 0) continue;

                        int x1 = x * 2;
                        int localBaseX = 0 - 24 * (x1 / 2);
                        int localBaseY = 63 * 12 - 12 * (x1 / 2);

                        int X = mx + localBaseX + x1 * 24 + y * 24 - worldRect.X;
                        int Y = my + localBaseY + y * 12 - worldRect.Y;

                        // 跳過不在 Viewport 內的格子
                        if (X + 48 < 0 || X > worldRect.Width || Y + 24 < 0 || Y > worldRect.Height)
                            continue;

                        // 菱形的四個頂點
                        Point pTop = new Point(X + 24, Y + 0);
                        Point pRight = new Point(X + 48, Y + 12);
                        Point pBottom = new Point(X + 24, Y + 24);
                        Point pLeft = new Point(X + 0, Y + 12);
                        Point pCenter = new Point(X + 24, Y + 12);

                        // 左半邊 - 使用 Attribute1
                        if (attr.Attribute1 != 0)
                        {
                            Color color1 = GetAttributeColor(attr.Attribute1);
                            using (Pen pen = new Pen(color1, 3))
                            {
                                g.DrawLine(pen, pLeft, pTop);
                                g.DrawLine(pen, pTop, pCenter);
                                g.DrawLine(pen, pCenter, pBottom);
                                g.DrawLine(pen, pBottom, pLeft);
                            }
                        }

                        // 右半邊 - 使用 Attribute2
                        if (attr.Attribute2 != 0)
                        {
                            Color color2 = GetAttributeColor(attr.Attribute2);
                            using (Pen pen = new Pen(color2, 3))
                            {
                                g.DrawLine(pen, pTop, pRight);
                                g.DrawLine(pen, pRight, pBottom);
                                g.DrawLine(pen, pBottom, pCenter);
                                g.DrawLine(pen, pCenter, pTop);
                            }
                        }
                    }
                }
            }
        }

        // 繪製通行性覆蓋層（Viewport 版本）
        // Attribute1 = 左半邊, Attribute2 = 右半邊
        private void DrawPassableOverlayViewport(Graphics g, Struct.L1Map currentMap, Rectangle worldRect)
        {
            g.SetSmoothingMode(SmoothingMode.AntiAlias);

            // Layer3 每個格子分成兩個三角形：
            // Attribute1 = 左上三角形, Attribute2 = 右上三角形
            using (Pen penImpassable = new Pen(Color.FromArgb(255, 128, 0, 128), 3))
            using (Pen penPassable = new Pen(Color.FromArgb(255, 50, 200, 255), 2))
            {
                foreach (var s32Data in _document.S32Files.Values)
                {
                    int[] loc = s32Data.SegInfo.GetLoc(1.0);
                    int mx = loc[0];
                    int my = loc[1];

                    for (int y = 0; y < 64; y++)
                    {
                        for (int x = 0; x < 64; x++)
                        {
                            var attr = s32Data.Layer3[y, x];
                            if (attr == null) continue;

                            int x1 = x * 2;
                            int localBaseX = 0 - 24 * (x1 / 2);
                            int localBaseY = 63 * 12 - 12 * (x1 / 2);

                            int X = mx + localBaseX + x1 * 24 + y * 24 - worldRect.X;
                            int Y = my + localBaseY + y * 12 - worldRect.Y;

                            // 跳過不在 Viewport 內的格子
                            if (X + 48 < 0 || X > worldRect.Width || Y + 24 < 0 || Y > worldRect.Height)
                                continue;

                            // 菱形的頂點
                            Point pTop = new Point(X + 24, Y + 0);
                            Point pRight = new Point(X + 48, Y + 12);
                            Point pLeft = new Point(X + 0, Y + 12);

                            // 左上邊線 - 使用 Attribute1 判斷
                            Pen pen1 = (attr.Attribute1 & 0x01) != 0 ? penImpassable : penPassable;
                            g.DrawLine(pen1, pLeft, pTop);

                            // 右上邊線 - 使用 Attribute2 判斷
                            Pen pen2 = (attr.Attribute2 & 0x01) != 0 ? penImpassable : penPassable;
                            g.DrawLine(pen2, pTop, pRight);
                        }
                    }
                }
            }
        }

        // 繪製區域覆蓋層（Viewport 版本）
        // Attribute1 = 左半邊, Attribute2 = 右半邊（與通行性繪製一致）
        private void DrawRegionsOverlayViewport(Graphics g, Struct.L1Map currentMap, Rectangle worldRect, bool showSafe, bool showCombat)
        {

            // 定義區域顏色（半透明）
            // 安全區：藍色，戰鬥區：紅色
            using (Brush safeBrush = new SolidBrush(Color.FromArgb(80, 0, 150, 255)))       // 藍色
            using (Brush combatBrush = new SolidBrush(Color.FromArgb(80, 255, 50, 50)))     // 紅色
            {
                foreach (var s32Data in _document.S32Files.Values)
                {
                    int[] loc = s32Data.SegInfo.GetLoc(1.0);
                    int mx = loc[0];
                    int my = loc[1];

                    for (int y = 0; y < 64; y++)
                    {
                        for (int x = 0; x < 64; x++)
                        {
                            var attr = s32Data.Layer3[y, x];
                            if (attr == null) continue;

                            int x1 = x * 2;
                            int localBaseX = 0 - 24 * (x1 / 2);
                            int localBaseY = 63 * 12 - 12 * (x1 / 2);

                            int X = mx + localBaseX + x1 * 24 + y * 24 - worldRect.X;
                            int Y = my + localBaseY + y * 12 - worldRect.Y;

                            // 跳過不在 Viewport 內的格子
                            if (X + 48 < 0 || X > worldRect.Width || Y + 24 < 0 || Y > worldRect.Height)
                                continue;

                            // 菱形的四個頂點
                            Point pTop = new Point(X + 24, Y + 0);
                            Point pRight = new Point(X + 48, Y + 12);
                            Point pBottom = new Point(X + 24, Y + 24);
                            Point pLeft = new Point(X + 0, Y + 12);

                            // 檢查區域類型（根據 MapTool 邏輯，客戶端只用 Attribute1 判斷整個格子）
                            // 低4位: 0-3=一般, 4-7/C-F=安全(bit2), 8-B=戰鬥(bit3且非bit2)
                            int val = attr.Attribute1 & 0x0F;
                            bool isSafe = (val & 0x04) != 0;  // bit 2 設定 = 安全區
                            bool isCombat = (val & 0x0C) == 0x08;  // bit 3 設定但 bit 2 未設定 = 戰鬥區

                            // 決定整個格子的顏色
                            Brush regionBrush = null;
                            if (isCombat && showCombat)
                                regionBrush = combatBrush;
                            else if (isSafe && showSafe)
                                regionBrush = safeBrush;

                            if (regionBrush != null)
                            {
                                // 繪製整個菱形
                                Point[] diamond = new Point[] { pTop, pRight, pBottom, pLeft };
                                g.FillPolygon(regionBrush, diamond);
                            }
                        }
                    }
                }
            }
        }

        // 繪製 Layer5 覆蓋層（透明圖塊標記）
        private void DrawLayer5OverlayViewport(Graphics g, Struct.L1Map currentMap, Rectangle worldRect, bool isLayer5Edit)
        {
            g.SetSmoothingMode(SmoothingMode.AntiAlias);

            // 收集所有 Layer5 位置（去重）
            var drawnPositions = new HashSet<(int mx, int my, int x, int y)>();

            // 半透明藍色填充和邊框
            using (SolidBrush fillBrush = new SolidBrush(Color.FromArgb(80, 60, 140, 255)))
            using (Pen borderPen = new Pen(Color.FromArgb(180, 80, 160, 255), 1.5f))
            using (Pen highlightPen = new Pen(Color.FromArgb(200, 150, 200, 255), 1f))
            {
                foreach (var s32Data in _document.S32Files.Values)
                {
                    // 只繪製已啟用的 S32
                    if (!_checkedS32Files.Contains(s32Data.FilePath)) continue;
                    if (s32Data.Layer5.Count == 0) continue;

                    int[] loc = s32Data.SegInfo.GetLoc(1.0);
                    int mx = loc[0];
                    int my = loc[1];

                    foreach (var item in s32Data.Layer5)
                    {
                        // 同位置只畫一次
                        var posKey = (mx, my, (int)item.X, (int)item.Y);
                        if (drawnPositions.Contains(posKey)) continue;
                        drawnPositions.Add(posKey);
                        // Layer5 的 X 是 0-127（Layer1 座標系），Y 是 0-63
                        // 繪製半格大小的三角形（X 切半）
                        int x1 = item.X;  // 0-127
                        int y = item.Y;   // 0-63

                        int localBaseX = 0 - 24 * (x1 / 2);
                        int localBaseY = 63 * 12 - 12 * (x1 / 2);

                        int X = mx + localBaseX + x1 * 24 + y * 24 - worldRect.X;
                        int Y = my + localBaseY + y * 12 - worldRect.Y;

                        // 跳過不在 Viewport 內的格子
                        if (X + 24 < 0 || X > worldRect.Width || Y + 12 < 0 || Y > worldRect.Height)
                            continue;

                        // 繪製半格三角形（根據 X 奇偶決定左半或右半）
                        Point[] triangle;
                        if (x1 % 2 == 0)
                        {
                            // 偶數 X：左半三角形
                            Point pLeft = new Point(X + 0, Y + 12);
                            Point pTop = new Point(X + 24, Y + 0);
                            Point pBottom = new Point(X + 24, Y + 24);
                            triangle = new Point[] { pLeft, pTop, pBottom };

                            // 填充
                            g.FillPolygon(fillBrush, triangle);
                            // 邊框（上亮下暗）
                            g.DrawLine(highlightPen, pLeft, pTop);
                            g.DrawLine(borderPen, pTop, pBottom);
                            g.DrawLine(borderPen, pBottom, pLeft);
                        }
                        else
                        {
                            // 奇數 X：右半三角形
                            Point pTop = new Point(X + 0, Y + 0);
                            Point pRight = new Point(X + 24, Y + 12);
                            Point pBottom = new Point(X + 0, Y + 24);
                            triangle = new Point[] { pTop, pRight, pBottom };

                            // 填充
                            g.FillPolygon(fillBrush, triangle);
                            // 邊框（上亮下暗）
                            g.DrawLine(highlightPen, pTop, pRight);
                            g.DrawLine(borderPen, pRight, pBottom);
                            g.DrawLine(borderPen, pBottom, pTop);
                        }
                    }
                }
            }

            // 在透明編輯模式下，繪製已設定 Layer5 的群組物件覆蓋層
            if (isLayer5Edit)
            {
                DrawLayer5GroupOverlay(g, worldRect);
            }
        }

        // 繪製群組高亮覆蓋層（綠色標記選取區域內群組的所有位置）
        private void DrawGroupHighlightOverlay(Graphics g, Rectangle worldRect, List<(int, int)> groupHighlightCells)
        {
            if (groupHighlightCells == null || groupHighlightCells.Count == 0)
                return;

            // 建立快速查找的 HashSet
            var highlightSet = new HashSet<(int, int)>(groupHighlightCells);

            g.SetSmoothingMode(SmoothingMode.AntiAlias);

            // 綠色半透明填充
            using (SolidBrush fillBrush = new SolidBrush(Color.FromArgb(100, 50, 200, 50)))
            using (Pen borderPen = new Pen(Color.FromArgb(200, 30, 180, 30), 2f))
            {
                foreach (var s32Data in _document.S32Files.Values)
                {
                    // 只繪製已啟用的 S32
                    if (!_checkedS32Files.Contains(s32Data.FilePath)) continue;

                    int[] loc = s32Data.SegInfo.GetLoc(1.0);
                    int mx = loc[0];
                    int my = loc[1];

                    int segStartX = s32Data.SegInfo.nLinBeginX * 2;
                    int segStartY = s32Data.SegInfo.nLinBeginY;

                    // 檢查此 S32 範圍內是否有高亮格子
                    for (int localY = 0; localY < 64; localY++)
                    {
                        for (int localX = 0; localX < 128; localX += 2)  // 每次跳 2（一格）
                        {
                            int globalX = segStartX + localX;
                            int globalY = segStartY + localY;

                            if (!highlightSet.Contains((globalX, globalY)))
                                continue;

                            // 計算像素位置（整格，包含左右兩半）
                            int x1 = localX;  // 偶數 X（左半）
                            int localBaseX = 0 - 24 * (x1 / 2);
                            int localBaseY = 63 * 12 - 12 * (x1 / 2);

                            int X = mx + localBaseX + x1 * 24 + localY * 24 - worldRect.X;
                            int Y = my + localBaseY + localY * 12 - worldRect.Y;

                            // 跳過不在 Viewport 內的格子
                            if (X + 48 < 0 || X > worldRect.Width || Y + 24 < 0 || Y > worldRect.Height)
                                continue;

                            // 繪製整格菱形
                            Point[] diamond = new Point[]
                            {
                                new Point(X + 24, Y),       // 上
                                new Point(X + 48, Y + 12),  // 右
                                new Point(X + 24, Y + 24),  // 下
                                new Point(X, Y + 12)        // 左
                            };

                            g.FillPolygon(fillBrush, diamond);
                            g.DrawPolygon(borderPen, diamond);
                        }
                    }
                }
            }
        }

        // 繪製已設定 Layer5 的群組物件覆蓋層
        private void DrawLayer5GroupOverlay(Graphics g, Rectangle worldRect)
        {
            // 只有在有選取格子時才顯示
            if (_editState.SelectedCells.Count == 0) return;

            // 從選取的格子收集 Layer5 的 GroupId 及其 Type
            var groupLayer5Info = new Dictionary<int, byte>(); // GroupId -> Type
            foreach (var selectedCell in _editState.SelectedCells)
            {
                var s32Data = selectedCell.S32Data;
                int localX = selectedCell.LocalX;  // Layer1 座標 (0-127)
                int localY = selectedCell.LocalY;  // Layer3 座標 (0-63)

                // 查找該格子位置對應的 Layer5 設定
                // Layer5 的 X 是 0-127，Y 是 0-63
                // selectedCell.LocalX 是 Layer1 座標 (0-127)，LocalY 是 (0-63)
                // 一個遊戲格子對應兩個 Layer1 X 座標（localX 和 localX+1）
                foreach (var item in s32Data.Layer5)
                {
                    if ((item.X == localX || item.X == localX + 1) && item.Y == localY)
                    {
                        // 如果同一個 GroupId 有多個設定，保留第一個
                        if (!groupLayer5Info.ContainsKey(item.ObjectIndex))
                        {
                            groupLayer5Info[item.ObjectIndex] = item.Type;
                        }
                    }
                }
            }

            if (groupLayer5Info.Count == 0) return;

            // 半透明覆蓋色：Type=0 紫色（高對比），Type=1 紅色
            using (SolidBrush type0Brush = new SolidBrush(Color.FromArgb(100, 180, 0, 255)))
            using (SolidBrush type1Brush = new SolidBrush(Color.FromArgb(100, 255, 80, 80)))
            {
                foreach (var s32Data in _document.S32Files.Values)
                {
                    // 只繪製已啟用的 S32
                    if (!_checkedS32Files.Contains(s32Data.FilePath)) continue;

                    int[] loc = s32Data.SegInfo.GetLoc(1.0);
                    int mx = loc[0];
                    int my = loc[1];

                    foreach (var obj in s32Data.Layer4)
                    {
                        // 檢查該群組是否有 Layer5 設定
                        if (!groupLayer5Info.TryGetValue(obj.GroupId, out byte type))
                            continue;

                        // 使用與高亮格子相同的座標計算方式
                        int x1 = obj.X;  // 0-127 (Layer1 座標系)
                        int y = obj.Y;   // 0-63

                        int localBaseX = 0 - 24 * (x1 / 2);
                        int localBaseY = 63 * 12 - 12 * (x1 / 2);

                        int X = mx + localBaseX + x1 * 24 + y * 24 - worldRect.X;
                        int Y = my + localBaseY + y * 12 - worldRect.Y;

                        // 跳過不在 Viewport 內的物件
                        if (X + 24 < 0 || X > worldRect.Width || Y + 24 < 0 || Y > worldRect.Height)
                            continue;

                        // 繪製半格菱形覆蓋（與格子高亮相同大小）
                        SolidBrush brush = type == 0 ? type0Brush : type1Brush;
                        Point[] diamond = new Point[]
                        {
                            new Point(X + 0, Y + 12),   // 左
                            new Point(X + 12, Y + 0),   // 上
                            new Point(X + 24, Y + 12),  // 右
                            new Point(X + 12, Y + 24)   // 下
                        };
                        g.FillPolygon(brush, diamond);
                    }
                }
            }
        }

        // 繪製選中格子的高亮（Viewport 版本）
        private void DrawHighlightedCellViewport(Graphics g, Rectangle worldRect, L1MapViewer.Models.S32Data highlightedS32Data, int highlightedCellX, int highlightedCellY)
        {
            if (highlightedS32Data == null) return;

            g.SetSmoothingMode(SmoothingMode.AntiAlias);

            int[] loc = highlightedS32Data.SegInfo.GetLoc(1.0);
            int mx = loc[0];
            int my = loc[1];

            int localBaseX = 0 - 24 * (highlightedCellX / 2);
            int localBaseY = 63 * 12 - 12 * (highlightedCellX / 2);

            int X = mx + localBaseX + highlightedCellX * 24 + highlightedCellY * 24 - worldRect.X;
            int Y = my + localBaseY + highlightedCellY * 12 - worldRect.Y;

            Point p1 = new Point(X + 0, Y + 12);
            Point p2 = new Point(X + 12, Y + 0);
            Point p3 = new Point(X + 24, Y + 12);
            Point p4 = new Point(X + 12, Y + 24);

            using (SolidBrush brush = new SolidBrush(Color.FromArgb(120, 255, 255, 0)))
            {
                g.FillPolygon(brush, new Point[] { p1, p2, p3, p4 });
            }

            using (Pen pen = new Pen(Color.FromArgb(255, 255, 200, 0), 3))
            {
                g.DrawPolygon(pen, new Point[] { p1, p2, p3, p4 });
            }
        }

        // 繪製 Layer8 標記和啟用的 SPR 動畫
        private void DrawLayer8MarkersAndSprites(Bitmap bitmap, Rectangle worldRect)
        {
            int totalLayer8Count = 0;
            int drawnCount = 0;

            using (Graphics g = GraphicsHelper.FromImage(bitmap))
            {
                g.SetSmoothingMode(SmoothingMode.AntiAlias);

                // 繪製所有 Layer8 項目的標記
                foreach (var s32Data in _document.S32Files.Values)
                {
                    totalLayer8Count += s32Data.Layer8.Count;
                    if (s32Data.Layer8.Count == 0) continue;

                    int[] loc = s32Data.SegInfo.GetLoc(1.0);
                    int mx = loc[0];
                    int my = loc[1];

                    for (int i = 0; i < s32Data.Layer8.Count; i++)
                    {
                        var item = s32Data.Layer8[i];

                        // Layer8 X,Y 是絕對遊戲座標，先轉為本地座標
                        int localLayer3X = item.X - s32Data.SegInfo.nLinBeginX;  // 0~63
                        int localLayer3Y = item.Y - s32Data.SegInfo.nLinBeginY;  // 0~63

                        // 跳過超出範圍的項目
                        if (localLayer3X < 0 || localLayer3X > 63 || localLayer3Y < 0 || localLayer3Y > 63)
                            continue;

                        // 轉為 Layer1 座標並計算世界像素座標
                        int layer1X = localLayer3X * 2;  // 0~127
                        int layer1Y = localLayer3Y;       // 0~63

                        int baseX = -24 * (layer1X / 2);
                        int baseY = 63 * 12 - 12 * (layer1X / 2);
                        int worldX = mx + baseX + layer1X * 24 + layer1Y * 24;
                        int worldY = my + baseY + layer1Y * 12;

                        // 轉為畫布座標（格子中心）
                        int x = worldX - worldRect.X + 12;
                        int y = worldY - worldRect.Y + 12;

                        // 檢查是否在可見範圍內
                        if (x < -50 || x > bitmap.Width + 50 || y < -50 || y > bitmap.Height + 50)
                            continue;

                        bool isEnabled = _editState.EnabledLayer8Items.Contains((s32Data.FilePath, i));

                        // 繪製標記（圓點）- 受 ShowLayer8Marker 控制
                        // 啟用時：灰色半透明 (opacity 0.1)，在 SPR 下面
                        // 停用時：橙色實心
                        int markerRadius = 10;

                        if (_viewState.ShowLayer8Marker)
                        {
                            if (isEnabled)
                            {
                                // 啟用狀態：先畫灰色半透明 marker
                                using (SolidBrush brush = new SolidBrush(Color.FromArgb(25, 128, 128, 128)))
                                {
                                    g.FillEllipse(brush, x - markerRadius, y - markerRadius, markerRadius * 2, markerRadius * 2);
                                }
                                using (Pen pen = new Pen(Color.FromArgb(50, 255, 255, 255)))
                                {
                                    g.DrawEllipse(pen, x - markerRadius, y - markerRadius, markerRadius * 2, markerRadius * 2);
                                }
                            }
                            else
                            {
                                // 停用狀態：橙色實心 marker
                                using (SolidBrush brush = new SolidBrush(Colors.Orange))
                                {
                                    g.FillEllipse(brush, x - markerRadius, y - markerRadius, markerRadius * 2, markerRadius * 2);
                                }
                                g.DrawEllipse(Pens.White, x - markerRadius, y - markerRadius, markerRadius * 2, markerRadius * 2);

                                // 只有停用狀態才顯示 SprId
                                using (Font font = new Font("Arial", 8, FontStyle.Bold))
                                {
                                    g.DrawString(item.SprId.ToString(), font, Brushes.White, x + markerRadius + 2, y - 6);
                                }
                            }
                        }

                        // 繪製 SPR 動畫 - 受 ShowLayer8Spr 控制
                        if (_viewState.ShowLayer8Spr && isEnabled)
                        {
                            DrawLayer8Sprite(g, item.SprId, x, y, s32Data.FilePath, i);
                        }
                        drawnCount++;
                    }
                }
            }

            Console.WriteLine($"[Layer8] totalLayer8Count={totalLayer8Count}, drawnCount={drawnCount}, worldRect={worldRect}");
        }

        // 繪製單個 Layer8 SPR 動畫帧
        private void DrawLayer8Sprite(Graphics g, int sprId, int x, int y, string s32Path, int itemIndex)
        {
            // 載入 SPR 帧（如果還沒載入）
            if (!_renderCache.Layer8SprCache.TryGetValue(sprId, out var frames))
            {
                frames = LoadLayer8SprFrames(sprId);
                _renderCache.Layer8SprCache[sprId] = frames;
            }

            if (frames == null || frames.Count == 0) return;

            // 取得當前帧索引
            var key = (s32Path, itemIndex);
            if (!_renderCache.Layer8AnimFrame.TryGetValue(key, out int frameIdx))
            {
                frameIdx = 0;
                _renderCache.Layer8AnimFrame[key] = 0;
            }

            var frame = frames[frameIdx % frames.Count];

            // 繪製 SPR（使用 SPR 檔案中的 offset）
            // 與 Rust 一致: start_x = center_x + frame.offset_x
            int drawX = x + frame.XOffset;
            int drawY = y + frame.YOffset;
            g.DrawImage(frame.Image, drawX, drawY);
        }

        // 載入 Layer8 SPR 帧（支援多 idx 檔案，保留 offset）
        private List<L1MapViewer.Models.Layer8Frame> LoadLayer8SprFrames(int sprId)
        {
            string sprKey = $"{sprId}-0.spr";

            // 依序嘗試不同的 idx 檔案
            string[] idxTypes = new[] {
                "Sprite",
                "Sprite00", "Sprite01", "Sprite02", "Sprite03",
                "Sprite04", "Sprite05", "Sprite06", "Sprite07",
                "Sprite08", "Sprite09", "Sprite10", "Sprite11",
                "Sprite12", "Sprite13", "Sprite14", "Sprite15"
            };

            foreach (var idxType in idxTypes)
            {
                try
                {
                    byte[] sprData = L1PakReader.UnPack(idxType, sprKey);
                    if (sprData != null && sprData.Length > 0)
                    {
                        var rawFrames = Lin.Helper.Core.Sprite.SprReader.LoadRaw(sprData);
                        if (rawFrames != null && rawFrames.Length > 0)
                        {
                            var result = new List<L1MapViewer.Models.Layer8Frame>();
                            foreach (var f in rawFrames)
                            {
                                if (f.Width > 0 && f.Height > 0 && f.Pixels != null)
                                {
                                    result.Add(new L1MapViewer.Models.Layer8Frame
                                    {
                                        Image = CreateBitmapFromRgbaLayer8(f.Pixels, f.Width, f.Height),
                                        XOffset = f.XOffset,
                                        YOffset = f.YOffset
                                    });
                                }
                            }
                            if (result.Count > 0)
                                return result;
                        }
                    }
                }
                catch { }
            }

            return new List<L1MapViewer.Models.Layer8Frame>();  // 找不到
        }

        // 將 RGBA 像素轉換為 BGRA 並建立 Bitmap（Layer8 用）
        private Bitmap CreateBitmapFromRgbaLayer8(byte[] rgbaPixels, int width, int height)
        {
            byte[] bgraPixels = new byte[rgbaPixels.Length];
            for (int i = 0; i < rgbaPixels.Length; i += 4)
            {
                bgraPixels[i + 0] = rgbaPixels[i + 2]; // B <- R
                bgraPixels[i + 1] = rgbaPixels[i + 1]; // G <- G
                bgraPixels[i + 2] = rgbaPixels[i + 0]; // R <- B
                bgraPixels[i + 3] = rgbaPixels[i + 3]; // A <- A
            }
            Bitmap bmp = new Bitmap(width, height, PixelFormat.Format32bppArgb);
            var bmpData = bmp.LockBits(new Rectangle(0, 0, width, height), ImageLockMode.WriteOnly, PixelFormat.Format32bppArgb);
            System.Runtime.InteropServices.Marshal.Copy(bgraPixels, 0, bmpData.Scan0, bgraPixels.Length);
            bmp.UnlockBits(bmpData);
            return bmp;
        }

        // [S32ScreenToWorld 已移至 MapForm.Coordinates.cs]

        // 查找點擊位置的 Layer8 標記
        private (string s32Path, int index)? FindLayer8MarkerAtPosition(int worldX, int worldY)
        {
            const int hitRadius = 20;  // 標記點擊範圍（加大）
            Console.WriteLine($"[Layer8-Click] Finding marker at world ({worldX}, {worldY})");

            foreach (var s32Data in _document.S32Files.Values)
            {
                if (s32Data.Layer8.Count == 0) continue;

                int[] loc = s32Data.SegInfo.GetLoc(1.0);
                int mx = loc[0];
                int my = loc[1];

                for (int i = 0; i < s32Data.Layer8.Count; i++)
                {
                    var item = s32Data.Layer8[i];

                    // Layer8 X,Y 是絕對遊戲座標，先轉為本地座標
                    int localLayer3X = item.X - s32Data.SegInfo.nLinBeginX;
                    int localLayer3Y = item.Y - s32Data.SegInfo.nLinBeginY;

                    if (localLayer3X < 0 || localLayer3X > 63 || localLayer3Y < 0 || localLayer3Y > 63)
                        continue;

                    int layer1X = localLayer3X * 2;
                    int layer1Y = localLayer3Y;

                    int baseX = -24 * (layer1X / 2);
                    int baseY = 63 * 12 - 12 * (layer1X / 2);
                    // 渲染時畫布座標 = worldX - worldRect.X + 12
                    // 所以標記的世界座標中心是 worldX + 12, worldY + 12
                    int markerWorldX = mx + baseX + layer1X * 24 + layer1Y * 24 + 12;
                    int markerWorldY = my + baseY + layer1Y * 12 + 12;

                    // 檢查是否在點擊範圍內
                    int dx = worldX - markerWorldX;
                    int dy = worldY - markerWorldY;
                    int distSq = dx * dx + dy * dy;

                    if (distSq <= hitRadius * hitRadius)
                    {
                        Console.WriteLine($"[Layer8-Click] HIT! marker at ({markerWorldX},{markerWorldY}), dist={Math.Sqrt(distSq):F1}");
                        return (s32Data.FilePath, i);
                    }
                }
            }

            Console.WriteLine($"[Layer8-Click] No marker found");
            return null;
        }

        // 繪製 S32 邊界框（Viewport 版本）
        private void DrawS32BoundaryOnlyViewport(Graphics g, Struct.L1Map currentMap, Rectangle worldRect)
        {
            g.SetSmoothingMode(SmoothingMode.AntiAlias);
            g.SetTextRenderingHint(TextRenderingHint.ClearTypeGridFit);

            Font font = new Font("Arial", 9, FontStyle.Bold);
            Pen boundaryPen = new Pen(Colors.Cyan, 2);

            foreach (var s32Data in _document.S32Files.Values)
            {
                int[] loc = s32Data.SegInfo.GetLoc(1.0);
                int mx = loc[0];
                int my = loc[1];

                Point[] corners = new Point[4];
                int[][] cornerCoords = new int[][] {
                    new int[] { 0, 0 },
                    new int[] { 64, 0 },
                    new int[] { 64, 64 },
                    new int[] { 0, 64 }
                };

                for (int i = 0; i < 4; i++)
                {
                    int x3 = cornerCoords[i][0];
                    int y = cornerCoords[i][1];
                    int x = x3 * 2;

                    int localBaseX = 0 - 24 * (x / 2);
                    int localBaseY = 63 * 12 - 12 * (x / 2);
                    int X = mx + localBaseX + x * 24 + y * 24 - worldRect.X;
                    int Y = my + localBaseY + y * 12 - worldRect.Y;

                    corners[i] = new Point(X, Y + 12);
                }

                g.DrawLine(boundaryPen, corners[0], corners[1]);
                g.DrawLine(boundaryPen, corners[1], corners[2]);
                g.DrawLine(boundaryPen, corners[2], corners[3]);
                g.DrawLine(boundaryPen, corners[3], corners[0]);

                int centerX = (corners[0].X + corners[2].X) / 2;
                int centerY = (corners[0].Y + corners[2].Y) / 2;
                string centerText = $"GetLoc({mx},{my})\n{s32Data.SegInfo.nLinBeginX},{s32Data.SegInfo.nLinBeginY}~{s32Data.SegInfo.nLinEndX},{s32Data.SegInfo.nLinEndY}";
                using (SolidBrush cb = new SolidBrush(ColorExtensions.FromArgb(200, Colors.Black)))
                using (SolidBrush ct = new SolidBrush(Colors.Lime))
                {
                    SizeF cs = g.MeasureString(centerText, font);
                    g.FillRectangle(cb, centerX - cs.Width/2 - 2, centerY - cs.Height/2 - 1, cs.Width + 4, cs.Height + 2);
                    g.DrawString(centerText, font, ct, centerX - cs.Width/2, centerY - cs.Height/2);
                }
            }

            font.Dispose();
            boundaryPen.Dispose();
        }

        // 繪製格線（Viewport 版本）- 擴展範圍: X 0-255, Y 0-127
        private void DrawS32GridViewport(Graphics g, Struct.L1Map currentMap, Rectangle worldRect)
        {
            var totalSw = System.Diagnostics.Stopwatch.StartNew();

            // 使用長線繪製 Grid，而不是每個格子畫 4 條短線
            // 菱形格子的網格由兩組平行斜線組成：
            // - "/" 方向線：斜率 = 12/24 = 0.5（從左下往右上）
            // - "\" 方向線：斜率 = -12/24 = -0.5（從左上往右下）

            var s32FilesSnapshot = _document.S32Files.Values.ToList();
            _logger.Debug($"[GRID-DETAIL] ToList took {totalSw.ElapsedMilliseconds}ms, S32 count: {s32FilesSnapshot.Count}");

            using (Pen gridPen = new Pen(ColorExtensions.FromArgb(100, Colors.Red), 2))
            {
                _logger.Debug($"[GRID-DETAIL] Pen creation took {totalSw.ElapsedMilliseconds}ms");
                int totalLinesDrawn = 0;
                var drawSw = System.Diagnostics.Stopwatch.StartNew();

                    foreach (var s32Data in s32FilesSnapshot)
                    {
                        int[] loc = s32Data.SegInfo.GetLoc(1.0);
                        int mx = loc[0];
                        int my = loc[1];

                        // 只畫正常範圍 (64x64 格子) 的 Grid
                        // 計算 S32 區塊的四個角點（世界像素座標）
                        // 格子 (0,0) 的左頂點
                        int baseX0 = 0;
                        int baseY0 = 63 * 12;
                        int corner0X = mx + baseX0 - worldRect.X;
                        int corner0Y = my + baseY0 + 12 - worldRect.Y;

                        // 每格寬 24 像素（水平方向），高 12 像素（垂直方向）
                        // 菱形格子的 Layer1 座標 x 範圍 0-127，y 範圍 0-63
                        // 但遊戲座標 x3 範圍 0-63 (Layer1 x = x3 * 2)

                        // 繪製 "/" 方向的線（沿著 y 方向的邊）
                        // 這些線從 x3=0 的格子左邊緣，到 x3=63 的格子右邊緣
                        // 總共需要 65 條線（包括最左和最右的邊界）
                        for (int i = 0; i <= 64; i++)
                        {
                            // 線的起點：y=0, x3=i 的格子的上頂點
                            // 線的終點：y=63, x3=i 的格子的下頂點
                            int x3 = i;
                            int x = x3 * 2;

                            // 起點 (y=0 時的上頂點)
                            int startLocalBaseX = -24 * (x / 2);
                            int startLocalBaseY = 63 * 12 - 12 * (x / 2);
                            int startX = mx + startLocalBaseX + x * 24 + 0 * 24 + 24 - worldRect.X; // +24 是到上頂點
                            int startY = my + startLocalBaseY + 0 * 12 - worldRect.Y;

                            // 終點 (y=63 時的右頂點) = (X+48, Y+12)
                            int endX = mx + startLocalBaseX + x * 24 + 63 * 24 + 48 - worldRect.X;
                            int endY = my + startLocalBaseY + 63 * 12 + 12 - worldRect.Y;

                            // 檢查是否在 viewport 內
                            if (endX >= 0 && startX <= worldRect.Width &&
                                Math.Max(startY, endY) >= 0 && Math.Min(startY, endY) <= worldRect.Height)
                            {
                                g.DrawLine(gridPen, startX, startY, endX, endY);
                                totalLinesDrawn++;
                            }
                        }

                        // 繪製 "\" 方向的線（沿著 x 方向的邊）
                        // 總共需要 65 條線
                        for (int j = 0; j <= 64; j++)
                        {
                            int y = j;

                            // 起點 (x3=0 時的左頂點)
                            int x = 0;
                            int startLocalBaseX = -24 * (x / 2);
                            int startLocalBaseY = 63 * 12 - 12 * (x / 2);
                            int startX = mx + startLocalBaseX + x * 24 + y * 24 - worldRect.X;
                            int startY = my + startLocalBaseY + y * 12 + 12 - worldRect.Y; // +12 是到左頂點

                            // 終點 (x3=63 時的上頂點) = (X+24, Y)
                            x = 63 * 2;
                            int endLocalBaseX = -24 * (x / 2);
                            int endLocalBaseY = 63 * 12 - 12 * (x / 2);
                            int endX = mx + endLocalBaseX + x * 24 + y * 24 + 24 - worldRect.X;
                            int endY = my + endLocalBaseY + y * 12 - worldRect.Y;

                            // 檢查是否在 viewport 內
                            if (endX >= 0 && startX <= worldRect.Width &&
                                Math.Max(startY, endY) >= 0 && Math.Min(startY, endY) <= worldRect.Height)
                            {
                                g.DrawLine(gridPen, startX, startY, endX, endY);
                                totalLinesDrawn++;
                            }
                        }
                    }

                _logger.Debug($"[GRID-DETAIL] DrawLine loop took {drawSw.ElapsedMilliseconds}ms, lines drawn: {totalLinesDrawn}");
            }
            _logger.Debug($"[GRID-DETAIL] Total time: {totalSw.ElapsedMilliseconds}ms");
        }

        // 繪製座標標籤（Viewport 版本）
        private void DrawCoordinateLabelsViewport(Graphics g, Struct.L1Map currentMap, Rectangle worldRect)
        {
            g.SetSmoothingMode(SmoothingMode.AntiAlias);
            g.SetTextRenderingHint(TextRenderingHint.ClearTypeGridFit);

            Font font = new Font("Arial", 8, FontStyle.Bold);
            int interval = 10;

            foreach (var s32Data in _document.S32Files.Values)
            {
                int[] loc = s32Data.SegInfo.GetLoc(1.0);
                int mx = loc[0];
                int my = loc[1];

                for (int y = 0; y < 64; y += interval)
                {
                    for (int x = 0; x < 128; x += interval)
                    {
                        int localBaseX = 0 - 24 * (x / 2);
                        int localBaseY = 63 * 12 - 12 * (x / 2);

                        int X = mx + localBaseX + x * 24 + y * 24 - worldRect.X;
                        int Y = my + localBaseY + y * 12 - worldRect.Y;

                        // 跳過不在 Viewport 內的格子
                        if (X + 24 < 0 || X > worldRect.Width || Y + 24 < 0 || Y > worldRect.Height)
                            continue;

                        int gameX = s32Data.SegInfo.nLinBeginX + x / 2;  // Layer1 座標轉遊戲座標
                        int gameY = s32Data.SegInfo.nLinBeginY + y;

                        string coordText = $"{gameX},{gameY}";
                        SizeF textSize = g.MeasureString(coordText, font);

                        int textX = X + 12 - (int)textSize.Width / 2;
                        int textY = Y + 12 - (int)textSize.Height / 2;

                        using (SolidBrush bgBrush = new SolidBrush(ColorExtensions.FromArgb(180, Colors.White)))
                        {
                            g.FillRectangle(bgBrush, textX - 2, textY - 1, textSize.Width + 4, textSize.Height + 2);
                        }

                        using (SolidBrush textBrush = new SolidBrush(Colors.Blue))
                        {
                            g.DrawString(coordText, font, textBrush, textX, textY);
                        }
                    }
                }
            }

            font.Dispose();
        }

        #endregion

        // 繪製 Tile 到緩衝區（直接使用像素座標）- RGB565 版本（用於 SkiaSharp SKColorType.Rgb565）
        private unsafe void DrawTilToBufferDirect565(int pixelX, int pixelY, int tileId, int indexId, int rowpix, byte* ptr, int maxWidth, int maxHeight)
        {
            try
            {
                // 使用 TileProvider 取得 til 資料（自動處理 override 和備援）
                var tilArray = TileProvider.Instance.GetTilArrayWithFallback(tileId, indexId, pixelX, out indexId);
                if (tilArray == null || indexId < 0 || indexId >= tilArray.Count) return;
                byte[] tilData = tilArray[indexId];
                if (tilData == null) return;

                // 使用 Lin.Helper.Core.L1Til 渲染 RGB565，支援 type 6/7 半透明效果
                Lin.Helper.Core.Tile.L1Til.RenderBlockDirectRgb565(tilData, pixelX, pixelY, ptr, rowpix, maxWidth, maxHeight, applyTypeAlpha: true);
            }
            catch
            {
                // 忽略錯誤
            }
        }

        // 繪製 Tile 到緩衝區（直接使用像素座標）- RGB555 版本（用於 PixelFormat.Format16bppRgb555）
        private unsafe void DrawTilToBufferDirect555(int pixelX, int pixelY, int tileId, int indexId, int rowpix, byte* ptr, int maxWidth, int maxHeight)
        {
            try
            {
                // 使用 TileProvider 取得 til 資料（自動處理 override 和備援）
                var tilArray = TileProvider.Instance.GetTilArrayWithFallback(tileId, indexId, pixelX, out indexId);
                if (tilArray == null || indexId < 0 || indexId >= tilArray.Count) return;
                byte[] tilData = tilArray[indexId];
                if (tilData == null) return;

                // 使用 Lin.Helper.Core.L1Til 渲染 RGB555，支援 type 6/7 半透明效果
                Lin.Helper.Core.Tile.L1Til.RenderBlockDirect(tilData, pixelX, pixelY, ptr, rowpix, maxWidth, maxHeight, applyTypeAlpha: true);
            }
            catch
            {
                // 忽略錯誤
            }
        }

        // 快取聚合的 Tile 資料（避免每次搜尋都重新計算）
        private Dictionary<int, TileInfo> cachedAggregatedTiles = new Dictionary<int, TileInfo>();

        // 更新 Tile 清單顯示 - 統計所有 S32 檔案的 tiles
        private void UpdateTileList()
        {
            UpdateTileList(null);  // 不帶搜尋條件
        }

        /// <summary>
        /// 背景載入 Tile 列表
        /// </summary>
        private void UpdateTileListAsync()
        {
            Task.Run(() =>
            {
                var sw = Stopwatch.StartNew();

                // 聚合所有 S32 檔案的 UsedTiles（在背景執行緒）
                var aggregatedTiles = new Dictionary<int, TileInfo>();
                foreach (var s32Data in _document.S32Files.Values)
                {
                    foreach (var tileKvp in s32Data.UsedTiles)
                    {
                        int tileId = tileKvp.Key;
                        var tileInfo = tileKvp.Value;

                        if (aggregatedTiles.ContainsKey(tileId))
                        {
                            aggregatedTiles[tileId].UsageCount += tileInfo.UsageCount;
                        }
                        else
                        {
                            aggregatedTiles[tileId] = new TileInfo
                            {
                                TileId = tileInfo.TileId,
                                IndexId = tileInfo.IndexId,
                                UsageCount = tileInfo.UsageCount,
                                Thumbnail = null
                            };
                        }
                    }

                    // 加入 Layer2 的 Tiles
                    foreach (var item in s32Data.Layer2)
                    {
                        if (item.TileId <= 0) continue;
                        if (aggregatedTiles.ContainsKey(item.TileId))
                        {
                            aggregatedTiles[item.TileId].UsageCount++;
                        }
                        else
                        {
                            aggregatedTiles[item.TileId] = new TileInfo
                            {
                                TileId = item.TileId,
                                IndexId = item.IndexId,
                                UsageCount = 1,
                                Thumbnail = null
                            };
                        }
                    }
                }

                // 預先載入所有縮圖（在背景執行緒）
                foreach (var tile in aggregatedTiles.Values)
                {
                    if (tile.Thumbnail == null)
                    {
                        tile.Thumbnail = LoadTileThumbnail(tile.TileId, tile.IndexId);
                    }
                }

                sw.Stop();
                LogPerf($"[TILELIST] total={sw.ElapsedMilliseconds}ms | tiles={aggregatedTiles.Count}");

                // 回到 UI 執行緒更新列表
                this.BeginInvoke((MethodInvoker)delegate
                {
                    cachedAggregatedTiles = aggregatedTiles;

                    lvTiles.BeginUpdate();  // 暫停重繪
                    try
                    {
                        lvTiles.Items.Clear();

                        ImageList imageList = new ImageList();
                        imageList.ImageSize = new Size(48, 48);
                        imageList.ColorDepth = ColorDepth.Depth32Bit;
                        lvTiles.LargeImageList = imageList;

                        // 批量準備項目
                        var items = new List<IconTextListItem>();
                        int index = 0;
                        foreach (var tileKvp in aggregatedTiles.OrderBy(t => t.Key))
                        {
                            var tile = tileKvp.Value;
                            if (tile.Thumbnail != null)
                            {
                                imageList.Images.Add(tile.Thumbnail);

                                // 檢查是否為 R 版
                                bool isRemaster = TileProvider.Instance.IsRemaster(tile.TileId);
                                string rMark = isRemaster ? "(R)" : "";

                                var item = new IconTextListItem
                                {
                                    Text = $"ID:{tile.TileId}{rMark}\n×{tile.UsageCount}",
                                    ImageIndex = index,
                                    Tag = tile
                                };
                                items.Add(item);
                                index++;
                            }
                        }

                        // 批量添加
                        lvTiles.Items.AddRange(items);
                    }
                    finally
                    {
                        lvTiles.EndUpdate();  // 恢復重繪
                    }

                    lblTileList.Text = string.Format(LocalizationManager.L("Label_TileListCount"), lvTiles.Items.Count);
                });
            });
        }

        // 更新 Tile 清單顯示（支援搜尋過濾）
        private void UpdateTileList(string searchText)
        {
            Console.WriteLine("Update tile list start");
            Stopwatch sw = new Stopwatch();
            sw.Start();
                
            lvTiles.BeginUpdate();  // 暫停重繪
            try
            {
                lvTiles.Items.Clear();

                // 創建 ImageList
                ImageList imageList = new ImageList();
                imageList.ImageSize = new Size(48, 48);
                imageList.ColorDepth = ColorDepth.Depth32Bit;
                lvTiles.LargeImageList = imageList;

                if (_document.S32Files.Count == 0)
                {
                    this.toolStripStatusLabel1.Text = "沒有 S32 檔案";
                    return;
                }

                // 如果快取為空，重新聚合所有 S32 檔案的 UsedTiles
                if (cachedAggregatedTiles.Count == 0 || string.IsNullOrEmpty(searchText))
                {
                    cachedAggregatedTiles.Clear();

                    foreach (var s32Data in _document.S32Files.Values)
                    {
                        foreach (var tileKvp in s32Data.UsedTiles)
                        {
                            int tileId = tileKvp.Key;
                            var tileInfo = tileKvp.Value;

                            if (cachedAggregatedTiles.ContainsKey(tileId))
                            {
                                // 累加使用次數
                                cachedAggregatedTiles[tileId].UsageCount += tileInfo.UsageCount;
                            }
                            else
                            {
                                // 新增 tile
                                cachedAggregatedTiles[tileId] = new TileInfo
                                {
                                    TileId = tileInfo.TileId,
                                    IndexId = tileInfo.IndexId,
                                    UsageCount = tileInfo.UsageCount,
                                    Thumbnail = null
                                };
                            }
                        }

                        // 加入 Layer2 的 Tiles
                        foreach (var item in s32Data.Layer2)
                        {
                            if (item.TileId <= 0) continue;
                            if (cachedAggregatedTiles.ContainsKey(item.TileId))
                            {
                                cachedAggregatedTiles[item.TileId].UsageCount++;
                            }
                            else
                            {
                                cachedAggregatedTiles[item.TileId] = new TileInfo
                                {
                                    TileId = item.TileId,
                                    IndexId = item.IndexId,
                                    UsageCount = 1,
                                    Thumbnail = null
                                };
                            }
                        }
                    }
                }

                // 過濾 tiles
                var filteredTiles = cachedAggregatedTiles.AsEnumerable();
                if (!string.IsNullOrWhiteSpace(searchText))
                {
                    searchText = searchText.Trim();
                    // 支援多種搜尋方式：
                    // 1. 精確 ID 搜尋（輸入數字）
                    // 2. 範圍搜尋（如 "100-200"）
                    // 3. 多個 ID 搜尋（如 "100,200,300"）
                    if (searchText.Contains("-"))
                    {
                        // 範圍搜尋
                        var parts = searchText.Split('-');
                        if (parts.Length == 2 &&
                            int.TryParse(parts[0].Trim(), out int minId) &&
                            int.TryParse(parts[1].Trim(), out int maxId))
                        {
                            filteredTiles = filteredTiles.Where(t => t.Key >= minId && t.Key <= maxId);
                        }
                    }
                    else if (searchText.Contains(","))
                    {
                        // 多個 ID 搜尋
                        var ids = searchText.Split(',')
                            .Select(s => s.Trim())
                            .Where(s => int.TryParse(s, out _))
                            .Select(s => int.Parse(s))
                            .ToHashSet();
                        filteredTiles = filteredTiles.Where(t => ids.Contains(t.Key));
                    }
                    else if (int.TryParse(searchText, out int exactId))
                    {
                        // 精確 ID 或前綴搜尋
                        filteredTiles = filteredTiles.Where(t => t.Key.ToString().StartsWith(searchText));
                    }
                    else
                    {
                        // 文字搜尋（ID 包含此文字）
                        filteredTiles = filteredTiles.Where(t => t.Key.ToString().Contains(searchText));
                    }
                }

                // 批量準備項目
                var items = new List<IconTextListItem>();
                int index = 0;
                int totalCount = cachedAggregatedTiles.Count;
                foreach (var tileKvp in filteredTiles.OrderBy(t => t.Key))
                {
                    var tile = tileKvp.Value;

                    // 載入縮圖（如果還沒載入）
                    if (tile.Thumbnail == null)
                    {
                        tile.Thumbnail = LoadTileThumbnail(tile.TileId, tile.IndexId);
                    }

                    if (tile.Thumbnail != null)
                    {
                        imageList.Images.Add(tile.Thumbnail);

                        // 檢查是否為 R 版
                        bool isRemaster = TileProvider.Instance.IsRemaster(tile.TileId);
                        string rMark = isRemaster ? "(R)" : "";

                        var item = new IconTextListItem
                        {
                            Text = $"ID:{tile.TileId}{rMark}\n×{tile.UsageCount}",
                            ImageIndex = index,
                            Tag = tile
                        };
                        items.Add(item);
                        index++;
                    }
                }

                // 批量添加
                lvTiles.Items.AddRange(items);

                string statusText = string.IsNullOrWhiteSpace(searchText)
                    ? string.Format(LocalizationManager.L("Label_TileListCount"), lvTiles.Items.Count)
                    : $"{LocalizationManager.L("Label_SearchResult")}: {lvTiles.Items.Count}/{totalCount}";
                lblTileList.Text = statusText;
            }
            finally
            {
                lvTiles.EndUpdate();  // 恢復重繪
            }
            sw.Stop();
            Console.WriteLine("Update tile list end:"+sw.ElapsedMilliseconds+"ms");
        }

        // Tile 搜尋框文字變更事件
        private void txtTileSearch_TextChanged(object sender, EventArgs e)
        {
            UpdateTileList(txtTileSearch.Text);
        }

        // 計算 Tile.idx 中 1-9999 範圍內已使用的 TileId 數量
        private int GetTileIdxUsedCount()
        {
            try
            {
                // 觸發載入 Tile.idx（如果還沒載入）
                L1IdxReader.Find("Tile", "1.til");

                if (Share.IdxDataList.TryGetValue("Tile", out var tileIdx))
                {
                    int count = 0;
                    foreach (var key in tileIdx.Keys)
                    {
                        // 檔名格式為 "xxx.til"，解析出數字
                        if (key.EndsWith(".til"))
                        {
                            string numPart = key.Substring(0, key.Length - 4);
                            if (int.TryParse(numPart, out int tileId) && tileId >= 1 && tileId <= 9999)
                            {
                                count++;
                            }
                        }
                    }
                    return count;
                }
            }
            catch
            {
                // 忽略錯誤
            }
            return 0;
        }

        /// <summary>
        /// 讀取 list.til 中記錄的最大 TileId
        /// list.til 是一個包含單一 int32 數字的檔案，表示 Tile 的最大 ID
        /// </summary>
        private int GetListTilMaxId(bool forceReload = false)
        {
            if (_listTilMaxId.HasValue && !forceReload)
                return _listTilMaxId.Value;

            try
            {
                byte[] data = L1PakReader.UnPack("Tile", "list.til");
                if (data != null && data.Length >= 4)
                {
                    _listTilMaxId = BitConverter.ToInt32(data, 0);
                    return _listTilMaxId.Value;
                }
            }
            catch
            {
                // 忽略錯誤
            }
            return 9999; // 預設值
        }

        /// <summary>
        /// 取得 Tile.idx 中實際使用的最大 TileId
        /// </summary>
        private int GetActualMaxTileId()
        {
            int maxId = 0;
            try
            {
                // 觸發載入 Tile.idx
                L1IdxReader.Find("Tile", "1.til");

                if (Share.IdxDataList.TryGetValue("Tile", out var tileIdx))
                {
                    foreach (var key in tileIdx.Keys)
                    {
                        if (key.EndsWith(".til") && key != "list.til")
                        {
                            string numPart = key.Substring(0, key.Length - 4);
                            if (int.TryParse(numPart, out int tileId) && tileId > maxId)
                            {
                                maxId = tileId;
                            }
                        }
                    }
                }
            }
            catch
            {
                // 忽略錯誤
            }
            return maxId;
        }

        /// <summary>
        /// 檢查 list.til 數值按鈕點擊事件
        /// </summary>
        private void btnToolCheckListTil_Click(object sender, EventArgs e)
        {
            try
            {
                int listTilValue = GetListTilMaxId(true); // 強制重新讀取
                int actualMaxId = GetActualMaxTileId();
                int usedCount = GetTileIdxUsedCount();

                if (listTilValue > actualMaxId + 1)
                {
                    int suggestedValue = actualMaxId + 1;
                    var result = WinFormsMessageBox.Show(
                        $"list.til 檢查結果：\n\n" +
                        $"• list.til 記錄的上限：{listTilValue}\n" +
                        $"• 實際使用的最大 TileId：{actualMaxId}\n" +
                        $"• Tile.idx 中的 Tile 數量：{usedCount}\n\n" +
                        $"list.til 的數值 ({listTilValue}) 大於實際使用的最大 TileId + 1 ({actualMaxId + 1})。\n\n" +
                        $"是否要將 list.til 修改為 {suggestedValue}？",
                        "list.til 數值檢查",
                        MessageBoxButtons.YesNo,
                        MessageBoxIcon.Question);

                    if (result == DialogResult.Yes)
                    {
                        if (UpdateListTil(suggestedValue))
                        {
                            WinFormsMessageBox.Show(
                                $"list.til 已更新為 {suggestedValue}。\n\n剩餘可用空位：{suggestedValue - actualMaxId}",
                                "更新成功",
                                MessageBoxButtons.OK,
                                MessageBoxIcon.Information);

                            // 更新 Tile 清單顯示
                            UpdateTileList(txtTileSearch.Text);
                        }
                        else
                        {
                            WinFormsMessageBox.Show(
                                "更新 list.til 失敗，請檢查檔案權限。",
                                "更新失敗",
                                MessageBoxButtons.OK,
                                MessageBoxIcon.Error);
                        }
                    }
                }
                else
                {
                    WinFormsMessageBox.Show(
                        $"list.til 檢查結果：\n\n" +
                        $"• list.til 記錄的上限：{listTilValue}\n" +
                        $"• 實際使用的最大 TileId：{actualMaxId}\n" +
                        $"• Tile.idx 中的 Tile 數量：{usedCount}\n" +
                        $"• 剩餘可用空位：{listTilValue - actualMaxId}\n\n" +
                        $"list.til 數值正常，無需更新。",
                        "list.til 數值檢查",
                        MessageBoxButtons.OK,
                        MessageBoxIcon.Information);
                }
            }
            catch (Exception ex)
            {
                WinFormsMessageBox.Show(
                    $"檢查 list.til 時發生錯誤：{ex.Message}",
                    "錯誤",
                    MessageBoxButtons.OK,
                    MessageBoxIcon.Error);
            }
        }

        /// <summary>
        /// 更新 list.til 的數值並存回 pak
        /// </summary>
        private bool UpdateListTil(int newValue)
        {
            try
            {
                byte[] data = BitConverter.GetBytes(newValue);
                bool success = L1PakWriter.AppendFile("Tile", "list.til", data);
                if (success)
                {
                    _listTilMaxId = newValue;
                }
                return success;
            }
            catch (Exception ex)
            {
                Console.WriteLine($"UpdateListTil error: {ex.Message}");
                return false;
            }
        }

        /// <summary>
        /// 測 til 按鈕點擊事件 - 選擇外部 til 檔案暫時替換顯示
        /// </summary>
        private void btnToolTestTil_Click(object sender, EventArgs e)
        {
            try
            {
                using (var openDialog = new OpenFileDialog())
                {
                    openDialog.Filter = "Tile 檔案|*.til|所有檔案|*.*";
                    openDialog.Title = "選擇要測試的 til 檔案";

                    if (openDialog.ShowDialog(this) != DialogResult.Ok)
                        return;

                    string filePath = openDialog.FileName;
                    string fileName = Path.GetFileNameWithoutExtension(filePath);

                    // 嘗試從檔名解析 tileId
                    int tileId = 0;
                    bool autoDetected = int.TryParse(fileName, out tileId);

                    // 讓用戶確認或修改 tileId
                    string input = ShowInputDialog(
                        "測 til",
                        $"請輸入要替換的 TileId：\n（檔名偵測：{(autoDetected ? tileId.ToString() : "無法偵測")}）",
                        autoDetected ? tileId.ToString() : "0");

                    if (!int.TryParse(input, out tileId))
                    {
                        WinFormsMessageBox.Show("無效的 TileId", "錯誤", MessageBoxButtons.OK, MessageBoxIcon.Error);
                        return;
                    }

                    // 載入 til 檔案
                    byte[] tilData = File.ReadAllBytes(filePath);
                    List<byte[]> tilArray = L1Til.Parse(tilData);

                    if (tilArray == null || tilArray.Count == 0)
                    {
                        WinFormsMessageBox.Show("無法解析 til 檔案", "錯誤", MessageBoxButtons.OK, MessageBoxIcon.Error);
                        return;
                    }

                    // 設定 Override（TileProvider 會自動觸發事件，MiniMapControl 會自動重繪）
                    TileProvider.Instance.SetOverride(tileId, tilArray);

                    // 重新渲染 Viewport
                    RenderS32Map();

                    WinFormsMessageBox.Show(
                        $"已暫時替換 TileId {tileId}\n（{tilArray.Count} 個 blocks）\n\n使用「清til」按鈕可恢復",
                        "測 til",
                        MessageBoxButtons.OK,
                        MessageBoxIcon.Information);
                }
            }
            catch (Exception ex)
            {
                WinFormsMessageBox.Show($"測 til 失敗：{ex.Message}", "錯誤", MessageBoxButtons.OK, MessageBoxIcon.Error);
            }
        }

        /// <summary>
        /// 清除測 til 按鈕點擊事件 - 清除所有暫時替換
        /// </summary>
        private void btnToolClearTestTil_Click(object sender, EventArgs e)
        {
            try
            {
                if (TileProvider.Instance.OverrideCount == 0)
                {
                    WinFormsMessageBox.Show("目前沒有任何測 til 設定", "清除測 til", MessageBoxButtons.OK, MessageBoxIcon.Information);
                    return;
                }

                // 清除所有 override（TileProvider 會自動觸發事件，MiniMapControl 會自動重繪）
                var clearedIds = TileProvider.Instance.ClearAllOverrides();

                // 重新渲染 Viewport
                RenderS32Map();

                WinFormsMessageBox.Show(
                    $"已清除 {clearedIds.Count} 個測 til 設定\n（TileId: {string.Join(", ", clearedIds)}）",
                    "清除測 til",
                    MessageBoxButtons.OK,
                    MessageBoxIcon.Information);
            }
            catch (Exception ex)
            {
                WinFormsMessageBox.Show($"清除測 til 失敗：{ex.Message}", "錯誤", MessageBoxButtons.OK, MessageBoxIcon.Error);
            }
        }

        // 載入 Tile 縮圖（使用快取）
        private Bitmap LoadTileThumbnail(int tileId, int indexId)
        {
            try
            {
                // 使用 TileProvider 取得 til 資料
                var tilArray = TileProvider.Instance.GetTilArray(tileId);
                if (tilArray == null || indexId >= tilArray.Count)
                    return CreatePlaceholderThumbnail(tileId);

                // 繪製實際的 tile 圖片
                byte[] tilData = tilArray[indexId];
                return RenderTileThumbnail(tilData, tileId);
            }
            catch
            {
                return CreatePlaceholderThumbnail(tileId);
            }
        }

        // 繪製 Tile 到縮圖
        private unsafe Bitmap RenderTileThumbnail(byte[] tilData, int tileId)
        {
            try
            {
                // 創建 48x48 的縮圖
                Bitmap thumbnail = new Bitmap(48, 48, PixelFormat.Format16bppRgb555);

                Rectangle rect = new Rectangle(0, 0, thumbnail.Width, thumbnail.Height);
                BitmapData bmpData = thumbnail.LockBits(rect, ImageLockMode.ReadWrite, thumbnail.PixelFormat);
                int rowpix = bmpData.Stride;
                byte* ptr = (byte*)bmpData.Scan0;

                // 固定 tilData 陣列以取得指標
                fixed (byte* til_ptr_fixed = tilData)
                {
                    byte* til_ptr = til_ptr_fixed;
                    byte type = *(til_ptr++);

                    // 縮圖偏移（置中）
                    int offsetX = 12;
                    int offsetY = 12;

                    if ((type & 0x02) == 0 && (type & 0x01) != 0 )
                    {
                        // 下半部 2.5D 方塊
                        for (int ty = 0; ty < 24; ty++)
                        {
                            int n = (ty <= 11) ? (ty + 1) * 2 : (23 - ty) * 2;
                            int tx = 0;
                            for (int p = 0; p < n; p++)
                            {
                                ushort color = (ushort)(*(til_ptr++) | (*(til_ptr++) << 8));
                                int px = offsetX + tx;
                                int py = offsetY + ty;
                                if (px >= 0 && px < 48 && py >= 0 && py < 48)
                                {
                                    int v = py * rowpix + (px * 2);
                                    *(ptr + v) = (byte)(color & 0x00FF);
                                    *(ptr + v + 1) = (byte)((color & 0xFF00) >> 8);
                                }
                                tx++;
                            }
                        }
                    }
                    else if ((type & 0x02) == 0 && (type & 0x01) == 0 )
                    {
                        // 上半部 2.5D 方塊
                        for (int ty = 0; ty < 24; ty++)
                        {
                            int n = (ty <= 11) ? (ty + 1) * 2 : (23 - ty) * 2;
                            int tx = 24 - n;
                            for (int p = 0; p < n; p++)
                            {
                                ushort color = (ushort)(*(til_ptr++) | (*(til_ptr++) << 8));
                                int px = offsetX + tx;
                                int py = offsetY + ty;
                                if (px >= 0 && px < 48 && py >= 0 && py < 48)
                                {
                                    int v = py * rowpix + (px * 2);
                                    *(ptr + v) = (byte)(color & 0x00FF);
                                    *(ptr + v + 1) = (byte)((color & 0xFF00) >> 8);
                                }
                                tx++;
                            }
                        }
                    }
                    else
                    {
                        // 壓縮格式（type 34, 35 或其他）
                        byte x_offset = *(til_ptr++);
                        byte y_offset = *(til_ptr++);
                        byte xxLen = *(til_ptr++);
                        byte yLen = *(til_ptr++);

                        for (int ty = 0; ty < yLen && ty < 48; ty++)
                        {
                            int tx = x_offset;
                            byte xSegmentCount = *(til_ptr++);
                            for (int nx = 0; nx < xSegmentCount; nx++)
                            {
                                tx += *(til_ptr++) / 2;
                                int xLen = *(til_ptr++);
                                for (int p = 0; p < xLen; p++)
                                {
                                    ushort color = (ushort)(*(til_ptr++) | (*(til_ptr++) << 8));
                                    int px = offsetX + tx;
                                    int py = offsetY + ty + y_offset;
                                    if (px >= 0 && px < 48 && py >= 0 && py < 48)
                                    {
                                        int v = py * rowpix + (px * 2);
                                        *(ptr + v) = (byte)(color & 0x00FF);
                                        *(ptr + v + 1) = (byte)((color & 0xFF00) >> 8);
                                    }
                                    tx++;
                                }
                            }
                        }
                    }
                }

                thumbnail.UnlockBits(bmpData);
                return thumbnail;
            }
            catch
            {
                return CreatePlaceholderThumbnail(tileId);
            }
        }

        // 創建佔位縮圖
        private Bitmap CreatePlaceholderThumbnail(int tileId)
        {
            Bitmap placeholder = new Bitmap(new Size(48, 48), Eto.Drawing.PixelFormat.Format32bppRgba);
            using (Graphics g = GraphicsHelper.FromImage(placeholder))
            {
                g.Clear(Colors.DarkGray);
                g.DrawRectangle(Pens.Red, 1, 1, 46, 46);
                using (Font font = new Font("Arial", 8))
                {
                    g.DrawString("?", font, Brushes.White, 18, 16);
                }
            }
            return placeholder;
        }

        #region MapViewerControl 事件處理

        // MapViewerControl 滑鼠按下事件 - 轉發給編輯處理
        private void MapViewerControl_MapMouseDown(object sender, MapMouseEventArgs e)
        {
            // 先直接用世界座標處理 Layer8 marker 點擊（避免座標轉換誤差）
            if (e.Buttons == Eto.Forms.MouseButtons.Primary && ControlCompat.ModifierKeys == Keys.None && _viewState.ShowLayer8)
            {
                var clickedMarker = FindLayer8MarkerAtPosition(e.WorldLocation.X, e.WorldLocation.Y);
                if (clickedMarker.HasValue)
                {
                    var (s32Path, index) = clickedMarker.Value;
                    Console.WriteLine($"[Layer8-MapViewer] Clicked marker: {s32Path} index={index}");

                    // 切換顯示狀態
                    if (_editState.EnabledLayer8Items.Contains((s32Path, index)))
                    {
                        _editState.EnabledLayer8Items.Remove((s32Path, index));
                        _renderCache.Layer8AnimFrame.Remove((s32Path, index));

                        if (_editState.EnabledLayer8Items.Count == 0 && _layer8AnimTimer != null)
                        {
                            _layer8AnimTimer.Stop();
                        }
                        Console.WriteLine($"[Layer8-MapViewer] Disabled marker");
                    }
                    else
                    {
                        _editState.EnabledLayer8Items.Add((s32Path, index));
                        _renderCache.Layer8AnimFrame[(s32Path, index)] = 0;

                        if (_layer8AnimTimer != null && !_layer8AnimTimer.Enabled)
                        {
                            _layer8AnimTimer.Start();
                        }
                        Console.WriteLine($"[Layer8-MapViewer] Enabled marker, total enabled: {_editState.EnabledLayer8Items.Count}");
                    }

                    // 只重繪 L8 動畫覆蓋層，不影響地圖和其他圖層
                    _mapViewerControl.InvalidateAnimationOverlay();
                    return;
                }
            }

            // 使用 MapViewerControl 提供的世界座標，轉換回螢幕座標給現有邏輯
            var screenLocation = _mapViewerControl.WorldToScreen(e.WorldLocation);
            var me = new MouseEventArgs(e.GetButton(), e.Modifiers, screenLocation, new SizeF(0, e.Delta));
            s32PictureBox_MouseDown(sender, me);
        }

        // MapViewerControl 滑鼠移動事件 - 轉發給編輯處理
        private void MapViewerControl_MapMouseMove(object sender, MapMouseEventArgs e)
        {
            var screenLocation = _mapViewerControl.WorldToScreen(e.WorldLocation);
            var me = new MouseEventArgs(e.GetButton(), e.Modifiers, screenLocation, new SizeF(0, e.Delta));
            s32PictureBox_MouseMove(sender, me);
        }

        // MapViewerControl 滑鼠放開事件 - 轉發給編輯處理
        private void MapViewerControl_MapMouseUp(object sender, MapMouseEventArgs e)
        {
            var screenLocation = _mapViewerControl.WorldToScreen(e.WorldLocation);
            var me = new MouseEventArgs(e.GetButton(), e.Modifiers, screenLocation, new SizeF(0, e.Delta));
            s32PictureBox_MouseUp(sender, me);

            // 如果不是拖曳操作，也觸發 Click 事件（處理格子點擊、右鍵選單等）
            if (!_interaction.IsMainMapDragging && !_interaction.IsMiniMapDragging && !isSelectingRegion)
            {
                s32PictureBox_MouseClick(sender, me);
            }
        }

        // MapViewerControl 繪製覆蓋層 - 繪製 L8 動畫、選取框、多邊形等
        private void MapViewerControl_PaintOverlay(object sender, PaintEventArgs e)
        {
            var sw = Stopwatch.StartNew();

            // 繪製 Layer8 標記和 SPR 動畫
            if (_viewState.ShowLayer8)
            {
                var l8Sw = Stopwatch.StartNew();
                DrawLayer8OverlayOnControl(e.Graphics);
                l8Sw.Stop();
                if (l8Sw.ElapsedMilliseconds > 5)
                    _logger.Debug($"[UI-OVERLAY] Layer8 overlay took {l8Sw.ElapsedMilliseconds}ms");
            }

            // 繪製編輯覆蓋層
            var editSw = Stopwatch.StartNew();
            DrawEditingOverlay(e.Graphics);
            editSw.Stop();

            sw.Stop();
            if (sw.ElapsedMilliseconds > 10)
                _logger.Debug($"[UI-OVERLAY] PaintOverlay total={sw.ElapsedMilliseconds}ms, edit={editSw.ElapsedMilliseconds}ms");
        }

        // 在 MapViewerControl 的覆蓋層上繪製 Layer8 標記
        private void DrawLayer8OverlayOnControl(Graphics g)
        {
            if (_document.S32Files.Count == 0) return;

            g.SetSmoothingMode(SmoothingMode.AntiAlias);

            foreach (var s32Data in _document.S32Files.Values)
            {
                if (s32Data.Layer8.Count == 0) continue;

                int[] loc = s32Data.SegInfo.GetLoc(1.0);
                int mx = loc[0];
                int my = loc[1];

                for (int i = 0; i < s32Data.Layer8.Count; i++)
                {
                    var item = s32Data.Layer8[i];

                    // Layer8 X,Y 是絕對遊戲座標，先轉為本地座標
                    int localLayer3X = item.X - s32Data.SegInfo.nLinBeginX;
                    int localLayer3Y = item.Y - s32Data.SegInfo.nLinBeginY;

                    if (localLayer3X < 0 || localLayer3X > 63 || localLayer3Y < 0 || localLayer3Y > 63)
                        continue;

                    int layer1X = localLayer3X * 2;
                    int layer1Y = localLayer3Y;

                    int baseX = -24 * (layer1X / 2);
                    int baseY = 63 * 12 - 12 * (layer1X / 2);

                    // Marker 位置：格子中心 (+12, +12)
                    int markerWorldX = mx + baseX + layer1X * 24 + layer1Y * 24 + 12;
                    int markerWorldY = my + baseY + layer1Y * 12 + 12;

                    // SPR 位置：格子左上角（offset 由 SPR 檔案提供）
                    int sprWorldX = mx + baseX + layer1X * 24 + layer1Y * 24;
                    int sprWorldY = my + baseY + layer1Y * 12;

                    // 轉為螢幕座標
                    var markerScreenPoint = _mapViewerControl.WorldToScreen(new Point(markerWorldX, markerWorldY));
                    int markerX = markerScreenPoint.X;
                    int markerY = markerScreenPoint.Y;

                    var sprScreenPoint = _mapViewerControl.WorldToScreen(new Point(sprWorldX, sprWorldY));
                    int sprX = sprScreenPoint.X;
                    int sprY = sprScreenPoint.Y;

                    // 檢查是否在可見範圍內
                    if (markerX < -50 || markerX > _mapViewerControl.Width + 50 || markerY < -50 || markerY > _mapViewerControl.Height + 50)
                        continue;

                    bool isEnabled = _editState.EnabledLayer8Items.Contains((s32Data.FilePath, i));

                    // 繪製標記（圓點）- 受 ShowLayer8Marker 控制
                    // 啟用時：灰色半透明 (opacity 0.1)，在 SPR 下面
                    // 停用時：橙色實心
                    int markerRadius = (int)(10 * _viewState.ZoomLevel);
                    if (markerRadius < 5) markerRadius = 5;

                    if (_viewState.ShowLayer8Marker)
                    {
                        if (isEnabled)
                        {
                            // 啟用狀態：先畫灰色半透明 marker
                            using (SolidBrush brush = new SolidBrush(Color.FromArgb(25, 128, 128, 128)))
                            {
                                g.FillEllipse(brush, markerX - markerRadius, markerY - markerRadius, markerRadius * 2, markerRadius * 2);
                            }
                            using (Pen pen = new Pen(Color.FromArgb(50, 255, 255, 255)))
                            {
                                g.DrawEllipse(pen, markerX - markerRadius, markerY - markerRadius, markerRadius * 2, markerRadius * 2);
                            }
                        }
                        else
                        {
                            // 停用狀態：橙色實心 marker
                            using (SolidBrush brush = new SolidBrush(Colors.Orange))
                            {
                                g.FillEllipse(brush, markerX - markerRadius, markerY - markerRadius, markerRadius * 2, markerRadius * 2);
                            }
                            g.DrawEllipse(Pens.White, markerX - markerRadius, markerY - markerRadius, markerRadius * 2, markerRadius * 2);
                        }

                        // 顯示 SprId - 受 ShowLayer8Marker 控制
                        using (Font font = new Font("Arial", (float)Math.Max(6, 8 * _viewState.ZoomLevel), FontStyle.Bold))
                        {
                            g.DrawString(item.SprId.ToString(), font, Brushes.White, markerX + markerRadius + 2, markerY - 6);
                        }
                    }

                    // 繪製 SPR 動畫 - 受 ShowLayer8Spr 控制
                    if (_viewState.ShowLayer8Spr && isEnabled)
                    {
                        DrawLayer8SpriteOnOverlay(g, item.SprId, sprX, sprY, s32Data.FilePath, i);
                    }
                }
            }
        }

        // 在覆蓋層上繪製 Layer8 SPR 動畫帧
        private void DrawLayer8SpriteOnOverlay(Graphics g, int sprId, int x, int y, string s32Path, int itemIndex)
        {
            if (!_renderCache.Layer8SprCache.TryGetValue(sprId, out var frames))
            {
                frames = LoadLayer8SprFrames(sprId);
                _renderCache.Layer8SprCache[sprId] = frames;
            }

            if (frames == null || frames.Count == 0) return;

            var key = (s32Path, itemIndex);
            if (!_renderCache.Layer8AnimFrame.TryGetValue(key, out int frameIdx))
            {
                frameIdx = 0;
                _renderCache.Layer8AnimFrame[key] = 0;
            }

            var frame = frames[frameIdx % frames.Count];
            float scale = (float)_viewState.ZoomLevel;
            int drawW = (int)(frame.Image.Width * scale);
            int drawH = (int)(frame.Image.Height * scale);

            // 使用 SPR 檔案中的 offset（縮放後）
            // 與 Rust 一致: start_x = center_x + frame.offset_x
            int drawX = x + (int)Math.Round(frame.XOffset * scale);
            int drawY = y + (int)Math.Round(frame.YOffset * scale);
            g.DrawImage(frame.Image, drawX, drawY, drawW, drawH);
        }

        // MapViewerControl 座標變更事件 - 更新狀態列
        private void MapViewerControl_CoordinateChanged(object sender, CoordinateChangedEventArgs e)
        {
            this.toolStripStatusLabel2.Text = $"座標: ({e.GameX}, {e.GameY})";
        }

        // MapViewerControl 渲染完成事件
        private void MapViewerControl_RenderCompleted(object sender, RenderCompletedEventArgs e)
        {
            // 可選：更新渲染時間顯示
            // LogPerf($"[RENDER-COMPLETE] {e.RenderTimeMs}ms");
        }

        // 繪製編輯覆蓋層（從 s32PictureBox_Paint 中提取）
        private void DrawEditingOverlay(Graphics g)
        {
            // 通行性編輯模式：繪製多邊形（保留舊功能但使用統一顏色）
            if (_editState.IsDrawingPassabilityPolygon && _editState.PassabilityPolygonPoints.Count > 0)
            {
                Color polygonColor = Colors.LightBlue;

                using (Pen pen = new Pen(polygonColor, 3))
                {
                    for (int i = 0; i < _editState.PassabilityPolygonPoints.Count - 1; i++)
                    {
                        g.DrawLine(pen, _editState.PassabilityPolygonPoints[i], _editState.PassabilityPolygonPoints[i + 1]);
                    }
                    if (_editState.PassabilityPolygonPoints.Count >= 3)
                    {
                        using (Pen dashPen = new Pen(polygonColor, 2) { DashStyle = DashStyle.Dash })
                        {
                            g.DrawLine(dashPen, _editState.PassabilityPolygonPoints[_editState.PassabilityPolygonPoints.Count - 1], _editState.PassabilityPolygonPoints[0]);
                        }
                    }
                }

                using (SolidBrush brush = new SolidBrush(polygonColor))
                {
                    foreach (var pt in _editState.PassabilityPolygonPoints)
                    {
                        g.FillEllipse(brush, pt.X - 5, pt.Y - 5, 10, 10);
                    }
                }

                if (_editState.PassabilityPolygonPoints.Count >= 3)
                {
                    using (SolidBrush fillBrush = new SolidBrush(ColorExtensions.FromArgb(50, polygonColor)))
                    {
                        g.FillPolygon(fillBrush, _editState.PassabilityPolygonPoints.ToArray());
                    }
                }
                return;
            }

            // 有選中的格子時，繪製對齊格線的菱形選取框
            if (_editState.SelectedCells.Count > 0)
            {
                Color color = isSelectingRegion ? Colors.Green : Colors.Orange;
                DrawSelectedCells(g, _editState.SelectedCells, color);

                if (isSelectingRegion)
                {
                    string info = $"選取 {_editState.SelectedCells.Count} 格";
                    using (Font font = new Font("Arial", 10, FontStyle.Bold))
                    using (SolidBrush bgBrush = new SolidBrush(ColorExtensions.FromArgb(180, Colors.Black)))
                    using (SolidBrush textBrush = new SolidBrush(Colors.White))
                    {
                        SizeF textSize = g.MeasureString(info, font);
                        float textX = regionEndPoint.X + 15;
                        float textY = regionEndPoint.Y - 20;
                        g.FillRectangle(bgBrush, textX - 2, textY - 2, textSize.Width + 4, textSize.Height + 4);
                        g.DrawString(info, font, textBrush, textX, textY);
                    }
                }
            }
        }

        #endregion

        // S32 地圖點擊事件 - 更新高亮和狀態列
        private void s32PictureBox_MouseClick(object sender, MouseEventArgs e)
        {
            var sw = Stopwatch.StartNew();
            LogPerf($"[MOUSE-CLICK] start, button={e.GetButton()}, isDragging={_interaction.IsMainMapDragging}");

            // 如果正在選擇區域，不處理點擊
            if (isSelectingRegion)
            {
                LogPerf($"[MOUSE-CLICK] skip - selecting region");
                return;
            }

            // 獲取當前地圖資訊以計算正確的 baseY
            if (string.IsNullOrEmpty(_document.MapId) || !Share.MapDataList.ContainsKey(_document.MapId))
            {
                LogPerf($"[MOUSE-CLICK] skip - no map");
                return;
            }

            // 將點擊位置轉換為世界座標
            var worldPoint = S32ScreenToWorld((int)e.Location.X, (int)e.Location.Y);
            int worldX = worldPoint.X;
            int worldY = worldPoint.Y;

            // 注意：Layer8 標記點擊已在 MapViewerControl_MapMouseDown 處理，
            // 這裡不再重複處理，避免雙重切換導致狀態不變

            // 使用優化的格子查找（先過濾 S32 範圍，減少 400x 計算量）
            var result = CellFinder.FindCellOptimized(worldX, worldY, _document.S32Files.Values);
            LogPerf($"[MOUSE-CLICK] search done, found={result.Found}, elapsed={result.ElapsedMs}ms, s32Checked={result.S32Checked}, cellsChecked={result.CellsChecked}");

            if (result.Found)
            {
                var s32Data = result.S32Data;
                int x = result.CellX;
                int y = result.CellY;

                // 如果找到的是延伸區域的格子（超出正常 Layer1 範圍 0-127 x 0-63），
                // 嘗試找另一個 S32 的正常範圍內的格子
                if (x >= 128 || y >= 64)
                {
                    // 搜尋是否有其他 S32 的正常範圍包含這個世界座標
                    var normalResult = FindCellInNormalRange(worldX, worldY);
                    if (normalResult.Found)
                    {
                        // 使用正常範圍的結果
                        s32Data = normalResult.S32Data;
                        x = normalResult.CellX;
                        y = normalResult.CellY;
                    }
                    else if (e.Buttons == Eto.Forms.MouseButtons.Alternate)
                    {
                        // 如果有選取格子，優先顯示選取區域選單
                        if (_editState.SelectedCells.Count > 0)
                        {
                            ShowSelectionContextMenu(e.Location.ToPoint());
                            return;
                        }
                        // 真正的延伸區域，顯示新增 S32 選單
                        Struct.L1Map currentMap = Share.MapDataList[_document.MapId];
                        ShowEmptyAreaContextMenu(e.Location.ToPoint(), new Point(worldX, worldY), currentMap);
                        return;
                    }
                    else
                    {
                        // 左鍵點擊延伸區域，不做任何處理
                        return;
                    }
                }

                // 設置當前選中的 S32 檔案
                currentS32FileItem = new S32FileItem
                {
                    FilePath = s32Data.FilePath,
                    SegInfo = s32Data.SegInfo
                };

                // 記錄選中的格子並更新狀態列顯示第三層屬性（僅限正常範圍內的格子）
                _editState.HighlightedS32Data = s32Data;
                _editState.HighlightedCellX = x;
                _editState.HighlightedCellY = y;
                if (x < 128 && y < 64)
                {
                    UpdateStatusBarWithLayer3Info(s32Data, x, y);
                }

                // 區域編輯模式：右鍵變更選取區域的區域類型
                if (currentRegionEditMode != RegionEditMode.None && e.Buttons == Eto.Forms.MouseButtons.Alternate)
                {
                    if (_editState.SelectedCells.Count > 0)
                    {
                        SetSelectedCellsRegionType(currentRegionType);
                    }
                    return;
                }

                // 素材貼上模式：點擊貼上素材
                if (_pendingMaterial != null && e.Buttons == Eto.Forms.MouseButtons.Primary)
                {
                    // 使用 CoordinateHelper 轉換 Layer1 本地座標為遊戲座標
                    var (gameX, gameY) = CoordinateHelper.LocalToGameCoords(s32Data, x, y);
                    PasteMaterialAtPosition(gameX, gameY);
                    return;
                }

                // 右鍵點擊：如果有選取格子則顯示選取區域選單，否則顯示區塊操作選單
                if (e.Buttons == Eto.Forms.MouseButtons.Alternate)
                {
                    // 優先顯示選取區域的右鍵選單（不論是否在複製模式）
                    if (_editState.SelectedCells.Count > 0)
                    {
                        ShowSelectionContextMenu(e.Location.ToPoint());
                        return;
                    }
                    // 沒有選取時顯示區塊操作選單
                    Struct.L1Map currentMap = Share.MapDataList[_document.MapId];
                    ShowExistingBlockContextMenu(e.Location.ToPoint(), new Point(worldX, worldY), currentMap, s32Data);
                    return;
                }

                // 重新渲染以顯示高亮
                RenderS32Map();

                // 透明編輯模式下：顯示附近群組縮圖
                if (_editState.IsLayer5EditMode)
                {
                    UpdateNearbyGroupThumbnails(s32Data, x, y, 10);
                }
                else
                {
                    // 非透明編輯模式，不需要更新群組清單
                }
                sw.Stop();
                LogPerf($"[MOUSE-CLICK] found cell, total={sw.ElapsedMilliseconds}ms");
                return;
            }

            sw.Stop();
            LogPerf($"[MOUSE-CLICK] no cell found, total={sw.ElapsedMilliseconds}ms, s32Count={_document.S32Files.Count}");

            // 點擊空白區域時，如果有選取格子則顯示選取選單，否則顯示新增 S32 選單
            if (e.Buttons == Eto.Forms.MouseButtons.Alternate && _document.S32Files.Count > 0)
            {
                // 優先顯示選取區域的右鍵選單
                if (_editState.SelectedCells.Count > 0)
                {
                    ShowSelectionContextMenu(e.Location.ToPoint());
                    return;
                }
                Struct.L1Map currentMap = Share.MapDataList[_document.MapId];
                ShowEmptyAreaContextMenu(e.Location.ToPoint(), new Point(worldX, worldY), currentMap);
            }
        }

        // 顯示空白區域的右鍵選單
        private void ShowEmptyAreaContextMenu(Point screenLocation, Point worldPos, Struct.L1Map currentMap)
        {
            ContextMenuStrip menu = new ContextMenuStrip();

            ToolStripMenuItem addS32Item = new ToolStripMenuItem("➕ 在此位置新增 S32 區塊...");
            addS32Item.Font = FontExtensions.CreateFont(addS32Item.Font, FontStyle.Bold);
            addS32Item.Click += (s, args) =>
            {
                TryCreateS32AtClickPosition(worldPos, currentMap);
            };
            menu.Items.Add(addS32Item);

            // 在此位置匯入 fs32
            ToolStripMenuItem importFs32Item = new ToolStripMenuItem("📦 在此位置匯入 fs32...");
            importFs32Item.Click += (s, args) =>
            {
                ImportFs32AtPosition(worldPos, currentMap);
            };
            menu.Items.Add(importFs32Item);

            // 顯示預估的 Block 座標
            if (_document.S32Files.Count > 0)
            {
                var (blockX, blockY) = EstimateBlockCoordinates(worldPos, currentMap);
                string fileName = $"{blockX:X4}{blockY:X4}.s32".ToLower();

                menu.Items.Add(new ToolStripSeparator());
                ToolStripMenuItem infoItem = new ToolStripMenuItem($"預估位置: {fileName} ({blockX:X4},{blockY:X4})");
                infoItem.Enabled = false;
                menu.Items.Add(infoItem);
            }

            menu.Show(_mapViewerControl, screenLocation);
        }

        // 顯示已存在區塊的右鍵選單
        private void ShowExistingBlockContextMenu(Point screenLocation, Point worldPos, Struct.L1Map currentMap, S32Data currentS32)
        {
            ContextMenuStrip menu = new ContextMenuStrip();

            // 在此位置匯入 fs32（覆蓋現有區塊）
            ToolStripMenuItem importFs32Item = new ToolStripMenuItem("📦 在此位置匯入 fs32...");
            importFs32Item.Click += (s, args) =>
            {
                ImportFs32AtPosition(worldPos, currentMap);
            };
            menu.Items.Add(importFs32Item);

            // 顯示當前區塊資訊
            menu.Items.Add(new ToolStripSeparator());
            string blockFileName = Path.GetFileName(currentS32.FilePath);
            ToolStripMenuItem infoItem = new ToolStripMenuItem($"當前區塊: {blockFileName}");
            infoItem.Enabled = false;
            menu.Items.Add(infoItem);

            // 顯示目標位置資訊
            var (blockX, blockY) = EstimateBlockCoordinates(worldPos, currentMap);
            string targetFileName = $"{blockX:X4}{blockY:X4}.s32".ToLower();
            ToolStripMenuItem targetItem = new ToolStripMenuItem($"目標位置: {targetFileName} ({blockX:X4},{blockY:X4})");
            targetItem.Enabled = false;
            menu.Items.Add(targetItem);

            menu.Show(_mapViewerControl, screenLocation);
        }

        // 在正常範圍內（0-127 x 0-63）搜尋格子，避免找到延伸區域的格子
        private CellFinder.FindResult FindCellInNormalRange(int worldX, int worldY)
        {
            var result = new CellFinder.FindResult { Found = false };

            foreach (var s32Data in _document.S32Files.Values)
            {
                int[] loc = s32Data.SegInfo.GetLoc(1.0);
                int mx = loc[0];
                int my = loc[1];

                // 只搜尋正常範圍 (0-127 x 0-63)
                for (int y = 0; y < 64; y++)
                {
                    for (int x = 0; x < 128; x++)
                    {
                        int localBaseX = -24 * (x / 2);
                        int localBaseY = 63 * 12 - 12 * (x / 2);

                        int cellX = mx + localBaseX + x * 24 + y * 24;
                        int cellY = my + localBaseY + y * 12;

                        // 檢查點是否在菱形內
                        int centerX = cellX + 12;
                        int centerY = cellY + 12;
                        int dx = Math.Abs(worldX - centerX);
                        int dy = Math.Abs(worldY - centerY);

                        if (dx * 12 + dy * 12 <= 144) // 12 * 12 = 144
                        {
                            result.Found = true;
                            result.S32Data = s32Data;
                            result.CellX = x;
                            result.CellY = y;
                            return result;
                        }
                    }
                }
            }

            return result;
        }

        // 估算點擊位置的 Block 座標
        private (int blockX, int blockY) EstimateBlockCoordinates(Point clickPos, Struct.L1Map currentMap)
        {
            if (_document.S32Files.Count == 0)
            {
                int defaultBlockX = currentMap.nMinBlockX != 0xFFFF ? currentMap.nMinBlockX : 0x7FFF;
                int defaultBlockY = currentMap.nMinBlockY != 0xFFFF ? currentMap.nMinBlockY : 0x8000;
                return (defaultBlockX, defaultBlockY);
            }

            var refS32 = _document.S32Files.Values.First();
            int[] refLoc = refS32.SegInfo.GetLoc(1.0);
            int refMx = refLoc[0];
            int refMy = refLoc[1];

            int blockWidth = 64 * 24 * 2;  // 3072
            int blockHeight = 64 * 12 * 2; // 1536

            int refCenterX = refMx + blockWidth / 2;
            int refCenterY = refMy + blockHeight / 2;

            int deltaPixelX = clickPos.X - refCenterX;
            int deltaPixelY = clickPos.Y - refCenterY;

            double dBx = (double)(deltaPixelX * blockHeight - deltaPixelY * blockWidth) / (blockWidth * blockHeight);
            double dBy = (double)(deltaPixelX * blockHeight + deltaPixelY * blockWidth) / (blockWidth * blockHeight);

            int deltaBlockX = (int)Math.Round(dBx);
            int deltaBlockY = (int)Math.Round(dBy);

            int targetBlockX = refS32.SegInfo.nBlockX + deltaBlockX;
            int targetBlockY = refS32.SegInfo.nBlockY + deltaBlockY;

            return (targetBlockX, targetBlockY);
        }

        // S32 地圖雙擊事件 - 顯示格子詳細資訊或新增 S32
        private void s32PictureBox_MouseDoubleClick(object sender, MouseEventArgs e)
        {
            // 獲取當前地圖資訊
            if (string.IsNullOrEmpty(_document.MapId) || !Share.MapDataList.ContainsKey(_document.MapId))
                return;

            Struct.L1Map currentMap = Share.MapDataList[_document.MapId];

            // 將點擊位置轉換為世界座標（考慮縮放和捲動位置）
            int worldX = (int)(e.Location.X / _viewState.ZoomLevel) + _viewState.ScrollX;
            int worldY = (int)(e.Location.Y / _viewState.ZoomLevel) + _viewState.ScrollY;

            // 使用優化的格子查找
            var result = CellFinder.FindCellOptimized(worldX, worldY, _document.S32Files.Values);

            if (result.Found)
            {
                var s32Data = result.S32Data;
                int x = result.CellX;
                int y = result.CellY;

                // 延伸區域（超出正常 Layer1 範圍 0-127 x 0-63）視為空白區域，觸發新增 S32
                if (x >= 128 || y >= 64)
                {
                    Point adjustedLocation = new Point(worldX, worldY);
                    TryCreateS32AtClickPosition(adjustedLocation, currentMap);
                    return;
                }

                // 設置當前選中的 S32 檔案
                currentS32FileItem = new S32FileItem
                {
                    FilePath = s32Data.FilePath,
                    SegInfo = s32Data.SegInfo
                };

                // 記錄選中的格子
                _editState.HighlightedS32Data = s32Data;
                _editState.HighlightedCellX = x;
                _editState.HighlightedCellY = y;

                // 顯示格子詳細資料
                ShowCellLayersDialog(x, y);
                return;
            }

            // 如果沒有雙擊到任何 S32 區塊，檢查是否要新增 S32
            if (e.Buttons == Eto.Forms.MouseButtons.Primary)
            {
                Point adjustedLocation = new Point(worldX, worldY);
                TryCreateS32AtClickPosition(adjustedLocation, currentMap);
            }
        }

        // 嘗試在點擊位置創建新的 S32
        private void TryCreateS32AtClickPosition(Point clickPos, Struct.L1Map currentMap)
        {
            // 從點擊像素位置反推 Block 座標
            // GetLoc 公式：
            // baseX = 0;
            // baseY = (nMapBlockCountX - 1) * blockHeight / 2;
            // mx = blockX * blockWidth + my * 2 - blockX * blockWidth / 2 - blockY * blockWidth / 2;
            // my = baseY + blockY * blockHeight - blockX * blockHeight / 2 - blockY * blockHeight / 2;
            //
            // 簡化：對於菱形地圖，使用一個參考點來計算
            // 取得一個已知 S32 的位置作為參考

            if (_document.S32Files.Count == 0)
            {
                // 如果沒有任何 S32，使用地圖的 Min Block 作為基準
                int defaultBlockX = currentMap.nMinBlockX != 0xFFFF ? currentMap.nMinBlockX : 0x7FFF;
                int defaultBlockY = currentMap.nMinBlockY != 0xFFFF ? currentMap.nMinBlockY : 0x8000;
                CreateNewS32AtBlock(defaultBlockX, defaultBlockY, currentMap);
                return;
            }

            // 取得第一個 S32 作為參考點
            var refS32 = _document.S32Files.Values.First();
            int[] refLoc = refS32.SegInfo.GetLoc(1.0);
            int refMx = refLoc[0];
            int refMy = refLoc[1];
            int refBlockX = refS32.SegInfo.nBlockX - currentMap.nMinBlockX;
            int refBlockY = refS32.SegInfo.nBlockY - currentMap.nMinBlockY;

            // 每個 S32 區塊的像素大小
            int blockWidth = 64 * 24 * 2;  // 3072
            int blockHeight = 64 * 12 * 2; // 1536

            // 參考 S32 的中心像素位置
            int refCenterX = refMx + blockWidth / 2;
            int refCenterY = refMy + blockHeight / 2;

            // 計算點擊位置相對於參考 S32 的偏移量（像素）
            int deltaPixelX = clickPos.X - refCenterX;
            int deltaPixelY = clickPos.Y - refCenterY;

            // 菱形座標系轉換：
            // 根據 GetLoc 公式：
            // mx = baseX + blockX*W - blockX*W/2 - blockY*W/2 + blockY*W = baseX + blockX*W/2 + blockY*W/2
            // my = baseY + blockY*H - blockX*H/2 - blockY*H/2 = baseY - blockX*H/2 + blockY*H/2
            //
            // 所以：
            // deltaPixelX = (dBx + dBy) * blockWidth/2
            // deltaPixelY = (-dBx + dBy) * blockHeight/2
            //
            // 反推：
            // dBx + dBy = deltaPixelX * 2 / blockWidth
            // -dBx + dBy = deltaPixelY * 2 / blockHeight
            // 2*dBy = deltaPixelX * 2 / blockWidth + deltaPixelY * 2 / blockHeight
            // 2*dBx = deltaPixelX * 2 / blockWidth - deltaPixelY * 2 / blockHeight

            double sumDelta = (double)deltaPixelX * 2 / blockWidth;
            double diffDelta = (double)deltaPixelY * 2 / blockHeight;

            int deltaBlockX = (int)Math.Round((sumDelta - diffDelta) / 2);
            int deltaBlockY = (int)Math.Round((sumDelta + diffDelta) / 2);

            // 計算目標 Block 座標
            int targetRelBlockX = refBlockX + deltaBlockX;
            int targetRelBlockY = refBlockY + deltaBlockY;

            int targetBlockX = currentMap.nMinBlockX + targetRelBlockX;
            int targetBlockY = currentMap.nMinBlockY + targetRelBlockY;

            // 檢查是否已存在
            string fileName = $"{targetBlockX:X4}{targetBlockY:X4}.s32".ToLower();
            string filePath = Path.Combine(currentMap.szFullDirName, fileName);

            if (File.Exists(filePath) || _document.S32Files.Keys.Any(k => k.EndsWith(fileName, StringComparison.OrdinalIgnoreCase)))
            {
                // 已存在，顯示提示
                this.toolStripStatusLabel1.Text = $"S32 已存在: {fileName}";
                return;
            }

            // 創建新 S32
            CreateNewS32AtBlock(targetBlockX, targetBlockY, currentMap);
        }

        // 在指定 Block 座標創建新的 S32
        private void CreateNewS32AtBlock(int blockX, int blockY, Struct.L1Map currentMap)
        {
            string fileName = $"{blockX:X4}{blockY:X4}.s32".ToLower();
            string filePath = Path.Combine(currentMap.szFullDirName, fileName);

            // 檢查是否已存在
            if (File.Exists(filePath))
            {
                WinFormsMessageBox.Show($"S32 檔案已存在: {fileName}", "錯誤", MessageBoxButtons.OK, MessageBoxIcon.Error);
                return;
            }

            if (_document.S32Files.Keys.Any(k => k.EndsWith(fileName, StringComparison.OrdinalIgnoreCase)))
            {
                WinFormsMessageBox.Show($"S32 檔案已載入: {fileName}", "錯誤", MessageBoxButtons.OK, MessageBoxIcon.Error);
                return;
            }

            // 計算遊戲座標範圍
            int linEndX = (blockX - 0x7FFF) * 64 + 0x7FFF;
            int linEndY = (blockY - 0x7FFF) * 64 + 0x7FFF;
            int linBeginX = linEndX - 64 + 1;
            int linBeginY = linEndY - 64 + 1;

            // 確認新增
            var confirmResult = WinFormsMessageBox.Show(
                $"要在此位置新增 S32 區塊嗎？\n\n" +
                $"檔案名稱: {fileName}\n" +
                $"Block座標: ({blockX:X4}, {blockY:X4})\n" +
                $"遊戲座標: ({linBeginX},{linBeginY}) ~ ({linEndX},{linEndY})\n" +
                $"路徑: {filePath}",
                "新增 S32",
                MessageBoxButtons.YesNo,
                MessageBoxIcon.Question);

            if (confirmResult != DialogResult.Yes) return;

            // 創建空的 S32 資料
            S32Data newS32Data = CreateEmptyS32Data(blockX, blockY, filePath);

            // 創建 SegInfo
            Struct.L1MapSeg segInfo = new Struct.L1MapSeg(blockX, blockY, true);
            segInfo.isRemastered = false;
            segInfo.nMapMinBlockX = currentMap.nMinBlockX;
            segInfo.nMapMinBlockY = currentMap.nMinBlockY;
            segInfo.nMapBlockCountX = currentMap.nBlockCountX;

            newS32Data.SegInfo = segInfo;
            newS32Data.IsModified = true;

            // 加入到記憶體（先加入才能用 SaveS32File）
            _document.S32Files[filePath] = newS32Data;

            // 寫入檔案
            try
            {
                SaveS32File(filePath);  // 使用正確格式的保存方法
            }
            catch (Exception ex)
            {
                // 移除失敗的 S32
                _document.S32Files.Remove(filePath);
                WinFormsMessageBox.Show($"寫入檔案失敗: {ex.Message}", "錯誤", MessageBoxButtons.OK, MessageBoxIcon.Error);
                return;
            }

            // 加入到 FullFileNameList
            currentMap.FullFileNameList[filePath] = segInfo;

            // 更新地圖邊界（如果新的 S32 超出現有邊界）
            if (blockX < currentMap.nMinBlockX || blockX > currentMap.nMaxBlockX ||
                blockY < currentMap.nMinBlockY || blockY > currentMap.nMaxBlockY)
            {
                currentMap.nMinBlockX = Math.Min(currentMap.nMinBlockX, blockX);
                currentMap.nMinBlockY = Math.Min(currentMap.nMinBlockY, blockY);
                currentMap.nMaxBlockX = Math.Max(currentMap.nMaxBlockX, blockX);
                currentMap.nMaxBlockY = Math.Max(currentMap.nMaxBlockY, blockY);
                currentMap.nBlockCountX = currentMap.nMaxBlockX - currentMap.nMinBlockX + 1;
                currentMap.nBlockCountY = currentMap.nMaxBlockY - currentMap.nMinBlockY + 1;
                currentMap.nLinLengthX = currentMap.nBlockCountX * 64;
                currentMap.nLinLengthY = currentMap.nBlockCountY * 64;
                currentMap.nLinEndX = (currentMap.nMaxBlockX - 0x7FFF) * 64 + 0x7FFF;
                currentMap.nLinEndY = (currentMap.nMaxBlockY - 0x7FFF) * 64 + 0x7FFF;
                currentMap.nLinBeginX = currentMap.nLinEndX - currentMap.nLinLengthX + 1;
                currentMap.nLinBeginY = currentMap.nLinEndY - currentMap.nLinLengthY + 1;

                // 更新所有 SegInfo 的共享值
                foreach (var seg in currentMap.FullFileNameList.Values)
                {
                    seg.nMapMinBlockX = currentMap.nMinBlockX;
                    seg.nMapMinBlockY = currentMap.nMinBlockY;
                    seg.nMapBlockCountX = currentMap.nBlockCountX;
                }
            }

            // 加入到 UI 清單
            string displayName = $"{fileName} ({blockX:X4},{blockY:X4}) [{segInfo.nLinBeginX},{segInfo.nLinBeginY}~{segInfo.nLinEndX},{segInfo.nLinEndY}]";
            S32FileItem item = new S32FileItem
            {
                FilePath = filePath,
                DisplayName = displayName,
                SegInfo = segInfo,
                IsChecked = true
            };
            // 重新載入地圖（重新讀取所有 S32 檔案）
            ReloadCurrentMap();

            this.toolStripStatusLabel1.Text = $"已新增 S32: {fileName}";
        }

        // [UpdateStatusBarWithLayer3Info 已移至 MapForm.Coordinates.cs]

        // 設定單個格子的通行性
        private void SetCellPassable(S32Data s32Data, int cellX, int cellY, bool passable)
        {
            // 計算第三層座標（第三層是 64x64，第一層是 64x128）
            int layer3X = cellX / 2;
            if (layer3X >= 64) layer3X = 63;

            // 計算遊戲座標（Layer3 尺度）
            int gameX = s32Data.SegInfo.nLinBeginX + layer3X;
            int gameY = s32Data.SegInfo.nLinBeginY + cellY;

            // 設定通行性屬性
            if (s32Data.Layer3[cellY, layer3X] == null)
            {
                s32Data.Layer3[cellY, layer3X] = new MapAttribute { Attribute1 = 0, Attribute2 = 0 };
            }

            if (passable)
            {
                // 清除不可通行屬性（Attribute1 & Attribute2 的 0x01 位元）
                s32Data.Layer3[cellY, layer3X].Attribute1 = (short)(s32Data.Layer3[cellY, layer3X].Attribute1 & ~0x01);
                s32Data.Layer3[cellY, layer3X].Attribute2 = (short)(s32Data.Layer3[cellY, layer3X].Attribute2 & ~0x01);
                this.toolStripStatusLabel1.Text = $"已設定 ({gameX},{gameY}) 為可通行";
            }
            else
            {
                // 設定不可通行屬性（Attribute1 & Attribute2 的 0x01 位元）
                s32Data.Layer3[cellY, layer3X].Attribute1 = (short)(s32Data.Layer3[cellY, layer3X].Attribute1 | 0x01);
                s32Data.Layer3[cellY, layer3X].Attribute2 = (short)(s32Data.Layer3[cellY, layer3X].Attribute2 | 0x01);
                this.toolStripStatusLabel1.Text = $"已設定 ({gameX},{gameY}) 為不可通行";
            }

            s32Data.IsModified = true;
            RenderS32Map();
        }

        // 批次設定區域通行性
        private void SetRegionPassable(List<SelectedCell> cells, bool passable)
        {
            int modifiedCount = 0;
            HashSet<S32Data> modifiedS32Files = new HashSet<S32Data>();

            foreach (var cell in cells)
            {
                // 計算第三層座標（第三層是 64x64，第一層是 64x128）
                int layer3X = cell.LocalX / 2;
                if (layer3X >= 64) layer3X = 63;

                // 確保座標在有效範圍內
                if (cell.LocalY < 0 || cell.LocalY >= 64) continue;

                // 設定通行性屬性
                if (cell.S32Data.Layer3[cell.LocalY, layer3X] == null)
                {
                    cell.S32Data.Layer3[cell.LocalY, layer3X] = new MapAttribute { Attribute1 = 0, Attribute2 = 0 };
                }

                if (passable)
                {
                    // 清除不可通行屬性（Attribute1 & Attribute2 的 0x01 位元）
                    cell.S32Data.Layer3[cell.LocalY, layer3X].Attribute1 = (short)(cell.S32Data.Layer3[cell.LocalY, layer3X].Attribute1 & ~0x01);
                    cell.S32Data.Layer3[cell.LocalY, layer3X].Attribute2 = (short)(cell.S32Data.Layer3[cell.LocalY, layer3X].Attribute2 & ~0x01);
                }
                else
                {
                    // 設定不可通行屬性（Attribute1 & Attribute2 的 0x01 位元）
                    cell.S32Data.Layer3[cell.LocalY, layer3X].Attribute1 = (short)(cell.S32Data.Layer3[cell.LocalY, layer3X].Attribute1 | 0x01);
                    cell.S32Data.Layer3[cell.LocalY, layer3X].Attribute2 = (short)(cell.S32Data.Layer3[cell.LocalY, layer3X].Attribute2 | 0x01);
                }

                modifiedCount++;
                modifiedS32Files.Add(cell.S32Data);
            }

            // 標記所有修改過的 S32 檔案
            foreach (var s32Data in modifiedS32Files)
            {
                s32Data.IsModified = true;
            }

            RenderS32Map();
            this.toolStripStatusLabel1.Text = $"已批次設定 {modifiedCount} 個格子為{(passable ? "可通行" : "不可通行")} (影響 {modifiedS32Files.Count} 個 S32 檔案)";
        }

        // 多邊形通行性設定：找出多邊形內的格子邊界，設定對應的通行屬性
        private void SetPolygonPassable(List<Point> polygonPoints, bool passable)
        {
            if (string.IsNullOrEmpty(_document.MapId) || !Share.MapDataList.ContainsKey(_document.MapId))
                return;

            if (polygonPoints.Count < 3)
            {
                this.toolStripStatusLabel1.Text = "多邊形至少需要 3 個頂點";
                return;
            }

            // 將螢幕座標轉換為世界座標（考慮縮放和捲動偏移）
            var scaledPolygon = polygonPoints.Select(p => new PointF(
                (float)(p.X / _viewState.ZoomLevel) + _viewState.ScrollX,
                (float)(p.Y / _viewState.ZoomLevel) + _viewState.ScrollY
            )).ToArray();

            // 收集多邊形內的邊界資訊 (S32Data, layer3X, layer3Y, isAttribute1)
            var includedEdges = new List<(S32Data s32, int layer3X, int layer3Y, bool isAttribute1)>();

            // 遍歷所有 S32 的所有格子，檢查邊界中點是否在多邊形內
            foreach (var s32Data in _document.S32Files.Values)
            {
                int[] loc = s32Data.SegInfo.GetLoc(1.0);
                int mx = loc[0];
                int my = loc[1];

                // Layer3 是 64x64
                for (int layer3Y = 0; layer3Y < 64; layer3Y++)
                {
                    for (int layer3X = 0; layer3X < 64; layer3X++)
                    {
                        // Layer3 座標轉 Layer1 座標（取偶數 x）
                        int x1 = layer3X * 2;

                        // 與 DrawPassabilityOverlay 完全相同的座標計算
                        int localBaseX = 0;
                        int localBaseY = 63 * 12;
                        localBaseX -= 24 * (x1 / 2);
                        localBaseY -= 12 * (x1 / 2);

                        int X = mx + localBaseX + x1 * 24 + layer3Y * 24;
                        int Y = my + localBaseY + layer3Y * 12;

                        // Layer3 菱形的四個頂點（48x24，與 DrawPassabilityOverlay 一致）
                        float pLeftX = X + 0, pLeftY = Y + 12;       // 左
                        float pTopX = X + 24, pTopY = Y + 0;         // 上
                        float pRightX = X + 48, pRightY = Y + 12;    // 右

                        // 計算左上邊的中點
                        float leftTopMidX = (pLeftX + pTopX) / 2;
                        float leftTopMidY = (pLeftY + pTopY) / 2;

                        // 計算右上邊的中點
                        float rightTopMidX = (pTopX + pRightX) / 2;
                        float rightTopMidY = (pTopY + pRightY) / 2;

                        // 檢查左上邊中點是否在多邊形內
                        if (IsPointInPolygon(leftTopMidX, leftTopMidY, scaledPolygon))
                        {
                            includedEdges.Add((s32Data, layer3X, layer3Y, true));  // Attribute1
                        }

                        // 檢查右上邊中點是否在多邊形內
                        if (IsPointInPolygon(rightTopMidX, rightTopMidY, scaledPolygon))
                        {
                            includedEdges.Add((s32Data, layer3X, layer3Y, false)); // Attribute2
                        }
                    }
                }
            }

            // 去除重複
            var uniqueEdges = includedEdges.Distinct().ToList();

            if (uniqueEdges.Count == 0)
            {
                this.toolStripStatusLabel1.Text = "多邊形內沒有任何格子邊界";
                return;
            }

            // 設定通行性
            int modifiedCount = 0;
            HashSet<S32Data> modifiedS32Files = new HashSet<S32Data>();

            foreach (var (s32Data, layer3X, layer3Y, isAttribute1) in uniqueEdges)
            {
                if (s32Data.Layer3[layer3Y, layer3X] == null)
                {
                    s32Data.Layer3[layer3Y, layer3X] = new MapAttribute { Attribute1 = 0, Attribute2 = 0 };
                }

                if (isAttribute1)
                {
                    if (passable)
                        s32Data.Layer3[layer3Y, layer3X].Attribute1 = (short)(s32Data.Layer3[layer3Y, layer3X].Attribute1 & ~0x01);
                    else
                        s32Data.Layer3[layer3Y, layer3X].Attribute1 = (short)(s32Data.Layer3[layer3Y, layer3X].Attribute1 | 0x01);
                }
                else
                {
                    if (passable)
                        s32Data.Layer3[layer3Y, layer3X].Attribute2 = (short)(s32Data.Layer3[layer3Y, layer3X].Attribute2 & ~0x01);
                    else
                        s32Data.Layer3[layer3Y, layer3X].Attribute2 = (short)(s32Data.Layer3[layer3Y, layer3X].Attribute2 | 0x01);
                }

                modifiedCount++;
                modifiedS32Files.Add(s32Data);
            }

            // 標記所有修改過的 S32 檔案
            foreach (var s32Data in modifiedS32Files)
            {
                s32Data.IsModified = true;
            }

            RenderS32Map();
            this.toolStripStatusLabel1.Text = $"已設定 {modifiedCount} 個邊界為{(passable ? "可通行" : "不可通行")} (影響 {modifiedS32Files.Count} 個 S32 檔案)";
        }

        // 檢查點是否在多邊形內（射線法）
        private bool IsPointInPolygon(float px, float py, PointF[] polygon)
        {
            bool inside = false;
            int j = polygon.Length - 1;

            for (int i = 0; i < polygon.Length; i++)
            {
                if ((polygon[i].Y < py && polygon[j].Y >= py || polygon[j].Y < py && polygon[i].Y >= py)
                    && (polygon[i].X <= px || polygon[j].X <= px))
                {
                    if (polygon[i].X + (py - polygon[i].Y) / (polygon[j].Y - polygon[i].Y) * (polygon[j].X - polygon[i].X) < px)
                    {
                        inside = !inside;
                    }
                }
                j = i;
            }

            return inside;
        }

        // S32 地圖鼠標按下事件 - 開始區域選擇或拖拽移動
        private void s32PictureBox_MouseDown(object sender, MouseEventArgs e)
        {
            // 點擊主地圖時清除小地圖焦點
            _interaction.IsMiniMapFocused = false;

            // 清除群組高亮（點擊地圖任意位置時）
            if (_editState.GroupHighlightCells.Count > 0)
            {
                _editState.ClearGroupHighlight();
                RenderS32Map();
            }

            // 中鍵拖拽移動視圖
            if (e.Buttons == Eto.Forms.MouseButtons.Middle)
            {
                _logger.Debug($"[DRAG] Drag start at ({e.Location.X},{e.Location.Y}), scroll=({_viewState.ScrollX},{_viewState.ScrollY})");
                _interaction.StartMainMapDrag(e.Location.ToPoint(), _viewState.ScrollX, _viewState.ScrollY);
                this._mapViewerControl.Cursor = Cursors.SizeAll;

                // 停止渲染計時器，避免拖曳中觸發新渲染
                dragRenderTimer.Stop();

                // 取消正在進行的背景渲染（釋放 GDI+ 鎖，避免 UI 凍結）
                if (_isRendering)
                {
                    LogPerf($"[DRAG-START] Cancelling render...");
                    lock (_viewportRenderLock)
                    {
                        _viewportRenderCts?.Cancel();
                    }
                }
                else
                {
                    LogPerf($"[DRAG-START] No render in progress");
                }

                // 重置拖曳效能計數器
                _dragMoveCount = 0;
                _dragPaintCount = 0;
                _dragSessionSw.Restart();
                return;
            }

            // 先檢查 Layer8 marker 點擊（不需要選取 S32）
            if (e.Buttons == Eto.Forms.MouseButtons.Primary && ControlCompat.ModifierKeys == Keys.None && _viewState.ShowLayer8)
            {
                var worldPoint = S32ScreenToWorld((int)e.Location.X, (int)e.Location.Y);
                var clickedMarker = FindLayer8MarkerAtPosition(worldPoint.X, worldPoint.Y);
                if (clickedMarker.HasValue)
                {
                    var (s32Path, index) = clickedMarker.Value;
                    Console.WriteLine($"[Layer8] Clicked marker: {s32Path} index={index}");

                    // 切換顯示狀態
                    if (_editState.EnabledLayer8Items.Contains((s32Path, index)))
                    {
                        _editState.EnabledLayer8Items.Remove((s32Path, index));
                        _renderCache.Layer8AnimFrame.Remove((s32Path, index));

                        if (_editState.EnabledLayer8Items.Count == 0 && _layer8AnimTimer != null)
                        {
                            _layer8AnimTimer.Stop();
                        }
                        Console.WriteLine($"[Layer8] Disabled marker");
                    }
                    else
                    {
                        _editState.EnabledLayer8Items.Add((s32Path, index));
                        _renderCache.Layer8AnimFrame[(s32Path, index)] = 0;

                        if (_layer8AnimTimer != null && !_layer8AnimTimer.Enabled)
                        {
                            _layer8AnimTimer.Start();
                        }
                        Console.WriteLine($"[Layer8] Enabled marker, total enabled: {_editState.EnabledLayer8Items.Count}");
                    }

                    // 重繪
                    RenderS32Map();
                    return;
                }
            }

            if (currentS32Data == null || currentS32FileItem == null)
                return;

            // 左鍵：開始區域選擇（Layer8 點擊已在前面處理）
            // 支援 Shift 擴大選取
            bool isShiftHeld = (ControlCompat.ModifierKeys & Keys.Shift) == Keys.Shift;
            bool isNoOtherModifier = (ControlCompat.ModifierKeys & ~Keys.Shift) == Keys.None;

            if (e.Buttons == Eto.Forms.MouseButtons.Primary && isNoOtherModifier && _pendingMaterial == null)
            {
                // 取得當前點擊位置的遊戲座標
                var (clickGameX, clickGameY, _, _, _) = ScreenToGameCoords((int)e.Location.X, (int)e.Location.Y);

                if (isShiftHeld && _interaction.HasSelectionAnchor && clickGameX >= 0)
                {
                    // Shift 擴大選取：從錨點到當前點擊位置
                    int anchorX = _interaction.SelectionAnchorGameCoord.X;
                    int anchorY = _interaction.SelectionAnchorGameCoord.Y;

                    // 計算選取範圍（限制最大 150x150）
                    const int MaxSelectionSize = 150;
                    int minGameX = Math.Min(anchorX, clickGameX);
                    int maxGameX = Math.Max(anchorX, clickGameX);
                    int minGameY = Math.Min(anchorY, clickGameY);
                    int maxGameY = Math.Max(anchorY, clickGameY);

                    // 限制選取範圍
                    if (maxGameX - minGameX >= MaxSelectionSize)
                    {
                        if (clickGameX > anchorX)
                            maxGameX = minGameX + MaxSelectionSize - 1;
                        else
                            minGameX = maxGameX - MaxSelectionSize + 1;
                    }
                    if (maxGameY - minGameY >= MaxSelectionSize)
                    {
                        if (clickGameY > anchorY)
                            maxGameY = minGameY + MaxSelectionSize - 1;
                        else
                            minGameY = maxGameY - MaxSelectionSize + 1;
                    }

                    // 取得候選 S32 列表
                    var candidateS32s = _document.S32Files.Values.ToList();

                    // 直接使用遊戲座標選取格子
                    _editState.SelectedCells = CoordinateHelper.GetCellsInGameCoordRange(
                        minGameX, maxGameX, minGameY, maxGameY,
                        candidateS32s, currentS32Data);

                    if (_editState.SelectedCells.Count > 0)
                    {
                        selectedRegion = GetAlignedBoundsFromCells(_editState.SelectedCells);
                    }

                    isSelectingRegion = false;  // 不進入拖曳選取模式
                    _interaction.IsLayer4CopyMode = true;

                    // 更新狀態
                    int selWidth = maxGameX - minGameX + 1;
                    int selHeight = maxGameY - minGameY + 1;
                    this.toolStripStatusLabel1.Text = $"已選取 {_editState.SelectedCells.Count} 格 ({selWidth}x{selHeight})，按 Ctrl+C 複製";

                    _mapViewerControl.InvalidateOverlay();
                }
                else
                {
                    // 一般選取：開始拖曳選取
                    isSelectingRegion = true;
                    _interaction.IsLayer4CopyMode = true;  // 進入複製模式
                    _interaction.RegionStartPoint = e.Location.ToPoint();
                    regionEndPoint = e.Location.ToPoint();
                    selectedRegion = new Rectangle();

                    // 儲存錨點（遊戲座標）
                    if (clickGameX >= 0)
                    {
                        _interaction.SelectionAnchorGameCoord = new Point(clickGameX, clickGameY);
                    }

                    this.toolStripStatusLabel1.Text = "選取區域... (放開後按 Ctrl+C 複製，Shift+點擊擴大選取)";
                }
            }
        }

        // S32 地圖鼠標移動事件 - 更新選擇區域或拖拽移動
        private void s32PictureBox_MouseMove(object sender, MouseEventArgs e)
        {
            var totalSw = Stopwatch.StartNew();

            // 中鍵拖拽移動視圖
            if (_interaction.IsMainMapDragging)
            {
                // 每 50 次記錄一次，避免 log 過多
                if (_dragMoveCount % 50 == 0)
                {
                    LogPerf($"[DRAG-MOVE] count={_dragMoveCount}");
                }

                int deltaX = (int)e.Location.X - _interaction.MainMapDragStartPoint.X;
                int deltaY = (int)e.Location.Y - _interaction.MainMapDragStartPoint.Y;

                // 計算新的捲動位置（世界座標，需要除以縮放）
                int newScrollX = _interaction.MainMapDragStartScroll.X - (int)(deltaX / _viewState.ZoomLevel);
                int newScrollY = _interaction.MainMapDragStartScroll.Y - (int)(deltaY / _viewState.ZoomLevel);

                // 限制在有效範圍內（使用 ViewState 的限制，含緩衝區）
                newScrollX = Math.Max(_viewState.MinScrollX, Math.Min(newScrollX, _viewState.MaxScrollX));
                newScrollY = Math.Max(_viewState.MinScrollY, Math.Min(newScrollY, _viewState.MaxScrollY));

                // 更新 ViewState 的捲動位置
                _viewState.SetScrollSilent(newScrollX, newScrollY);

                // 標記需要重繪（讓 OS 批次處理 Paint 訊息，避免同步阻塞）
                _mapViewerControl.Refresh();
                _dragMoveCount++;
                return;
            }

            // 更新狀態列顯示遊戲座標（拖曳時跳過）
            var statusSw = Stopwatch.StartNew();
            UpdateStatusBarWithGameCoords((int)e.Location.X, (int)e.Location.Y);
            statusSw.Stop();

            if (isSelectingRegion)
            {
                regionEndPoint = e.Location.ToPoint();

                // 計算起點到終點之間的格子範圍（所有模式都對齊格線）
                var cellsSw = Stopwatch.StartNew();
                _editState.SelectedCells = GetCellsInIsometricRange(_interaction.RegionStartPoint, regionEndPoint);
                cellsSw.Stop();

                var boundsSw = Stopwatch.StartNew();
                if (_editState.SelectedCells.Count > 0)
                {
                    selectedRegion = GetAlignedBoundsFromCells(_editState.SelectedCells);
                }
                boundsSw.Stop();

                // 重繪覆蓋層以顯示選擇框（不需要重新渲染地圖）
                var invalidateSw = Stopwatch.StartNew();
                _mapViewerControl.InvalidateOverlay();
                invalidateSw.Stop();

                totalSw.Stop();
                LogPerf($"[MOUSE-MOVE-SELECT] status={statusSw.ElapsedMilliseconds}ms, cells={cellsSw.ElapsedMilliseconds}ms ({_editState.SelectedCells.Count}), bounds={boundsSw.ElapsedMilliseconds}ms, invalidate={invalidateSw.ElapsedMilliseconds}ms, total={totalSw.ElapsedMilliseconds}ms");
            }
        }

        // [UpdateStatusBarWithGameCoords 已移至 MapForm.Coordinates.cs]

        // S32 地圖鼠標釋放事件 - 完成區域選擇並執行批量操作
        private void s32PictureBox_MouseUp(object sender, MouseEventArgs e)
        {
            var totalSw = Stopwatch.StartNew();

            // 結束中鍵拖拽
            if (e.Buttons == Eto.Forms.MouseButtons.Middle && _interaction.IsMainMapDragging)
            {
                var upSw = Stopwatch.StartNew();
                _dragSessionSw.Stop();
                long dragMs = _dragSessionSw.ElapsedMilliseconds;
                double fps = dragMs > 0 ? (_dragPaintCount * 1000.0 / dragMs) : 0;

                // 輸出拖曳效能統計
                _logger.Debug($"[DRAG] Drag end: duration={dragMs}ms, moves={_dragMoveCount}, paints={_dragPaintCount}, FPS={fps:F1}");
                LogPerf($"[DRAG-END] duration={dragMs}ms, moves={_dragMoveCount}, paints={_dragPaintCount}, FPS={fps:F1}");

                _interaction.EndDrag();
                this._mapViewerControl.Cursor = Cursors.Default;

                // 延遲更新 MiniMap 紅框，避免阻塞拖曳結束事件
                this.BeginInvoke((MethodInvoker)delegate { UpdateMiniMapViewportRect(); });

                // 拖曳結束後重新渲染
                _logger.Debug("[DRAG] Calling RenderS32Map after drag end");
                RenderS32Map();

                upSw.Stop();
                _logger.Debug($"[DRAG] Mouse up complete in {upSw.ElapsedMilliseconds}ms");
                LogPerf($"[MOUSE-UP-MIDDLE] total={upSw.ElapsedMilliseconds}ms");
                return;
            }

            // 素材貼上模式：左鍵點擊貼上素材
            if (_pendingMaterial != null && e.Buttons == Eto.Forms.MouseButtons.Primary && !isSelectingRegion)
            {
                // 將螢幕座標轉換為世界座標
                var worldPoint = S32ScreenToWorld((int)e.Location.X, (int)e.Location.Y);
                int worldX = worldPoint.X;
                int worldY = worldPoint.Y;

                // 找到點擊的格子
                var result = CellFinder.FindCellOptimized(worldX, worldY, _document.S32Files.Values);
                if (result.Found)
                {
                    var (gameX, gameY) = CoordinateHelper.LocalToGameCoords(result.S32Data, result.CellX, result.CellY);
                    PasteMaterialAtPosition(gameX, gameY);
                }
                return;
            }

            if (isSelectingRegion && e.Buttons == Eto.Forms.MouseButtons.Primary)
            {
                isSelectingRegion = false;

                // Layer4 複製模式：保留選取範圍，等待 Ctrl+C 或 Ctrl+V
                if (_interaction.IsLayer4CopyMode)
                {
                    var boundsSw = Stopwatch.StartNew();
                    // _editState.SelectedCells 已在 MouseMove 中更新
                    if (_editState.SelectedCells.Count > 0)
                    {
                        // 計算所有選中格子的螢幕座標邊界
                        copyRegionBounds = GetAlignedBoundsFromCells(_editState.SelectedCells);
                        selectedRegion = copyRegionBounds;
                    }
                    else
                    {
                        copyRegionBounds = selectedRegion;
                    }
                    boundsSw.Stop();

                    // 計算選取區域的全域 Layer1 座標原點（使用選中格子中最小的 X, Y 作為原點）
                    var originSw = Stopwatch.StartNew();
                    int globalX = -1, globalY = -1;
                    int gameX = -1, gameY = -1;
                    if (_editState.SelectedCells.Count > 0)
                    {
                        // 找出所有選中格子的最小全域 Layer1 座標
                        int minGlobalX = int.MaxValue, minGlobalY = int.MaxValue;
                        foreach (var cell in _editState.SelectedCells)
                        {
                            // nLinBeginX 是 Layer3 座標，乘以 2 轉成 Layer1，再加上 cell.LocalX
                            int cellGlobalX = cell.S32Data.SegInfo.nLinBeginX * 2 + cell.LocalX;
                            int cellGlobalY = cell.S32Data.SegInfo.nLinBeginY + cell.LocalY;
                            if (cellGlobalX < minGlobalX) minGlobalX = cellGlobalX;
                            if (cellGlobalY < minGlobalY) minGlobalY = cellGlobalY;
                        }
                        globalX = minGlobalX;
                        globalY = minGlobalY;
                        // 計算遊戲座標（Layer3 尺度）
                        gameX = globalX / 2;
                        gameY = globalY;
                    }
                    _editState.CopyRegionOrigin = new Point(globalX, globalY);
                    originSw.Stop();

                    // 更新移動指令（顯示選取第一格的座標）
                    if (gameX >= 0 && gameY >= 0)
                    {
                        _editState.SelectedGameX = gameX;
                        _editState.SelectedGameY = gameY;
                        toolStripCopyMoveCmd.Enabled = true;
                        toolStripCopyMoveCmd.Text = $"移動 {gameX} {gameY} {_document.MapId}";
                        // 同步狀態列按鈕
                        if (_statusBtnCopyMoveCmd != null)
                        {
                            _statusBtnCopyMoveCmd.Enabled = true;
                            _statusBtnCopyMoveCmd.Text = $"移動 {gameX} {gameY} {_document.MapId}";
                        }
                    }

                    // 根據是否有剪貼簿資料顯示不同提示（顯示遊戲座標）
                    if (hasLayer4Clipboard && _editState.CellClipboard.Count > 0)
                    {
                        this.toolStripStatusLabel1.Text = $"已選取貼上位置 (遊戲座標: {gameX}, {gameY})，按 Ctrl+V 貼上 {_editState.CellClipboard.Count} 格資料，選中 {_editState.SelectedCells.Count} 格";
                    }
                    else
                    {
                        this.toolStripStatusLabel1.Text = $"已選取區域 (遊戲座標: {gameX}, {gameY})，選中 {_editState.SelectedCells.Count} 格，按 Ctrl+C 複製";
                    }

                    // 更新群組縮圖列表
                    var thumbSw = Stopwatch.StartNew();
                    if (_editState.IsLayer5EditMode && _editState.SelectedCells.Count > 0)
                    {
                        // 透明編輯模式：使用選取區域第一格的位置顯示附近群組（有 L5 設定的排前面）
                        var firstCell = _editState.SelectedCells[0];
                        UpdateNearbyGroupThumbnails(firstCell.S32Data, firstCell.LocalX, firstCell.LocalY, 10);
                    }
                    else
                    {
                        // 一般模式：顯示選取區域內的群組
                        UpdateGroupThumbnailsList(_editState.SelectedCells);
                    }
                    thumbSw.Stop();

                    // 重新渲染以確保選取區域的 S32 都有顯示
                    RenderS32Map();

                    // 更新選取區域涉及的 S32 檔案資訊
                    UpdateSelectionS32Info();

                    totalSw.Stop();
                    LogPerf($"[MOUSE-UP-SELECT] bounds={boundsSw.ElapsedMilliseconds}ms, origin={originSw.ElapsedMilliseconds}ms, thumb={thumbSw.ElapsedMilliseconds}ms, total={totalSw.ElapsedMilliseconds}ms, cells={_editState.SelectedCells.Count}");
                    return;
                }

                // 找出選中區域內的所有格子
                var cellsSw = Stopwatch.StartNew();
                List<SelectedCell> selectedCells = GetCellsInRegion(selectedRegion);
                cellsSw.Stop();

                if (selectedCells.Count > 0)
                {
                    // 刪除模式：批次刪除物件
                    var deleteSw = Stopwatch.StartNew();
                    DeleteAllLayer4ObjectsInRegion(selectedCells);
                    deleteSw.Stop();
                    totalSw.Stop();
                    LogPerf($"[MOUSE-UP-DELETE] cells={cellsSw.ElapsedMilliseconds}ms, delete={deleteSw.ElapsedMilliseconds}ms, total={totalSw.ElapsedMilliseconds}ms");
                }

                // 清除選擇框
                selectedRegion = new Rectangle();
                _mapViewerControl.Refresh();
            }

            // 右鍵顯示選取區域操作選單（通行編輯模式時會包含通行設定選項）
            if (e.Buttons == Eto.Forms.MouseButtons.Alternate && _interaction.IsLayer4CopyMode && _editState.SelectedCells.Count > 0)
            {
                ShowSelectionContextMenu(e.Location.ToPoint());
                return;
            }

        }

        // 顯示選取區域右鍵選單
        private void ShowSelectionContextMenu(Point location)
        {
            var menu = new ContextMenuStrip();

            // 查看詳細資料（使用滑鼠位置的格子，或第一個選中的格子）
            var coords = ScreenToGameCoords(location.X, location.Y);
            SelectedCell detailCell = null;
            if (coords.s32Data != null)
            {
                // 優先使用滑鼠位置的格子
                detailCell = _editState.SelectedCells.FirstOrDefault(c =>
                    c.S32Data == coords.s32Data && c.LocalX == coords.localX && c.LocalY == coords.localY);
            }
            if (detailCell == null && _editState.SelectedCells.Count > 0)
            {
                detailCell = _editState.SelectedCells[0];
            }

            if (detailCell != null)
            {
                var detailItem = new ToolStripMenuItem("查看詳細資料...");
                detailItem.Click += (s, e) => {
                    _editState.HighlightedS32Data = detailCell.S32Data;
                    _editState.HighlightedCellX = detailCell.LocalX;
                    _editState.HighlightedCellY = detailCell.LocalY;
                    ShowCellLayersDialog(detailCell.LocalX, detailCell.LocalY);
                };
                menu.Items.Add(detailItem);
                menu.Items.Add(new ToolStripSeparator());
            }

            var exportFs32Item = new ToolStripMenuItem("匯出為 fs32 地圖包...");
            exportFs32Item.Click += (s, e) => ExportSelectionAsFs32();
            menu.Items.Add(exportFs32Item);

            var saveAsFs3pItem = new ToolStripMenuItem("儲存為素材 (fs3p)...");
            saveAsFs3pItem.Click += (s, e) => SaveSelectionAsMaterial();
            menu.Items.Add(saveAsFs3pItem);

            menu.Items.Add(new ToolStripSeparator());

            var copyItem = new ToolStripMenuItem("複製 (Ctrl+C)");
            copyItem.Click += (s, e) => CopySelectedCells();
            menu.Items.Add(copyItem);

            // 用剪貼簿的地板填滿選取區
            bool hasLayer1InClipboard = _editState.CellClipboard.Any(c => c.Layer1Cell1 != null || c.Layer1Cell2 != null);
            var fillWithFloorItem = new ToolStripMenuItem("用複製中的地板填滿選取區");
            fillWithFloorItem.Enabled = hasLayer1InClipboard && _editState.SelectedCells.Count > 0;
            fillWithFloorItem.Click += (s, e) => FillSelectionWithClipboardFloor();
            menu.Items.Add(fillWithFloorItem);

            var clearItem = new ToolStripMenuItem("清除選取區域資料...");
            clearItem.Click += (s, e) => ClearSelectedCellsWithDialog();
            menu.Items.Add(clearItem);

            menu.Items.Add(new ToolStripSeparator());

            var showGroupAreaItem = new ToolStripMenuItem("顯示區域群組所在位置");
            showGroupAreaItem.Click += (s, e) => ShowGroupsInSelectedArea();
            menu.Items.Add(showGroupAreaItem);

            // 通行編輯模式：加入通行性設定選項
            if (currentPassableEditMode == PassableEditMode.Editing)
            {
                int cellCount = _editState.SelectedCells.Count;
                menu.Items.Add(new ToolStripSeparator());

                // 左上
                var leftTopPassable = new ToolStripMenuItem($"左上 可通行 ({cellCount} 格)");
                leftTopPassable.Click += (s, ev) => SetSelectedCellsPassability(PassabilityTarget.LeftTop, true);
                menu.Items.Add(leftTopPassable);

                var leftTopImpassable = new ToolStripMenuItem($"左上 不可通行 ({cellCount} 格)");
                leftTopImpassable.Click += (s, ev) => SetSelectedCellsPassability(PassabilityTarget.LeftTop, false);
                menu.Items.Add(leftTopImpassable);

                menu.Items.Add(new ToolStripSeparator());

                // 右上
                var rightTopPassable = new ToolStripMenuItem($"右上 可通行 ({cellCount} 格)");
                rightTopPassable.Click += (s, ev) => SetSelectedCellsPassability(PassabilityTarget.RightTop, true);
                menu.Items.Add(rightTopPassable);

                var rightTopImpassable = new ToolStripMenuItem($"右上 不可通行 ({cellCount} 格)");
                rightTopImpassable.Click += (s, ev) => SetSelectedCellsPassability(PassabilityTarget.RightTop, false);
                menu.Items.Add(rightTopImpassable);

                menu.Items.Add(new ToolStripSeparator());

                // 左下（實際設定鄰近格子的右上）
                var leftBottomPassable = new ToolStripMenuItem($"左下 可通行 ({cellCount} 格)");
                leftBottomPassable.Click += (s, ev) => SetSelectedCellsPassability(PassabilityTarget.LeftBottom, true);
                menu.Items.Add(leftBottomPassable);

                var leftBottomImpassable = new ToolStripMenuItem($"左下 不可通行 ({cellCount} 格)");
                leftBottomImpassable.Click += (s, ev) => SetSelectedCellsPassability(PassabilityTarget.LeftBottom, false);
                menu.Items.Add(leftBottomImpassable);

                menu.Items.Add(new ToolStripSeparator());

                // 右下（實際設定鄰近格子的左上）
                var rightBottomPassable = new ToolStripMenuItem($"右下 可通行 ({cellCount} 格)");
                rightBottomPassable.Click += (s, ev) => SetSelectedCellsPassability(PassabilityTarget.RightBottom, true);
                menu.Items.Add(rightBottomPassable);

                var rightBottomImpassable = new ToolStripMenuItem($"右下 不可通行 ({cellCount} 格)");
                rightBottomImpassable.Click += (s, ev) => SetSelectedCellsPassability(PassabilityTarget.RightBottom, false);
                menu.Items.Add(rightBottomImpassable);

                menu.Items.Add(new ToolStripSeparator());

                // 整格（四個邊全部）
                var allPassable = new ToolStripMenuItem($"整格 可通行 ({cellCount} 格)");
                allPassable.Click += (s, ev) => SetSelectedCellsPassability(PassabilityTarget.All, true);
                menu.Items.Add(allPassable);

                var allImpassable = new ToolStripMenuItem($"整格 不可通行 ({cellCount} 格)");
                allImpassable.Click += (s, ev) => SetSelectedCellsPassability(PassabilityTarget.All, false);
                menu.Items.Add(allImpassable);
            }

            // 新增 S32 選項（在任何情況下都顯示，方便在延伸區新增 S32）
            if (Share.MapDataList.ContainsKey(_document.MapId))
            {
                menu.Items.Add(new ToolStripSeparator());

                // 將螢幕座標轉換為世界座標
                var worldPoint = S32ScreenToWorld(location.X, location.Y);
                var currentMap = Share.MapDataList[_document.MapId];
                var (blockX, blockY) = EstimateBlockCoordinates(new Point(worldPoint.X, worldPoint.Y), currentMap);
                string fileName = $"{blockX:X4}{blockY:X4}.s32".ToLower();

                var addS32Item = new ToolStripMenuItem($"➕ 在此位置新增 S32 區塊 ({fileName})...");
                addS32Item.Click += (s, e) => TryCreateS32AtClickPosition(new Point(worldPoint.X, worldPoint.Y), currentMap);
                menu.Items.Add(addS32Item);
            }

            menu.Show(_mapViewerControl, location);
        }

        // 更新選取區域涉及的 S32 檔案資訊
        private void UpdateSelectionS32Info()
        {
            if (_editState.SelectedCells.Count == 0)
            {
                // 沒有選取時清除高亮
                ClearS32ListHighlight();
                return;
            }

            // 收集選取區域涉及的 S32 檔案
            var involvedS32s = new HashSet<string>();
            foreach (var cell in _editState.SelectedCells)
            {
                if (cell.S32Data != null && !string.IsNullOrEmpty(cell.S32Data.FilePath))
                {
                    involvedS32s.Add(cell.S32Data.FilePath);
                }
            }

            if (involvedS32s.Count == 0)
                return;

            // 更新 lblS32Info 顯示涉及的 S32 檔案
            var s32Names = involvedS32s.Select(p => Path.GetFileName(p)).OrderBy(n => n).ToList();
            string s32List = string.Join(", ", s32Names.Take(5));
            if (s32Names.Count > 5)
                s32List += $" ... 共 {s32Names.Count} 個";

            lblS32Info.Text = $"選取 {_editState.SelectedCells.Count} 格 | 涉及 S32: {s32List}";

            // 高亮 lstS32Files 中的相關項目
            HighlightS32ListItems(involvedS32s);
        }

        // 高亮 S32 檔案清單中的項目
        private void HighlightS32ListItems(HashSet<string> filePaths)
        {
            // 先清除之前的高亮
            lstS32Files.Invalidate();

            // 找到第一個匹配的項目並捲動到該位置
            for (int i = 0; i < lstS32Files.Items.Count; i++)
            {
                if (lstS32Files.Items[i] is S32FileItem item && filePaths.Contains(item.FilePath))
                {
                    // 選中第一個匹配的項目（讓它可見）
                    lstS32Files.SelectedIndex = i;
                    break;
                }
            }

            // 儲存需要高亮的檔案路徑供繪製使用
            _highlightedS32Paths = filePaths;
            lstS32Files.Invalidate();
        }

        // 清除 S32 檔案清單高亮
        private void ClearS32ListHighlight()
        {
            _highlightedS32Paths = null;
            lstS32Files.Invalidate();
        }

        // 需要高亮的 S32 檔案路徑
        private HashSet<string> _highlightedS32Paths = null;

        // 匯出選取區域為 fs32
        private void ExportSelectionAsFs32()
        {
            if (_editState.SelectedCells.Count == 0)
            {
                WinFormsMessageBox.Show("請先選取區域", "提示", MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            // 收集選取區域涉及的 S32 檔案
            var involvedS32s = new Dictionary<string, S32Data>();
            foreach (var cell in _editState.SelectedCells)
            {
                if (cell.S32Data != null)
                {
                    // 從 _document.S32Files 找到對應的 key
                    var matchingEntry = _document.S32Files.FirstOrDefault(kvp => kvp.Value == cell.S32Data);
                    if (!string.IsNullOrEmpty(matchingEntry.Key) && !involvedS32s.ContainsKey(matchingEntry.Key))
                        involvedS32s[matchingEntry.Key] = cell.S32Data;
                }
            }

            using (var dialog = new L1MapViewer.Forms.ExportOptionsDialog(isFs3p: false, hasSelection: true))
            {
                if (dialog.ShowDialog(this) != DialogResult.Ok)
                    return;

                // 檢查異常（匯出不檢查 Tile 上限，若會移除 L8 擴展則不檢查）
                if (!CheckLayer5IssuesAndConfirm(involvedS32s, "匯出", checkTileLimit: false, checkLayer8Extended: !dialog.StripLayer8Ext))
                    return;

                // 根據模式決定要使用的 S32 清單
                IEnumerable<S32Data> s32ListForSpr = dialog.SelectedMode == L1MapViewer.Forms.ExportOptionsDialog.ExportMode.WholeMap
                    ? _document.S32Files.Values
                    : involvedS32s.Values;

                // 預先準備 Layer8 SPR 打包（在 SaveFileDialog 之前）
                var (sprListPath, sprIds) = PrepareLayer8SprPackaging(s32ListForSpr, dialog.LayerFlags);

                using (var saveDialog = new SaveFileDialog())
                {
                    saveDialog.Filter = "FS32 地圖包|*.fs32";
                    saveDialog.FileName = $"{_document.MapId}_export.fs32";

                    if (saveDialog.ShowDialog(this) != DialogResult.Ok)
                        return;

                    try
                    {
                        Fs32Data fs32;
                        if (dialog.SelectedMode == L1MapViewer.Forms.ExportOptionsDialog.ExportMode.WholeMap)
                        {
                            fs32 = Fs32Writer.CreateFromMap(_document, dialog.LayerFlags, dialog.IncludeTiles, dialog.StripLayer8Ext);
                        }
                        else
                        {
                            fs32 = Fs32Writer.CreateFromS32List(involvedS32s.Values.ToList(), _document.MapId, dialog.LayerFlags, dialog.IncludeTiles, dialog.StripLayer8Ext);
                        }

                        // 使用共用方法處理 R版 tiles 和 Layer8 SPR
                        ProcessFs32BeforeSave(fs32, dialog.IncludeTiles, sprListPath, sprIds);

                        Fs32Writer.Write(fs32, saveDialog.FileName);

                        string resultMsg = $"已匯出至 {saveDialog.FileName}\n({fs32.Blocks.Count} 區塊, {fs32.Tiles.Count} 圖塊, {fs32.Sprs.Count} SPR)";
                        toolStripStatusLabel1.Text = resultMsg.Replace("\n", " ");
                        ShowAutoCloseMessage(resultMsg, "匯出完成");
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine($"[ExportSelectionAsFs32] Error: {ex}");
                        WinFormsMessageBox.Show($"匯出失敗: {ex.Message}\n\n{ex.StackTrace}", "錯誤", MessageBoxButtons.OK, MessageBoxIcon.Error);
                    }
                }
            }
        }

        /// <summary>
        /// 預先準備 Layer8 SPR 打包（在 SaveFileDialog 之前呼叫）
        /// </summary>
        /// <returns>list.spr 路徑，若使用者取消或無 SPR 則返回 null</returns>
        private (string sprListPath, HashSet<int> sprIds) PrepareLayer8SprPackaging(IEnumerable<S32Data> s32List, ushort layerFlags)
        {
            if ((layerFlags & 0x80) == 0)  // Layer8 未勾選
                return (null, null);

            var sprIds = new HashSet<int>();
            foreach (var s32 in s32List)
            {
                foreach (var l8 in s32.Layer8)
                {
                    if (l8.SprId > 0)
                        sprIds.Add(l8.SprId);
                }
            }

            if (sprIds.Count == 0)
                return (null, null);

            var sprResult = WinFormsMessageBox.Show(
                $"Layer8 包含 {sprIds.Count} 個 SPR 項目。\n\n" +
                "是否要將 SPR 檔案一起打包？\n" +
                "（需要提供 list.spr 編碼檔）",
                "Layer8 SPR 打包",
                MessageBoxButtons.YesNo,
                MessageBoxIcon.Question);

            if (sprResult != DialogResult.Yes)
                return (null, null);

            // 選擇 list.spr 檔案
            using (var openDialog = new OpenFileDialog())
            {
                openDialog.Title = "選擇 list.spr 編碼檔";
                openDialog.Filter = "list.spr 編碼檔|list.spr;*.txt|所有檔案|*.*";
                openDialog.FileName = "list.spr";

                if (openDialog.ShowDialog(this) != DialogResult.Ok)
                    return (null, null);

                return (openDialog.FileName, sprIds);
            }
        }

        /// <summary>
        /// fs32 儲存前的共用處理（R版 tile 轉換 + Layer8 SPR 打包）
        /// </summary>
        /// <param name="sprListPath">預先選擇的 list.spr 路徑，null 表示不打包 SPR</param>
        /// <param name="sprIds">要打包的 SPR ID 集合</param>
        private void ProcessFs32BeforeSave(Fs32Data fs32, bool includeTiles, string sprListPath = null, HashSet<int> sprIds = null)
        {
            // 1. 處理 R版 tiles 轉換
            if (includeTiles && fs32.Tiles.Count > 0)
            {
                int remasterCount = fs32.Tiles.Values.Count(t => L1MapViewer.Converter.L1Til.IsRemaster(t.TilData));
                if (remasterCount > 0)
                {
                    var result = WinFormsMessageBox.Show(
                        $"地圖包中有 {remasterCount} 個 R版 (48x48) 圖塊。\n\n" +
                        "是否要轉換為天1格式 (24x24)？\n\n" +
                        "• 是 - 轉換為天1格式 (檔案較小，相容舊版)\n" +
                        "• 否 - 保留 R版格式",
                        "R版圖塊偵測",
                        MessageBoxButtons.YesNo,
                        MessageBoxIcon.Question,
                        MessageBoxDefaultButton.Button1);

                    if (result == DialogResult.Yes)
                    {
                        foreach (var tileId in fs32.Tiles.Keys.ToList())
                        {
                            var tile = fs32.Tiles[tileId];
                            if (L1MapViewer.Converter.L1Til.IsRemaster(tile.TilData))
                            {
                                tile.TilData = L1MapViewer.Converter.L1Til.DownscaleTil(tile.TilData);
                                tile.Md5Hash = TileHashManager.CalculateMd5(tile.TilData);
                            }
                        }
                    }
                }
            }

            // 2. 處理 Layer8 SPR 打包（使用預先選擇的 list.spr）
            if (!string.IsNullOrEmpty(sprListPath) && sprIds != null && sprIds.Count > 0)
            {
                CollectLayer8Sprs(fs32, sprIds, sprListPath);
            }
        }

        /// <summary>
        /// 收集 Layer8 使用的 SPR 檔案
        /// </summary>
        /// <param name="sprListPath">list.spr 檔案路徑</param>
        private void CollectLayer8Sprs(Fs32Data fs32, HashSet<int> sprIds, string sprListPath)
        {
            try
            {
                // 解析 list.spr
                var sprList = SprListParser.LoadFromFile(sprListPath);
                if (sprList == null || sprList.Entries == null)
                {
                    WinFormsMessageBox.Show("無法解析 list.spr 檔案", "錯誤", MessageBoxButtons.OK, MessageBoxIcon.Error);
                    return;
                }

                // 使用 Share.LineagePath（地圖資料夾）作為 sprite idx 資料夾
                string spriteFolder = Share.LineagePath;
                if (string.IsNullOrEmpty(spriteFolder) || !Directory.Exists(spriteFolder))
                {
                    WinFormsMessageBox.Show("無法取得地圖資料夾路徑", "錯誤", MessageBoxButtons.OK, MessageBoxIcon.Error);
                    return;
                }

                // 找到所有 sprite idx 檔案
                var spriteIdxFiles = FindSpriteIdxFiles(spriteFolder);
                if (spriteIdxFiles.Count == 0)
                {
                    WinFormsMessageBox.Show($"在 {spriteFolder} 找不到 sprite.idx 檔案", "錯誤", MessageBoxButtons.OK, MessageBoxIcon.Error);
                    return;
                }

                int successCount = 0;
                int failCount = 0;
                var failedIds = new List<int>();

                // 預先開啟所有 sprite idx 檔案
                var pakFiles = new List<PakFile>();
                try
                {
                    foreach (string idxPath in spriteIdxFiles)
                    {
                        try
                        {
                            pakFiles.Add(new PakFile(idxPath));
                        }
                        catch
                        {
                            // 忽略無法開啟的 idx 檔案
                        }
                    }

                    if (pakFiles.Count == 0)
                    {
                        WinFormsMessageBox.Show("無法開啟任何 sprite.idx 檔案", "錯誤", MessageBoxButtons.OK, MessageBoxIcon.Error);
                        return;
                    }

                    // 收集 SPR 檔案
                    foreach (int sprId in sprIds)
                    {
                        // 嘗試從各個 sprite idx 讀取所有符合的 SPR 檔案 (如 2197.spr, 2197-0.spr, 2197-1.spr 等)
                        var sprFiles = FindAllSprFromPakFiles(pakFiles, sprId);
                        if (sprFiles.Count == 0)
                        {
                            failCount++;
                            failedIds.Add(sprId);
                            continue;
                        }

                        // 取得對應的 CodeText
                        string codeText = "";
                        try
                        {
                            var entry = sprList.Entries.FirstOrDefault(e => e.Id == sprId);
                            // 檢查是否找到 entry (Id > 0 表示有效，因為 SprListEntry 是 struct)
                            if (entry.Id > 0)
                            {
                                // 使用暫存檔取得 sprtxt 格式
                                string tempFile = Path.GetTempFileName();
                                try
                                {
                                    Lin.Helper.Core.Sprite.SprListWriter.SaveEntry(entry, tempFile);
                                    codeText = File.ReadAllText(tempFile);
                                }
                                finally
                                {
                                    if (File.Exists(tempFile))
                                        File.Delete(tempFile);
                                }
                            }
                        }
                        catch
                        {
                            // 無法取得 CodeText，繼續但不含 code
                        }

                        fs32.Sprs[sprId] = new SprPackageData
                        {
                            SprId = sprId,
                            Files = sprFiles,
                            CodeText = codeText
                        };
                        successCount++;
                    }
                }
                finally
                {
                    // 確保釋放所有 PakFile
                    foreach (var pak in pakFiles)
                    {
                        pak.Dispose();
                    }
                }

                // 顯示結果
                string resultMsg = $"SPR 收集完成\n\n成功: {successCount}\n失敗: {failCount}";
                if (failCount > 0)
                {
                    string failedList = failedIds.Count <= 10
                        ? string.Join(", ", failedIds)
                        : string.Join(", ", failedIds.Take(10)) + $" ... 等 {failedIds.Count} 個";
                    resultMsg += $"\n\n找不到的 SPR: {failedList}";
                    WinFormsMessageBox.Show(resultMsg, "SPR 打包結果", MessageBoxButtons.OK, MessageBoxIcon.Warning);
                }
                else
                {
                    WinFormsMessageBox.Show(resultMsg, "SPR 打包結果", MessageBoxButtons.OK, MessageBoxIcon.Information);
                }
            }
            catch (Exception ex)
            {
                WinFormsMessageBox.Show($"處理 SPR 失敗: {ex.Message}\n\n{ex.StackTrace}", "錯誤", MessageBoxButtons.OK, MessageBoxIcon.Error);
            }
        }

        /// <summary>
        /// 找到資料夾內所有的 sprite idx 檔案
        /// </summary>
        private List<string> FindSpriteIdxFiles(string folder)
        {
            var result = new List<string>();

            if (!Directory.Exists(folder))
                return result;

            // 取得資料夾內所有檔案，用 case-insensitive 比對
            var allFiles = Directory.GetFiles(folder, "*.idx");

            // 建立要找的檔名集合 (小寫)
            var targetNames = new HashSet<string>(StringComparer.OrdinalIgnoreCase)
            {
                "sprite.idx"
            };
            for (int i = 0; i <= 15; i++)
            {
                targetNames.Add($"sprite{i:D2}.idx");
            }

            // 比對檔案
            foreach (var file in allFiles)
            {
                string fileName = Path.GetFileName(file);
                if (targetNames.Contains(fileName))
                {
                    result.Add(file);
                }
            }

            return result;
        }

        /// <summary>
        /// 從已開啟的 PakFile 列表中尋找 SPR
        /// </summary>
        /// <returns>Tuple of (sprData, originalFileName), or (null, null) if not found</returns>
        private (byte[] data, string fileName) FindSprFromPakFiles(List<PakFile> pakFiles, int sprId)
        {
            // 嘗試的檔名格式（按優先順序）
            string[] fileNameFormats = {
                $"{sprId}.spr",      // 標準格式
                $"{sprId}-0.spr",    // 帶動作索引格式
            };

            foreach (var pak in pakFiles)
            {
                foreach (string fileName in fileNameFormats)
                {
                    // 在 pak 中尋找檔案（不區分大小寫）
                    var entry = pak.Files.FirstOrDefault(f =>
                        f.FileName.Equals(fileName, StringComparison.OrdinalIgnoreCase));

                    if (!string.IsNullOrEmpty(entry.FileName))
                    {
                        return (pak.Extract(entry.FileName), entry.FileName);
                    }
                }
            }

            return (null, null);
        }

        /// <summary>
        /// 從已開啟的 PakFile 列表中尋找所有符合的 SPR 檔案
        /// 例如 sprId=2197 會找 2197.spr, 2197-0.spr, 2197-1.spr 等
        /// </summary>
        private Dictionary<string, byte[]> FindAllSprFromPakFiles(List<PakFile> pakFiles, int sprId)
        {
            var result = new Dictionary<string, byte[]>(StringComparer.OrdinalIgnoreCase);
            string exactName = $"{sprId}.spr";
            string prefix = $"{sprId}-";

            foreach (var pak in pakFiles)
            {
                foreach (var file in pak.Files)
                {
                    string fileName = file.FileName;
                    if (string.IsNullOrEmpty(fileName))
                        continue;

                    // 符合 {sprId}.spr 或 {sprId}-*.spr 格式
                    bool match = fileName.Equals(exactName, StringComparison.OrdinalIgnoreCase) ||
                                 (fileName.StartsWith(prefix, StringComparison.OrdinalIgnoreCase) &&
                                  fileName.EndsWith(".spr", StringComparison.OrdinalIgnoreCase));

                    if (match && !result.ContainsKey(fileName))
                    {
                        try
                        {
                            result[fileName] = pak.Extract(fileName);
                        }
                        catch { }
                    }
                }
            }

            return result;
        }

        // 儲存選取區域為素材 (fs3p)
        private void SaveSelectionAsMaterial()
        {
            if (_editState.SelectedCells.Count == 0)
            {
                WinFormsMessageBox.Show("請先選取區域", "提示", MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            using (var dialog = new L1MapViewer.Forms.ExportOptionsDialog(isFs3p: true, hasSelection: true))
            {
                if (dialog.ShowDialog(this) != DialogResult.Ok)
                    return;

                try
                {
                    // 產生縮圖
                    Bitmap thumbnail = GenerateSelectionThumbnail(_editState.SelectedCells, 128);

                    // 建立 fs3p
                    var fs3p = Fs3pWriter.CreateFromSelection(
                        _editState.SelectedCells,
                        _document.S32Files,
                        dialog.MaterialName,
                        dialog.LayerFlags,
                        dialog.IncludeTiles,
                        dialog.IncludeLayer5,
                        thumbnail);

                    if (fs3p == null)
                    {
                        WinFormsMessageBox.Show("建立素材失敗", "錯誤", MessageBoxButtons.OK, MessageBoxIcon.Error);
                        return;
                    }

                    // 檢查並處理 R版 tiles
                    if (dialog.IncludeTiles && fs3p.Tiles.Count > 0)
                    {
                        int remasterCount = fs3p.Tiles.Values.Count(t => L1MapViewer.Converter.L1Til.IsRemaster(t.TilData));
                        if (remasterCount > 0)
                        {
                            var result = WinFormsMessageBox.Show(
                                $"素材中有 {remasterCount} 個 R版 (48x48) 圖塊。\n\n" +
                                "是否要轉換為天1格式 (24x24)？\n\n" +
                                "• 是 - 轉換為天1格式 (檔案較小，相容舊版)\n" +
                                "• 否 - 保留 R版格式",
                                "R版圖塊偵測",
                                MessageBoxButtons.YesNo,
                                MessageBoxIcon.Question,
                                MessageBoxDefaultButton.Button1);  // 預設選「是」

                            if (result == DialogResult.Yes)
                            {
                                // 轉換所有 R版 tiles 為 天1 格式
                                foreach (var tileId in fs3p.Tiles.Keys.ToList())
                                {
                                    var tile = fs3p.Tiles[tileId];
                                    if (L1MapViewer.Converter.L1Til.IsRemaster(tile.TilData))
                                    {
                                        tile.TilData = L1MapViewer.Converter.L1Til.DownscaleTil(tile.TilData);
                                        tile.Md5Hash = TileHashManager.CalculateMd5(tile.TilData);
                                    }
                                }
                            }
                        }
                    }

                    // 儲存到素材庫
                    var library = new MaterialLibrary();
                    string savedPath = library.SaveMaterial(fs3p);

                    thumbnail?.Dispose();

                    toolStripStatusLabel1.Text = $"已儲存素材: {dialog.MaterialName} ({fs3p.Layer1Items.Count + fs3p.Layer2Items.Count + fs3p.Layer4Items.Count} 項目, {fs3p.Tiles.Count} 圖塊)";

                    // 更新素材面板
                    RefreshMaterialsList();
                }
                catch (Exception ex)
                {
                    WinFormsMessageBox.Show($"儲存素材失敗: {ex.Message}", "錯誤", MessageBoxButtons.OK, MessageBoxIcon.Error);
                }
            }
        }

        // 顯示選取區域內群組的所有位置（用綠色高亮）
        private void ShowGroupsInSelectedArea()
        {
            if (_editState.SelectedCells.Count == 0)
            {
                WinFormsMessageBox.Show("請先選取區域", "提示", MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            // 1. 收集選取區域內的 Layer1 座標
            var selectedLayer1Cells = new HashSet<(int x, int y)>();
            foreach (var cell in _editState.SelectedCells)
            {
                int layer1GlobalX = cell.S32Data.SegInfo.nLinBeginX * 2 + cell.LocalX;
                int layer1GlobalY = cell.S32Data.SegInfo.nLinBeginY + cell.LocalY;
                selectedLayer1Cells.Add((layer1GlobalX, layer1GlobalY));
                selectedLayer1Cells.Add((layer1GlobalX + 1, layer1GlobalY));  // 同一格的右半
            }

            // 2. 找出選取區域內有哪些群組 (S32Path, GroupId)
            var groupsInSelection = new HashSet<(string s32Path, int groupId)>();
            foreach (var s32Data in _document.S32Files.Values)
            {
                int segStartX = s32Data.SegInfo.nLinBeginX * 2;
                int segStartY = s32Data.SegInfo.nLinBeginY;

                foreach (var obj in s32Data.Layer4)
                {
                    int layer1GlobalX = segStartX + obj.X;
                    int layer1GlobalY = segStartY + obj.Y;

                    if (selectedLayer1Cells.Contains((layer1GlobalX, layer1GlobalY)))
                    {
                        groupsInSelection.Add((s32Data.FilePath, obj.GroupId));
                    }
                }
            }

            if (groupsInSelection.Count == 0)
            {
                WinFormsMessageBox.Show("選取區域內沒有群組", "提示", MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            // 3. 收集這些群組的所有格子位置
            var highlightCells = new List<(int globalX, int globalY)>();
            (int firstX, int firstY)? firstCell = null;

            foreach (var s32Data in _document.S32Files.Values)
            {
                int segStartX = s32Data.SegInfo.nLinBeginX * 2;
                int segStartY = s32Data.SegInfo.nLinBeginY;

                foreach (var obj in s32Data.Layer4)
                {
                    if (groupsInSelection.Contains((s32Data.FilePath, obj.GroupId)))
                    {
                        int layer1GlobalX = segStartX + obj.X;
                        int layer1GlobalY = segStartY + obj.Y;

                        // 正規化為偶數 X（同一格只加一次）
                        int normalizedX = (layer1GlobalX / 2) * 2;
                        var cellCoord = (normalizedX, layer1GlobalY);

                        if (!highlightCells.Contains(cellCoord))
                        {
                            highlightCells.Add(cellCoord);
                            if (firstCell == null)
                            {
                                firstCell = cellCoord;
                            }
                        }
                    }
                }
            }

            // 4. 設定高亮狀態
            _editState.GroupHighlightCells = highlightCells;

            // 5. 移動 viewport 到第一個位置
            if (firstCell.HasValue)
            {
                JumpToLayer1Coordinate(firstCell.Value.firstX, firstCell.Value.firstY);
            }

            // 6. 重新渲染
            RenderS32Map();

            this.toolStripStatusLabel1.Text = $"顯示 {groupsInSelection.Count} 個群組的 {highlightCells.Count} 個位置（點擊其他地方清除）";
        }

        // [JumpToLayer1Coordinate 已移至 MapForm.Coordinates.cs]

        // 產生選取區域縮圖 - 直接渲染 tiles，不依賴 viewport
        private Bitmap GenerateSelectionThumbnail(List<SelectedCell> cells, int maxSize)
        {
            if (cells == null || cells.Count == 0)
                return null;

            try
            {
                // 收集所有要繪製的 tiles (Layer1 + Layer4)
                var tilesToDraw = new List<(int px, int py, int tileId, int indexId, int layer)>();

                // 計算像素邊界
                int pixelMinX = int.MaxValue, pixelMaxX = int.MinValue;
                int pixelMinY = int.MaxValue, pixelMaxY = int.MinValue;

                foreach (var cell in cells)
                {
                    var s32Data = cell.S32Data;
                    int segStartX = s32Data.SegInfo.nLinBeginX * 2;
                    int segStartY = s32Data.SegInfo.nLinBeginY;

                    // 處理 Layer1 (偶數和奇數 X)
                    for (int dx = 0; dx <= 1; dx++)
                    {
                        int l1x = cell.LocalX + dx;
                        if (l1x < 128 && cell.LocalY < 64)
                        {
                            var tileCell = s32Data.Layer1[cell.LocalY, l1x];
                            if (tileCell != null && tileCell.TileId > 0)
                            {
                                // 計算像素座標（與渲染器相同的公式）
                                int halfX = l1x / 2;
                                int baseX = -24 * halfX;
                                int baseY = 63 * 12 - 12 * halfX;
                                int px = baseX + l1x * 24 + cell.LocalY * 24;
                                int py = baseY + cell.LocalY * 12;

                                tilesToDraw.Add((px, py, tileCell.TileId, tileCell.IndexId, 0));

                                pixelMinX = Math.Min(pixelMinX, px);
                                pixelMaxX = Math.Max(pixelMaxX, px + 48);
                                pixelMinY = Math.Min(pixelMinY, py);
                                pixelMaxY = Math.Max(pixelMaxY, py + 48);
                            }
                        }
                    }

                    // 處理 Layer4 (obj.X 是 Layer1 座標 0-127，需要 /2 得到遊戲座標)
                    int localGameX = cell.LocalX / 2;
                    foreach (var obj in s32Data.Layer4.Where(o => (o.X / 2) == localGameX && o.Y == cell.LocalY))
                    {
                        int halfX = obj.X / 2;
                        int baseX = -24 * halfX;
                        int baseY = 63 * 12 - 12 * halfX;
                        int px = baseX + obj.X * 24 + obj.Y * 24;
                        int py = baseY + obj.Y * 12;

                        tilesToDraw.Add((px, py, obj.TileId, obj.IndexId, obj.Layer));

                        pixelMinX = Math.Min(pixelMinX, px);
                        pixelMaxX = Math.Max(pixelMaxX, px + 48);
                        pixelMinY = Math.Min(pixelMinY, py);
                        pixelMaxY = Math.Max(pixelMaxY, py + 48);
                    }
                }

                if (tilesToDraw.Count == 0)
                    return null;

                // 計算實際大小
                int margin = 4;
                int actualWidth = pixelMaxX - pixelMinX + margin * 2;
                int actualHeight = pixelMaxY - pixelMinY + margin * 2;

                if (actualWidth <= 0 || actualHeight <= 0)
                    return null;

                // 限制暫存圖大小
                int maxTempSize = 512;
                float preScale = 1.0f;
                if (actualWidth > maxTempSize || actualHeight > maxTempSize)
                {
                    preScale = Math.Min((float)maxTempSize / actualWidth, (float)maxTempSize / actualHeight);
                }

                int tempWidth = Math.Max((int)(actualWidth * preScale), 1);
                int tempHeight = Math.Max((int)(actualHeight * preScale), 1);

                // 建立暫存圖並渲染
                Bitmap tempBitmap = new Bitmap(tempWidth, tempHeight, PixelFormat.Format16bppRgb555);
                Rectangle rect = new Rectangle(0, 0, tempBitmap.Width, tempBitmap.Height);
                BitmapData bmpData = tempBitmap.LockBits(rect, ImageLockMode.ReadWrite, tempBitmap.PixelFormat);
                int rowpix = bmpData.Stride;

                unsafe
                {
                    byte* ptr = (byte*)bmpData.Scan0;

                    // 填充白色背景
                    byte[] whiteLine = new byte[rowpix];
                    for (int x = 0; x < tempWidth; x++)
                    {
                        whiteLine[x * 2] = 0xFF;
                        whiteLine[x * 2 + 1] = 0x7F;
                    }
                    for (int y = 0; y < tempHeight; y++)
                    {
                        System.Runtime.InteropServices.Marshal.Copy(whiteLine, 0, (IntPtr)(ptr + y * rowpix), rowpix);
                    }

                    // 按 layer 排序後繪製
                    var sortedTiles = tilesToDraw.OrderBy(t => t.layer).ToArray();
                    foreach (var tile in sortedTiles)
                    {
                        int pixelX = (int)((tile.px - pixelMinX + margin) * preScale);
                        int pixelY = (int)((tile.py - pixelMinY + margin) * preScale);
                        DrawTilToBufferDirect555(pixelX, pixelY, tile.tileId, tile.indexId, rowpix, ptr, tempWidth, tempHeight);
                    }
                }

                tempBitmap.UnlockBits(bmpData);

                // 縮放到目標大小
                float finalScale = Math.Min((float)maxSize / tempWidth, (float)maxSize / tempHeight);
                finalScale = Math.Min(finalScale, 1.0f);
                int thumbWidth = Math.Max((int)(tempWidth * finalScale), 1);
                int thumbHeight = Math.Max((int)(tempHeight * finalScale), 1);

                Bitmap result = new Bitmap(thumbWidth, thumbHeight, PixelFormat.Format32bppArgb);
                using (Graphics g = GraphicsHelper.FromImage(result))
                {
                    g.Clear(Colors.White);
                    g.SetInterpolationMode(InterpolationMode.HighQualityBilinear);
                    g.DrawImage(tempBitmap, 0, 0, thumbWidth, thumbHeight);
                }

                tempBitmap.Dispose();
                return result;
            }
            catch
            {
                return null;
            }
        }

        // 素材列表的 ImageList
        private ImageList _materialsImageList;

        // 刷新素材列表
        private void RefreshMaterialsList()
        {
            try
            {
                var library = new MaterialLibrary();
                var recentMaterials = library.GetRecentMaterials();

                lvMaterials.Items.Clear();

                // 初始化或清空 ImageList
                if (_materialsImageList == null)
                {
                    _materialsImageList = new ImageList
                    {
                        ImageSize = new Size(48, 48),
                        ColorDepth = ColorDepth.Depth32Bit
                    };
                    lvMaterials.LargeImageList = _materialsImageList;
                }
                else
                {
                    _materialsImageList.Images.Clear();
                }

                int imageIndex = 0;
                foreach (var info in recentMaterials.Take(5))
                {
                    var item = new IconTextListItem
                    {
                        Text = info.Name ?? "未命名",
                        Tag = info.FilePath
                    };

                    // 加入縮圖
                    if (info.ThumbnailPng != null && info.ThumbnailPng.Length > 0)
                    {
                        try
                        {
                            using (var ms = new MemoryStream(info.ThumbnailPng))
                            {
                                var thumb = new Bitmap(ms);
                                _materialsImageList.Images.Add(thumb);
                                item.ImageIndex = imageIndex++;
                            }
                        }
                        catch (Exception ex)
                        {
                            _logger.Error(ex, $"RefreshMaterialsList: Failed to load thumbnail for {info.Name}");
                            item.ImageIndex = -1;
                        }
                    }
                    else
                    {
                        item.ImageIndex = -1;
                    }

                    lvMaterials.Items.Add(item);
                }
            }
            catch (Exception ex)
            {
                _logger.Error(ex, "RefreshMaterialsList failed");
            }
        }

        // S32 PictureBox 繪製事件 - 繪製 Viewport 和選擇框或多邊形
        private void s32PictureBox_Paint(object sender, PaintEventArgs e)
        {
            // 繪製 Viewport Bitmap（加鎖保護避免多執行緒衝突）
            lock (_renderCache.ViewportBitmapLock)
            {
                if (_renderCache.ViewportBitmap != null && _viewState.RenderWidth > 0)
                {
                    // 計算 Viewport Bitmap 在 PictureBox 上的繪製位置
                    int drawX = (int)((_viewState.RenderOriginX - _viewState.ScrollX) * _viewState.ZoomLevel);
                    int drawY = (int)((_viewState.RenderOriginY - _viewState.ScrollY) * _viewState.ZoomLevel);

                    // Viewport Bitmap 是未縮放的，需要縮放繪製
                    int drawW = (int)(_viewState.RenderWidth * _viewState.ZoomLevel);
                    int drawH = (int)(_viewState.RenderHeight * _viewState.ZoomLevel);

                    e.Graphics.DrawImage(_renderCache.ViewportBitmap, drawX, drawY, drawW, drawH);

                    // 拖曳時計數 Paint 次數
                    if (_interaction.IsMainMapDragging)
                    {
                        _dragPaintCount++;
                    }
                }
            }

            // 通行性編輯模式：繪製多邊形（舊功能，保留但使用固定顏色）
            if (_editState.IsDrawingPassabilityPolygon && _editState.PassabilityPolygonPoints.Count > 0)
            {
                Color polygonColor = Colors.LightBlue;

                // 繪製已有的多邊形邊
                using (Pen pen = new Pen(polygonColor, 3))
                {
                    for (int i = 0; i < _editState.PassabilityPolygonPoints.Count - 1; i++)
                    {
                        e.Graphics.DrawLine(pen, _editState.PassabilityPolygonPoints[i], _editState.PassabilityPolygonPoints[i + 1]);
                    }
                    // 如果有3個以上頂點，繪製封閉線（虛線預覽）
                    if (_editState.PassabilityPolygonPoints.Count >= 3)
                    {
                        using (Pen dashPen = new Pen(polygonColor, 2) { DashStyle = DashStyle.Dash })
                        {
                            e.Graphics.DrawLine(dashPen, _editState.PassabilityPolygonPoints[_editState.PassabilityPolygonPoints.Count - 1], _editState.PassabilityPolygonPoints[0]);
                        }
                    }
                }

                // 繪製頂點標記
                using (SolidBrush brush = new SolidBrush(polygonColor))
                {
                    foreach (var pt in _editState.PassabilityPolygonPoints)
                    {
                        e.Graphics.FillEllipse(brush, pt.X - 5, pt.Y - 5, 10, 10);
                    }
                }

                // 繪製半透明填充預覽（如果有3個以上頂點）
                if (_editState.PassabilityPolygonPoints.Count >= 3)
                {
                    using (SolidBrush fillBrush = new SolidBrush(ColorExtensions.FromArgb(50, polygonColor)))
                    {
                        e.Graphics.FillPolygon(fillBrush, _editState.PassabilityPolygonPoints.ToArray());
                    }
                }
                return;
            }

            // 有選中的格子時，繪製對齊格線的菱形選取框
            if (_editState.SelectedCells.Count > 0)
            {
                Color color = isSelectingRegion ? Colors.Green : Colors.Orange;
                DrawSelectedCells(e.Graphics, _editState.SelectedCells, color);

                // 顯示選取的格子數量
                if (isSelectingRegion)
                {
                    string info = $"選取 {_editState.SelectedCells.Count} 格";
                    using (Font font = new Font("Arial", 10, FontStyle.Bold))
                    using (SolidBrush bgBrush = new SolidBrush(ColorExtensions.FromArgb(180, Colors.Black)))
                    using (SolidBrush textBrush = new SolidBrush(Colors.White))
                    {
                        SizeF textSize = e.Graphics.MeasureString(info, font);
                        // 在滑鼠位置附近顯示
                        float textX = regionEndPoint.X + 15;
                        float textY = regionEndPoint.Y - 20;
                        e.Graphics.FillRectangle(bgBrush, textX - 2, textY - 2, textSize.Width + 4, textSize.Height + 4);
                        e.Graphics.DrawString(info, font, textBrush, textX, textY);
                    }
                }
            }
        }

        // 繪製選中的格子（每個格子繪製獨立的菱形）
        private void DrawSelectedCells(Graphics g, List<SelectedCell> cells, Color color)
        {
            if (cells.Count == 0 || string.IsNullOrEmpty(_document.MapId) || !Share.MapDataList.ContainsKey(_document.MapId))
                return;

            // 使用 ViewState 的捲動位置（世界座標）
            int scrollX = _viewState.ScrollX;
            int scrollY = _viewState.ScrollY;

            using (SolidBrush brush = new SolidBrush(ColorHelper.FromArgb(50, color)))
            using (Pen pen = new Pen(color, 2))
            {
                foreach (var cell in cells)
                {
                    // 與 DrawS32Grid 完全相同的座標計算（Layer3 格子，48x24）
                    int[] loc = cell.S32Data.SegInfo.GetLoc(1.0);
                    int mx = loc[0];
                    int my = loc[1];

                    int x = cell.LocalX;  // 已經是 Layer1 座標 (x3 * 2)
                    int y = cell.LocalY;

                    int localBaseX = 0;
                    int localBaseY = 63 * 12;
                    localBaseX -= 24 * (x / 2);
                    localBaseY -= 12 * (x / 2);

                    // 計算世界座標
                    int worldX = mx + localBaseX + x * 24 + y * 24;
                    int worldY = my + localBaseY + y * 12;

                    // 轉換為螢幕座標（考慮捲動位置和縮放）
                    // 螢幕座標 = (世界座標 - 捲動位置) * 縮放
                    int screenX = (int)((worldX - scrollX) * _viewState.ZoomLevel);
                    int screenY = (int)((worldY - scrollY) * _viewState.ZoomLevel);
                    int scaledWidth = (int)(48 * _viewState.ZoomLevel);
                    int scaledHeight = (int)(24 * _viewState.ZoomLevel);

                    // Layer3 菱形四個頂點（48x24，與 DrawS32Grid 一致）
                    Point[] diamondPoints = new Point[]
                    {
                        new Point(screenX, screenY + scaledHeight / 2),       // 左
                        new Point(screenX + scaledWidth / 2, screenY),        // 上
                        new Point(screenX + scaledWidth, screenY + scaledHeight / 2),  // 右
                        new Point(screenX + scaledWidth / 2, screenY + scaledHeight)   // 下
                    };

                    g.FillPolygon(brush, diamondPoints);
                    g.DrawPolygon(pen, diamondPoints);
                }
            }
        }

        // 繪製等距菱形選取框（支援長方形）
        private void DrawIsometricSelectionBox(Graphics g, Rectangle region, Color color)
        {
            // 計算等距投影菱形的四個頂點
            float centerX = region.Left + region.Width / 2f;
            float centerY = region.Top + region.Height / 2f;

            // 使用實際的寬高，保持 2:1 的等距比例
            float halfWidth = region.Width / 2f;       // 水平方向半寬
            float halfHeight = region.Height / 2f;     // 垂直方向半高

            PointF[] diamondPoints = new PointF[]
            {
                new PointF(centerX, centerY - halfHeight),  // 上
                new PointF(centerX + halfWidth, centerY),   // 右
                new PointF(centerX, centerY + halfHeight),  // 下
                new PointF(centerX - halfWidth, centerY)    // 左
            };

            // 繪製半透明選擇框（菱形）
            using (SolidBrush brush = new SolidBrush(ColorHelper.FromArgb(80, color)))
            {
                g.FillPolygon(brush, diamondPoints);
            }

            // 繪製邊框（菱形）
            using (Pen pen = new Pen(color, 3))
            {
                pen.DashStyle = DashStyle.Dash;
                g.DrawPolygon(pen, diamondPoints);
            }
        }

        // 獲取矩形區域內的所有格子座標（返回格子所屬的 S32Data 和局部座標）
        // SelectedCell 已移至 Models/S32DataModels.cs

        private List<SelectedCell> GetCellsInRegion(Rectangle region)
        {
            List<SelectedCell> cells = new List<SelectedCell>();

            // 獲取當前地圖資訊以計算正確的 baseY
            if (string.IsNullOrEmpty(_document.MapId) || !Share.MapDataList.ContainsKey(_document.MapId))
                return cells;

            Struct.L1Map currentMap = Share.MapDataList[_document.MapId];

            // 將螢幕矩形的四個角轉換為遊戲座標，找出遊戲座標的範圍
            // 螢幕座標 -> 遊戲座標的反向轉換
            int baseYOffset = (currentMap.nLinLengthY - 1) * 12;

            // 矩形的四個角點
            Point[] corners = new Point[]
            {
                new Point(region.Left, region.Top),
                new Point(region.Right, region.Top),
                new Point(region.Left, region.Bottom),
                new Point(region.Right, region.Bottom)
            };

            // 計算每個角點對應的遊戲座標範圍
            int minGameX = int.MaxValue, maxGameX = int.MinValue;
            int minGameY = int.MaxValue, maxGameY = int.MinValue;

            foreach (var corner in corners)
            {
                // 反向計算遊戲座標 (近似值，用於確定搜索範圍)
                // X = baseX + globalX * 24 + globalY * 24
                // Y = baseY + globalY * 12
                // 其中 baseX = -24 * (globalX / 2), baseY = baseYOffset - 12 * (globalX / 2)

                // 簡化：假設 globalX 為偶數時
                // X ≈ globalX * 12 + globalY * 24
                // Y ≈ baseYOffset + globalY * 12 - globalX * 6

                // 從 Y 得：globalY ≈ (Y - baseYOffset + globalX * 6) / 12
                // 從 X 得：globalX ≈ (X - globalY * 24) / 12

                // 用迭代方式估算
                for (int gx = -50; gx < currentMap.nLinLengthX + 50; gx += 10)
                {
                    for (int gy = -50; gy < currentMap.nLinLengthY + 50; gy += 10)
                    {
                        int bx = -24 * (gx / 2);
                        int by = baseYOffset - 12 * (gx / 2);
                        int sx = bx + gx * 24 + gy * 24;
                        int sy = by + gy * 12;

                        if (Math.Abs(sx - corner.X) < 200 && Math.Abs(sy - corner.Y) < 100)
                        {
                            minGameX = Math.Min(minGameX, gx - 20);
                            maxGameX = Math.Max(maxGameX, gx + 20);
                            minGameY = Math.Min(minGameY, gy - 20);
                            maxGameY = Math.Max(maxGameY, gy + 20);
                        }
                    }
                }
            }

            // 遍歷所有 S32 檔案
            foreach (var s32Data in _document.S32Files.Values)
            {
                // 使用 GetLoc 計算區塊位置
                int[] loc = s32Data.SegInfo.GetLoc(1.0);
                int mx = loc[0];
                int my = loc[1];

                for (int y = 0; y < 64; y++)
                {
                    for (int x = 0; x < 128; x++)
                    {
                        // 使用 GetLoc + drawTilBlock 公式計算像素位置
                        int localBaseX = 0;
                        int localBaseY = 63 * 12;
                        localBaseX -= 24 * (x / 2);
                        localBaseY -= 12 * (x / 2);

                        int X = mx + localBaseX + x * 24 + y * 24;
                        int Y = my + localBaseY + y * 12;

                        // 菱形的中心點
                        Point centerPoint = new Point(X + 12, Y + 12);

                        // 檢查中心點是否在選擇區域內（使用45度菱形判斷）
                        // 將選擇矩形視為螢幕上的菱形區域
                        if (IsPointInIsometricRegion(centerPoint, region))
                        {
                            cells.Add(new SelectedCell
                            {
                                S32Data = s32Data,
                                LocalX = x,
                                LocalY = y
                            });
                        }
                    }
                }
            }

            return cells;
        }

        // 檢查點是否在等距投影的菱形區域內（2:1 比例）
        private bool IsPointInIsometricRegion(Point point, Rectangle screenRect)
        {
            // 螢幕矩形的中心點
            float centerX = screenRect.Left + screenRect.Width / 2f;
            float centerY = screenRect.Top + screenRect.Height / 2f;

            // 將點相對於中心的偏移
            float dx = point.X - centerX;
            float dy = point.Y - centerY;

            // 等距投影菱形（2:1 比例）
            // 取寬和高的較大值來決定菱形大小，保持 2:1 比例
            float size = Math.Max(screenRect.Width, screenRect.Height * 2);
            float halfWidth = size / 2f;      // 水平方向半寬
            float halfHeight = size / 4f;     // 垂直方向半高（2:1 比例）

            // 使用菱形的標準判斷公式: |x/a| + |y/b| <= 1
            float normalizedX = Math.Abs(dx) / halfWidth;
            float normalizedY = Math.Abs(dy) / halfHeight;

            return (normalizedX + normalizedY) <= 1.0f;
        }

        // 用剪貼簿的地板填滿選取區（平鋪重複）
        private void FillSelectionWithClipboardFloor()
        {
            // 取得有 Layer1 資料的剪貼簿項目
            var clipboardL1Cells = _editState.CellClipboard
                .Where(c => c.Layer1Cell1 != null || c.Layer1Cell2 != null)
                .ToList();

            if (clipboardL1Cells.Count == 0)
            {
                WinFormsMessageBox.Show("剪貼簿中沒有地板資料。", "提示", MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            if (_editState.SelectedCells.Count == 0)
            {
                this.toolStripStatusLabel1.Text = "請先選取要填滿的區域";
                return;
            }

            // 計算剪貼簿圖案的範圍
            int clipMinX = clipboardL1Cells.Min(c => c.RelativeX);
            int clipMinY = clipboardL1Cells.Min(c => c.RelativeY);
            int clipMaxX = clipboardL1Cells.Max(c => c.RelativeX);
            int clipMaxY = clipboardL1Cells.Max(c => c.RelativeY);
            int clipWidth = clipMaxX - clipMinX + 2;  // +2 因為一個格子有兩個 Layer1 格
            int clipHeight = clipMaxY - clipMinY + 1;

            if (clipWidth <= 0 || clipHeight <= 0)
            {
                WinFormsMessageBox.Show("剪貼簿圖案無效。", "錯誤", MessageBoxButtons.OK, MessageBoxIcon.Error);
                return;
            }

            // 建立快速查找字典 (相對座標 -> Layer1Cell)
            var clipboardDict = new Dictionary<(int x, int y), (TileCell cell1, TileCell cell2)>();
            foreach (var cell in clipboardL1Cells)
            {
                clipboardDict[(cell.RelativeX, cell.RelativeY)] = (cell.Layer1Cell1, cell.Layer1Cell2);
            }

            // 計算選取區域的全域座標範圍
            int selMinGlobalX = int.MaxValue, selMinGlobalY = int.MaxValue;
            foreach (var cell in _editState.SelectedCells)
            {
                int globalX = cell.S32Data.SegInfo.nLinBeginX * 2 + cell.LocalX;
                int globalY = cell.S32Data.SegInfo.nLinBeginY + cell.LocalY;
                if (globalX < selMinGlobalX) selMinGlobalX = globalX;
                if (globalY < selMinGlobalY) selMinGlobalY = globalY;
            }

            // 確保起點是偶數以保持奇偶性
            if (selMinGlobalX % 2 != 0) selMinGlobalX -= 1;

            // 建立 Undo 記錄
            var undoAction = new UndoAction
            {
                Description = $"填滿地板 {_editState.SelectedCells.Count} 格"
            };

            int filledCount = 0;

            // 填滿每個選取的格子
            foreach (var cell in _editState.SelectedCells)
            {
                int globalX = cell.S32Data.SegInfo.nLinBeginX * 2 + cell.LocalX;
                int globalY = cell.S32Data.SegInfo.nLinBeginY + cell.LocalY;

                // 計算相對於選取區域起點的位置
                int relX = globalX - selMinGlobalX;
                int relY = globalY - selMinGlobalY;

                // 計算對應的剪貼簿位置（平鋪取餘數）
                int clipRelX = clipMinX + ((relX - clipMinX) % clipWidth + clipWidth) % clipWidth;
                int clipRelY = clipMinY + ((relY - clipMinY) % clipHeight + clipHeight) % clipHeight;

                // 查找對應的剪貼簿資料
                if (clipboardDict.TryGetValue((clipRelX, clipRelY), out var clipCell))
                {
                    S32Data targetS32 = cell.S32Data;
                    int localX = cell.LocalX;
                    int localY = cell.LocalY;

                    // 填入 Layer1Cell1
                    if (clipCell.cell1 != null && localX >= 0 && localX < 128)
                    {
                        var oldCell = targetS32.Layer1[localY, localX];
                        undoAction.ModifiedLayer1.Add(new UndoLayer1Info
                        {
                            S32FilePath = targetS32.FilePath,
                            LocalX = localX,
                            LocalY = localY,
                            OldTileId = oldCell?.TileId ?? 0,
                            OldIndexId = oldCell?.IndexId ?? 0,
                            NewTileId = clipCell.cell1.TileId,
                            NewIndexId = clipCell.cell1.IndexId
                        });

                        targetS32.Layer1[localY, localX] = new TileCell
                        {
                            X = localX,
                            Y = localY,
                            TileId = clipCell.cell1.TileId,
                            IndexId = clipCell.cell1.IndexId
                        };
                        targetS32.IsModified = true;
                        filledCount++;
                    }

                    // 填入 Layer1Cell2
                    if (clipCell.cell2 != null && localX + 1 >= 0 && localX + 1 < 128)
                    {
                        var oldCell = targetS32.Layer1[localY, localX + 1];
                        undoAction.ModifiedLayer1.Add(new UndoLayer1Info
                        {
                            S32FilePath = targetS32.FilePath,
                            LocalX = localX + 1,
                            LocalY = localY,
                            OldTileId = oldCell?.TileId ?? 0,
                            OldIndexId = oldCell?.IndexId ?? 0,
                            NewTileId = clipCell.cell2.TileId,
                            NewIndexId = clipCell.cell2.IndexId
                        });

                        targetS32.Layer1[localY, localX + 1] = new TileCell
                        {
                            X = localX + 1,
                            Y = localY,
                            TileId = clipCell.cell2.TileId,
                            IndexId = clipCell.cell2.IndexId
                        };
                        targetS32.IsModified = true;
                    }
                }
            }

            // 推入 Undo 堆疊
            if (undoAction.ModifiedLayer1.Count > 0)
            {
                PushUndoAction(undoAction);
            }

            // 重新渲染
            ClearS32BlockCache();
            RenderS32Map();

            this.toolStripStatusLabel1.Text = $"已填滿 {filledCount} 個地板格子";
        }

        // 批量刪除區域內選中層的資料（根據複製設定 checkbox）
        private void DeleteAllLayer4ObjectsInRegion(List<SelectedCell> cells)
        {
            bool deleteLayer1 = copySettingLayer1;
            bool deleteLayer2 = copySettingLayer2;
            bool deleteLayer3 = copySettingLayer3;
            bool deleteLayer4 = copySettingLayer4;
            bool deleteLayer5to8 = copySettingLayer5to8;

            if (!deleteLayer1 && !deleteLayer2 && !deleteLayer3 && !deleteLayer4 && !deleteLayer5to8)
            {
                this.toolStripStatusLabel1.Text = "請點擊「複製設定...」按鈕選擇要刪除的圖層";
                return;
            }

            // 統計要刪除的資料
            int layer1Count = 0, layer2Count = 0, layer3Count = 0, layer4Count = 0, layer5to8Count = 0;
            Dictionary<S32Data, List<ObjectTile>> objectsToDeleteByS32 = new Dictionary<S32Data, List<ObjectTile>>();
            HashSet<S32Data> affectedS32 = new HashSet<S32Data>();

            // 先統計數量
            foreach (var cell in cells)
            {
                int layer3X = cell.LocalX / 2;

                // Layer1 資料統計
                if (deleteLayer1)
                {
                    int layer1X = cell.LocalX;  // cell.LocalX 已經是 Layer3 * 2
                    if (cell.LocalY >= 0 && cell.LocalY < 64 && layer1X >= 0 && layer1X < 128)
                    {
                        var cell1 = cell.S32Data.Layer1[cell.LocalY, layer1X];
                        if (cell1 != null && cell1.TileId > 0) layer1Count++;
                    }
                    if (cell.LocalY >= 0 && cell.LocalY < 64 && layer1X + 1 >= 0 && layer1X + 1 < 128)
                    {
                        var cell2 = cell.S32Data.Layer1[cell.LocalY, layer1X + 1];
                        if (cell2 != null && cell2.TileId > 0) layer1Count++;
                    }
                }

                // Layer3 資料統計
                if (deleteLayer3)
                {
                    if (cell.LocalY >= 0 && cell.LocalY < 64 && layer3X >= 0 && layer3X < 64)
                    {
                        var attr = cell.S32Data.Layer3[cell.LocalY, layer3X];
                        if (attr != null && (attr.Attribute1 != 0 || attr.Attribute2 != 0)) layer3Count++;
                    }
                }

                // Layer4 物件統計已移至跨區塊搜索統一處理

                affectedS32.Add(cell.S32Data);
            }

            // Layer4 跨區塊物件搜索：遍歷所有 S32，找出座標精確落在選取範圍內的物件
            if (deleteLayer4 && cells.Count > 0)
            {
                // 建立選取格子的全域座標集合 (Layer3 座標系)
                var selectedGlobalCells = new HashSet<(int x, int y)>();
                foreach (var cell in cells)
                {
                    int globalX = cell.S32Data.SegInfo.nLinBeginX + cell.LocalX / 2;
                    int globalY = cell.S32Data.SegInfo.nLinBeginY + cell.LocalY;
                    selectedGlobalCells.Add((globalX, globalY));
                }

                // 遍歷所有 S32 檔案搜索物件（精確匹配選取格子）
                foreach (var s32Data in _document.S32Files.Values)
                {
                    int segStartX = s32Data.SegInfo.nLinBeginX;
                    int segStartY = s32Data.SegInfo.nLinBeginY;

                    foreach (var obj in s32Data.Layer4)
                    {
                        // 計算物件的全域座標 (考慮物件 X 可能超出 0-127 範圍，即溢出到相鄰區塊)
                        // 物件的 X 範圍可達 0-255，X/2 範圍為 0-127，可能超出當前 S32 的 64 格範圍
                        int objGlobalX = segStartX + obj.X / 2;
                        int objGlobalY = segStartY + obj.Y;

                        // 精確檢查是否在選取的格子內
                        if (selectedGlobalCells.Contains((objGlobalX, objGlobalY)))
                        {
                            // 避免重複加入
                            if (!objectsToDeleteByS32.ContainsKey(s32Data))
                            {
                                objectsToDeleteByS32[s32Data] = new List<ObjectTile>();
                            }
                            if (!objectsToDeleteByS32[s32Data].Contains(obj))
                            {
                                objectsToDeleteByS32[s32Data].Add(obj);
                                layer4Count++;
                            }
                        }
                    }
                }
            }

            // Layer2 統計（跨 S32 搜索覆蓋選取格子的 Layer2 項目）
            Dictionary<S32Data, List<Layer2Item>> layer2ToDeleteByS32 = new Dictionary<S32Data, List<Layer2Item>>();
            if (deleteLayer2 && cells.Count > 0)
            {
                // 建立選取格子的全域 Layer1 座標集合
                var selectedGlobalL1Cells = new HashSet<(int x, int y)>();
                foreach (var cell in cells)
                {
                    int globalX = cell.S32Data.SegInfo.nLinBeginX * 2 + cell.LocalX;
                    int globalY = cell.S32Data.SegInfo.nLinBeginY + cell.LocalY;
                    selectedGlobalL1Cells.Add((globalX, globalY));
                    // Layer2 項目可能落在 X 或 X+1 的位置
                    selectedGlobalL1Cells.Add((globalX + 1, globalY));
                }

                // 遍歷所有 S32 檔案搜索 L2 項目（跨 S32 搜索）
                foreach (var s32Data in _document.S32Files.Values)
                {
                    int s32StartX = s32Data.SegInfo.nLinBeginX * 2;
                    int s32StartY = s32Data.SegInfo.nLinBeginY;

                    foreach (var item2 in s32Data.Layer2)
                    {
                        // 計算 L2 項目的全域 Layer1 座標
                        int itemGlobalX = s32StartX + item2.X;
                        int itemGlobalY = s32StartY + item2.Y;

                        // 檢查是否在選取的格子內（selectedGlobalL1Cells 已包含 X 和 X+1）
                        if (selectedGlobalL1Cells.Contains((itemGlobalX, itemGlobalY)))
                        {
                            if (!layer2ToDeleteByS32.ContainsKey(s32Data))
                            {
                                layer2ToDeleteByS32[s32Data] = new List<Layer2Item>();
                            }
                            if (!layer2ToDeleteByS32[s32Data].Contains(item2))
                            {
                                layer2ToDeleteByS32[s32Data].Add(item2);
                                layer2Count++;
                            }
                        }
                    }
                }
            }

            // Layer5 統計（跨 S32 搜索覆蓋選取格子的透明圖塊）
            Dictionary<S32Data, List<Layer5Item>> layer5ToDeleteByS32 = new Dictionary<S32Data, List<Layer5Item>>();
            if (deleteLayer5to8 && cells.Count > 0)
            {
                // 建立選取格子的全域遊戲座標集合
                var selectedGameCells = new HashSet<(int x, int y)>();
                foreach (var cell in cells)
                {
                    int gameX = cell.S32Data.SegInfo.nLinBeginX + cell.LocalX / 2;
                    int gameY = cell.S32Data.SegInfo.nLinBeginY + cell.LocalY;
                    selectedGameCells.Add((gameX, gameY));
                }

                // 遍歷所有 S32 檔案搜索 L5 項目（跨 S32 搜索）
                foreach (var s32Data in _document.S32Files.Values)
                {
                    int segStartX = s32Data.SegInfo.nLinBeginX;
                    int segStartY = s32Data.SegInfo.nLinBeginY;

                    foreach (var item5 in s32Data.Layer5)
                    {
                        // 計算 L5 項目的全域遊戲座標
                        // L5 的 X 是 Layer1 座標 (0-255)，除以 2 得到遊戲座標偏移
                        int itemGameX = segStartX + item5.X / 2;
                        int itemGameY = segStartY + item5.Y;

                        // 檢查是否在選取的格子內
                        if (selectedGameCells.Contains((itemGameX, itemGameY)))
                        {
                            if (!layer5ToDeleteByS32.ContainsKey(s32Data))
                            {
                                layer5ToDeleteByS32[s32Data] = new List<Layer5Item>();
                            }
                            if (!layer5ToDeleteByS32[s32Data].Contains(item5))
                            {
                                layer5ToDeleteByS32[s32Data].Add(item5);
                                layer5to8Count++;
                            }
                        }
                    }
                }
            }

            if (layer1Count == 0 && layer2Count == 0 && layer3Count == 0 && layer4Count == 0 && layer5to8Count == 0)
            {
                this.toolStripStatusLabel1.Text = $"選中的 {cells.Count} 個格子內沒有可刪除的資料";
                return;
            }

            // 組合確認訊息
            var deleteParts = new List<string>();
            if (deleteLayer1 && layer1Count > 0) deleteParts.Add($"L1:{layer1Count}");
            if (deleteLayer2 && layer2Count > 0) deleteParts.Add($"L2:{layer2Count}");
            if (deleteLayer3 && layer3Count > 0) deleteParts.Add($"L3:{layer3Count}");
            if (deleteLayer4 && layer4Count > 0) deleteParts.Add($"L4:{layer4Count}");
            if (deleteLayer5to8 && layer5to8Count > 0) deleteParts.Add($"L5:{layer5to8Count}");

            string deleteInfo = string.Join(", ", deleteParts);

            // 確認刪除
            DialogResult result = WinFormsMessageBox.Show(
                $"確定要刪除選中區域內的資料嗎？\n" +
                $"選中格子數: {cells.Count}\n" +
                $"刪除項目: {deleteInfo}\n" +
                $"影響 {affectedS32.Count} 個 S32 檔案",
                "確認批量刪除",
                MessageBoxButtons.YesNo,
                MessageBoxIcon.Warning);

            if (result == DialogResult.Yes)
            {
                // 建立 Undo 記錄
                var undoAction = new UndoAction
                {
                    Description = $"批量刪除 {cells.Count} 格 ({deleteInfo})"
                };

                // 記錄 Layer4 物件到 Undo
                if (deleteLayer4)
                {
                    foreach (var kvp in objectsToDeleteByS32)
                    {
                        S32Data s32Data = kvp.Key;
                        int segStartX = s32Data.SegInfo.nLinBeginX;
                        int segStartY = s32Data.SegInfo.nLinBeginY;

                        foreach (var obj in kvp.Value)
                        {
                            undoAction.RemovedObjects.Add(new UndoObjectInfo
                            {
                                S32FilePath = s32Data.FilePath,
                                GameX = segStartX + obj.X / 2,
                                GameY = segStartY + obj.Y,
                                LocalX = obj.X,
                                LocalY = obj.Y,
                                GroupId = obj.GroupId,
                                Layer = obj.Layer,
                                IndexId = obj.IndexId,
                                TileId = obj.TileId
                            });
                        }
                    }
                }

                // 儲存 Undo 記錄
                PushUndoAction(undoAction);

                // 執行刪除
                foreach (var cell in cells)
                {
                    int layer3X = cell.LocalX / 2;

                    // 刪除 Layer1 資料（清空為預設值）
                    if (deleteLayer1)
                    {
                        int layer1X = cell.LocalX;
                        if (cell.LocalY >= 0 && cell.LocalY < 64 && layer1X >= 0 && layer1X < 128)
                        {
                            cell.S32Data.Layer1[cell.LocalY, layer1X] = new TileCell { X = layer1X, Y = cell.LocalY, TileId = 0, IndexId = 0 };
                        }
                        if (cell.LocalY >= 0 && cell.LocalY < 64 && layer1X + 1 >= 0 && layer1X + 1 < 128)
                        {
                            cell.S32Data.Layer1[cell.LocalY, layer1X + 1] = new TileCell { X = layer1X + 1, Y = cell.LocalY, TileId = 0, IndexId = 0 };
                        }
                    }

                    // 刪除 Layer3 資料（清空為預設值）
                    if (deleteLayer3)
                    {
                        if (cell.LocalY >= 0 && cell.LocalY < 64 && layer3X >= 0 && layer3X < 64)
                        {
                            cell.S32Data.Layer3[cell.LocalY, layer3X] = new MapAttribute { Attribute1 = 0, Attribute2 = 0 };
                        }
                    }

                    cell.S32Data.IsModified = true;
                }

                // 刪除 Layer4 物件
                if (deleteLayer4)
                {
                    foreach (var kvp in objectsToDeleteByS32)
                    {
                        S32Data s32Data = kvp.Key;
                        foreach (var obj in kvp.Value)
                        {
                            s32Data.Layer4.Remove(obj);
                        }
                        Layer4Index_RemoveRange(s32Data, kvp.Value);
                        s32Data.IsModified = true;
                    }
                }

                // 刪除 Layer2（按格子刪除）
                int layer2Deleted = 0;
                if (deleteLayer2)
                {
                    foreach (var kvp in layer2ToDeleteByS32)
                    {
                        S32Data s32Data = kvp.Key;
                        foreach (var item in kvp.Value)
                        {
                            s32Data.Layer2.Remove(item);
                            layer2Deleted++;
                        }
                        s32Data.IsModified = true;
                    }
                }

                // 刪除 Layer5（按格子刪除透明圖塊）
                int layer5Deleted = 0;
                if (deleteLayer5to8)
                {
                    foreach (var kvp in layer5ToDeleteByS32)
                    {
                        S32Data s32Data = kvp.Key;
                        foreach (var item in kvp.Value)
                        {
                            s32Data.Layer5.Remove(item);
                            layer5Deleted++;
                        }
                        s32Data.IsModified = true;
                    }
                }

                // 清除快取並重新渲染
                ClearS32BlockCache();
                RenderS32Map();

                // 更新 Layer5 異常檢查按鈕
                UpdateMapValidateButton();

                // 組合結果訊息
                var resultParts = new List<string>();
                if (deleteLayer1 && layer1Count > 0) resultParts.Add($"L1:{layer1Count}");
                if (deleteLayer2 && layer2Deleted > 0) resultParts.Add($"L2:{layer2Deleted}");
                if (deleteLayer3 && layer3Count > 0) resultParts.Add($"L3:{layer3Count}");
                if (deleteLayer4 && layer4Count > 0) resultParts.Add($"L4:{layer4Count}");
                if (deleteLayer5to8 && layer5Deleted > 0) resultParts.Add($"L5:{layer5Deleted}");

                string resultInfo = resultParts.Count > 0 ? string.Join(", ", resultParts) : "無";
                this.toolStripStatusLabel1.Text = $"已刪除 {cells.Count} 格 ({resultInfo})，影響 {affectedS32.Count} 個 S32 檔案";
            }
        }

        // 刪除指定格子的所有第四層物件
        private void DeleteAllLayer4ObjectsAtCell(int cellX, int cellY)
        {
            // 找出該格子的所有物件
            var objectsAtCell = currentS32Data.Layer4.Where(o => o.X == cellX && o.Y == cellY).ToList();

            if (objectsAtCell.Count == 0)
            {
                this.toolStripStatusLabel1.Text = $"格子 ({cellX},{cellY}) 沒有第四層物件";
                return;
            }

            // 確認刪除（計算遊戲座標，Layer3 尺度）
            int layer3X = cellX / 2;
            if (layer3X >= 64) layer3X = 63;
            int gameX = currentS32FileItem.SegInfo.nLinBeginX + layer3X;
            int gameY = currentS32FileItem.SegInfo.nLinBeginY + cellY;

            DialogResult result = WinFormsMessageBox.Show(
                $"確定要刪除格子 ({cellX},{cellY}) 的所有第四層物件嗎？\n" +
                $"遊戲座標: ({gameX},{gameY})\n" +
                $"共有 {objectsAtCell.Count} 個物件",
                "確認刪除",
                MessageBoxButtons.YesNo,
                MessageBoxIcon.Warning);

            if (result == DialogResult.Yes)
            {
                // 建立 Undo 記錄
                var undoAction = new UndoAction
                {
                    Description = $"刪除格子 ({gameX},{gameY}) 的 {objectsAtCell.Count} 個 Layer4 物件"
                };

                // 刪除所有物件
                foreach (var obj in objectsAtCell)
                {
                    // 記錄到 Undo（刪除的物件）
                    undoAction.RemovedObjects.Add(new UndoObjectInfo
                    {
                        S32FilePath = currentS32Data.FilePath,
                        GameX = gameX,
                        GameY = gameY,
                        LocalX = obj.X,
                        LocalY = obj.Y,
                        GroupId = obj.GroupId,
                        Layer = obj.Layer,
                        IndexId = obj.IndexId,
                        TileId = obj.TileId
                    });

                    currentS32Data.Layer4.Remove(obj);
                }
                Layer4Index_RemoveRange(currentS32Data, objectsAtCell);

                // 儲存 Undo 記錄
                PushUndoAction(undoAction);

                isS32Modified = true;
                RenderS32Map();
                this.toolStripStatusLabel1.Text = $"已刪除格子 ({cellX},{cellY}) 的 {objectsAtCell.Count} 個第四層物件";
            }
        }

        // 檢查點是否在菱形內
        private bool IsPointInDiamond(Point p, Point p1, Point p2, Point p3, Point p4)
        {
            // 使用 Region 來檢測
            using (GraphicsPath path = new GraphicsPath())
            {
                path.AddPolygon(new Point[] { p1, p2, p3, p4 });
                using (Region region = new Region(path))
                {
                    return region.IsVisible(p);
                }
            }
        }

        // 顯示格子的四層 Tile 對話框
        private void ShowCellLayersDialog(int cellX, int cellY)
        {
            // 計算遊戲座標（Layer3 尺度）
            // cellX 是 Layer1 座標 (0-127)，需轉換為 Layer3 座標 (0-63)
            int layer3X = cellX / 2;
            if (layer3X >= 64) layer3X = 63;
            int gameX = currentS32FileItem.SegInfo.nLinBeginX + layer3X;
            int gameY = currentS32FileItem.SegInfo.nLinBeginY + cellY;

            // 創建對話框
            Form layerForm = new Form();
            layerForm.Text = $"格子詳細資訊 - 格子座標 ({cellX}, {cellY}) - 遊戲座標 ({gameX}, {gameY})";
            layerForm.Size = new Size(800, 600);
            layerForm.SetFormBorderStyle(FormBorderStyle.Sizable);
            layerForm.SetStartPosition(FormStartPosition.CenterParent);

            // 使用 TabControl 來組織不同的資訊 - 每層一個 Tab
            TabControl tabControl = new TabControl();
            tabControl.SetDock(DockStyle.Fill);

            // 預先檢查各層是否有資料
            int normX = (cellX / 2) * 2;
            int leftX = normX, rightX = normX + 1;
            bool hasL1 = (leftX < 128 && cellY < 64 && currentS32Data.Layer1[cellY, leftX]?.TileId > 0) ||
                         (rightX < 128 && cellY < 64 && currentS32Data.Layer1[cellY, rightX]?.TileId > 0);
            bool hasL2 = HasLayer2AtCell(normX, cellY);
            bool hasL3 = cellY < 64 && layer3X < 64 && currentS32Data.Layer3[cellY, layer3X] != null;
            bool hasL4 = currentS32Data.Layer4.Any(o => (o.X / 2) * 2 == normX && o.Y == cellY);
            bool hasL5 = HasLayer5AtCell(normX, cellY);
            bool hasL6 = hasL1 || hasL4 || hasL2;  // 有任何 tile 就有 L6
            bool hasL7 = currentS32Data.Layer7.Any(p => (p.X / 2) * 2 == normX && p.Y == cellY);
            bool hasL8 = HasLayer8AtCell(normX, cellY);

            // L1: 地板
            TabPage tabL1 = new TabPage(hasL1 ? "L1 地板" : "L1 ·");
            var layer1Panel = CreateLayerPanel(cellX, cellY, 1);
            tabL1.GetControls().Add(layer1Panel);
            tabControl.GetTabPages().Add(tabL1);

            // L2: 資料
            TabPage tabL2 = new TabPage(hasL2 ? "L2" : "L2 ·");
            var layer2Panel = CreateLayer2Panel(cellX, cellY);
            tabL2.GetControls().Add(layer2Panel);
            tabControl.GetTabPages().Add(tabL2);

            // L3: 屬性
            TabPage tabL3 = new TabPage(hasL3 ? "L3 屬性" : "L3 ·");
            var layer3Panel = CreateLayer3Panel(cellX, cellY);
            tabL3.GetControls().Add(layer3Panel);
            tabControl.GetTabPages().Add(tabL3);

            // L4: 物件
            TabPage tabL4 = new TabPage(hasL4 ? "L4 物件" : "L4 ·");
            var layer4Panel = CreateLayer4Panel(cellX, cellY);
            tabL4.GetControls().Add(layer4Panel);
            tabControl.GetTabPages().Add(tabL4);

            // L5: 透明圖塊
            TabPage tabL5 = new TabPage(hasL5 ? "L5 透明" : "L5 ·");
            var layer5Panel = CreateLayer5Panel(cellX, cellY);
            tabL5.GetControls().Add(layer5Panel);
            tabControl.GetTabPages().Add(tabL5);

            // L6: 使用的 Til
            TabPage tabL6 = new TabPage(hasL6 ? "L6 Til" : "L6 ·");
            var layer6Panel = CreateLayer6Panel(cellX, cellY);
            tabL6.GetControls().Add(layer6Panel);
            tabControl.GetTabPages().Add(tabL6);

            // L7: 傳送點
            TabPage tabL7 = new TabPage(hasL7 ? "L7 傳送" : "L7 ·");
            var layer7Panel = CreateLayer7Panel(cellX, cellY);
            tabL7.GetControls().Add(layer7Panel);
            tabControl.GetTabPages().Add(tabL7);

            // L8: 特效
            TabPage tabL8 = new TabPage(hasL8 ? "L8 特效" : "L8 ·");
            var layer8Panel = CreateLayer8Panel(cellX, cellY);
            tabL8.GetControls().Add(layer8Panel);
            tabControl.GetTabPages().Add(tabL8);

            // 渲染資料
            TabPage tabRender = new TabPage("渲染資料");
            var renderPanel = CreateRenderInfoPanel(cellX, cellY);
            tabRender.GetControls().Add(renderPanel);
            tabControl.GetTabPages().Add(tabRender);

            layerForm.GetControls().Add(tabControl);
            layerForm.ShowDialog(this);
        }

        // 檢查指定格子是否有 Layer2 資料（搜尋所有 S32）
        private bool HasLayer2AtCell(int normX, int y)
        {
            int globalLayer1X = currentS32Data.SegInfo.nLinBeginX * 2 + normX;
            int globalLayer1Y = currentS32Data.SegInfo.nLinBeginY + y;

            foreach (var s32Data in _document.S32Files.Values)
            {
                if (s32Data.Layer2.Count == 0) continue;
                int s32StartX = s32Data.SegInfo.nLinBeginX * 2;
                int s32StartY = s32Data.SegInfo.nLinBeginY;

                foreach (var item2 in s32Data.Layer2)
                {
                    int itemGlobalX = s32StartX + item2.X;
                    int itemGlobalY = s32StartY + item2.Y;
                    if ((itemGlobalX == globalLayer1X || itemGlobalX == globalLayer1X + 1) && itemGlobalY == globalLayer1Y)
                        return true;
                }
            }
            return false;
        }

        // 檢查指定格子是否有 Layer5 資料（搜尋所有 S32）
        private bool HasLayer5AtCell(int normX, int y)
        {
            int globalLayer1X = currentS32Data.SegInfo.nLinBeginX * 2 + normX;
            int globalLayer1Y = currentS32Data.SegInfo.nLinBeginY + y;

            foreach (var s32Data in _document.S32Files.Values)
            {
                if (s32Data.Layer5.Count == 0) continue;
                int s32StartX = s32Data.SegInfo.nLinBeginX * 2;
                int s32StartY = s32Data.SegInfo.nLinBeginY;

                foreach (var item5 in s32Data.Layer5)
                {
                    int itemGlobalX = s32StartX + item5.X;
                    int itemGlobalY = s32StartY + item5.Y;
                    if ((itemGlobalX == globalLayer1X || itemGlobalX == globalLayer1X + 1) && itemGlobalY == globalLayer1Y)
                        return true;
                }
            }
            return false;
        }

        // 檢查指定格子是否有 Layer8 資料（搜尋所有 S32）
        private bool HasLayer8AtCell(int normX, int y)
        {
            int globalLayer1X = currentS32Data.SegInfo.nLinBeginX * 2 + normX;
            int globalLayer1Y = currentS32Data.SegInfo.nLinBeginY + y;

            foreach (var s32Data in _document.S32Files.Values)
            {
                if (s32Data.Layer8.Count == 0) continue;
                int s32StartX = s32Data.SegInfo.nLinBeginX * 2;
                int s32StartY = s32Data.SegInfo.nLinBeginY;

                foreach (var item8 in s32Data.Layer8)
                {
                    int itemGlobalX = s32StartX + item8.X;
                    int itemGlobalY = s32StartY + item8.Y;
                    if ((itemGlobalX == globalLayer1X || itemGlobalX == globalLayer1X + 1) && itemGlobalY == globalLayer1Y)
                        return true;
                }
            }
            return false;
        }

        // 創建第一層面板（含 S32 檔案資訊，分左右三角顯示）
        private Panel CreateLayerPanel(int x, int y, int layer)
        {
            Panel panel = new Panel();
            panel.SetDock(DockStyle.Fill);

            // S32 檔案資訊
            Label s32Info = new Label();
            string s32Name = System.IO.Path.GetFileName(currentS32Data.FilePath);
            int gameX = currentS32FileItem.SegInfo.nLinBeginX + x / 2;
            int gameY = currentS32FileItem.SegInfo.nLinBeginY + y;
            s32Info.Text = $"S32: {s32Name} | 遊戲座標: ({gameX}, {gameY})";
            s32Info.SetDock(DockStyle.Top);
            s32Info.Height = 20;
            s32Info.BackgroundColor = Color.FromArgb(60, 60, 60);
            s32Info.TextColor = Colors.White;
            s32Info.SetTextAlign(ContentAlignment.MiddleCenter);
            s32Info.Font = new Font("Consolas", 9);

            // 左右三角並排顯示
            int leftX = (x / 2) * 2;      // 偶數 X（左三角）
            int rightX = leftX + 1;        // 奇數 X（右三角）

            SplitContainer split = new SplitContainer();
            split.SetDock(DockStyle.Fill);
            split.Orientation = Orientation.Vertical;
            split.SplitterDistance = 350;
            split.SplitterMoved += (s, e) => { }; // 允許手動調整
            // 視窗大小改變時自動置中
            split.Resize += (s, e) =>
            {
                if (split.Width > 0)
                    split.SplitterDistance = split.Width / 2;
            };

            // 左三角面板
            Panel leftPanel = new Panel();
            leftPanel.SetDock(DockStyle.Fill);

            Label leftTitle = new Label();
            leftTitle.Text = $"◀ 左三角 (X={leftX})";
            leftTitle.SetDock(DockStyle.Top);
            leftTitle.Height = 22;
            leftTitle.BackgroundColor = Colors.LightBlue;
            leftTitle.SetTextAlign(ContentAlignment.MiddleCenter);

            var leftCell = (leftX < 128 && y < 64) ? currentS32Data.Layer1[y, leftX] : null;
            PictureBox leftPb = new PictureBox();
            leftPb.SetDock(DockStyle.Fill);
            leftPb.SetSizeMode(PictureBoxSizeMode.Zoom);
            leftPb.BackgroundColor = Colors.Black;

            if (leftCell != null && leftCell.TileId > 0)
            {
                leftPb.Image = LoadTileEnlarged(leftCell.TileId, leftCell.IndexId, 100);

                Label leftInfo = new Label();
                leftInfo.Text = $"Tile: {leftCell.TileId} | Idx: {leftCell.IndexId}";
                leftInfo.SetDock(DockStyle.Bottom);
                leftInfo.Height = 22;
                leftInfo.SetTextAlign(ContentAlignment.MiddleCenter);
                leftPanel.GetControls().Add(leftInfo);
            }

            leftPanel.GetControls().Add(leftPb);
            leftPanel.GetControls().Add(leftTitle);
            split.Panel1.GetControls().Add(leftPanel);

            // 右三角面板
            Panel rightPanel = new Panel();
            rightPanel.SetDock(DockStyle.Fill);

            Label rightTitle = new Label();
            rightTitle.Text = $"▶ 右三角 (X={rightX})";
            rightTitle.SetDock(DockStyle.Top);
            rightTitle.Height = 22;
            rightTitle.BackgroundColor = Colors.LightGreen;
            rightTitle.SetTextAlign(ContentAlignment.MiddleCenter);

            var rightCell = (rightX < 128 && y < 64) ? currentS32Data.Layer1[y, rightX] : null;
            PictureBox rightPb = new PictureBox();
            rightPb.SetDock(DockStyle.Fill);
            rightPb.SetSizeMode(PictureBoxSizeMode.Zoom);
            rightPb.BackgroundColor = Colors.Black;

            if (rightCell != null && rightCell.TileId > 0)
            {
                rightPb.Image = LoadTileEnlarged(rightCell.TileId, rightCell.IndexId, 100);

                Label rightInfo = new Label();
                rightInfo.Text = $"Tile: {rightCell.TileId} | Idx: {rightCell.IndexId}";
                rightInfo.SetDock(DockStyle.Bottom);
                rightInfo.Height = 22;
                rightInfo.SetTextAlign(ContentAlignment.MiddleCenter);
                rightPanel.GetControls().Add(rightInfo);
            }

            rightPanel.GetControls().Add(rightPb);
            rightPanel.GetControls().Add(rightTitle);
            split.Panel2.GetControls().Add(rightPanel);

            panel.GetControls().Add(split);
            panel.GetControls().Add(s32Info);
            return panel;
        }

        // 創建第二層面板 - 搜尋所有 S32，按左三角/右三角及不同 S32 分開顯示
        private Panel CreateLayer2Panel(int x, int y)
        {
            Panel panel = new Panel();
            panel.SetDock(DockStyle.Fill);

            // 計算當前格子的全域 Layer1 座標
            int normalizedX = (x / 2) * 2;  // 正規化為偶數（同一格的左半）
            int globalLayer1X = currentS32Data.SegInfo.nLinBeginX * 2 + normalizedX;
            int globalLayer1Y = currentS32Data.SegInfo.nLinBeginY + y;

            // 搜尋所有 S32 的 Layer2（因為相鄰 S32 的裝飾可能超出邊界）
            // 分類：左三角 (x偶數) 和 右三角 (x奇數)
            var leftItems = new List<(string s32Name, S32Data s32Data, Layer2Item item)>();
            var rightItems = new List<(string s32Name, S32Data s32Data, Layer2Item item)>();

            foreach (var s32Data in _document.S32Files.Values)
            {
                if (s32Data.Layer2.Count == 0) continue;

                int s32StartX = s32Data.SegInfo.nLinBeginX * 2;
                int s32StartY = s32Data.SegInfo.nLinBeginY;
                string s32Name = System.IO.Path.GetFileName(s32Data.FilePath);

                foreach (var item in s32Data.Layer2)
                {
                    int itemGlobalX = s32StartX + item.X;
                    int itemGlobalY = s32StartY + item.Y;

                    // 檢查是否在目標格子範圍內（左半 x 或 右半 x+1）
                    if (itemGlobalY == globalLayer1Y)
                    {
                        if (itemGlobalX == globalLayer1X)
                        {
                            leftItems.Add((s32Name, s32Data, item));
                        }
                        else if (itemGlobalX == globalLayer1X + 1)
                        {
                            rightItems.Add((s32Name, s32Data, item));
                        }
                    }
                }
            }

            int totalCount = leftItems.Count + rightItems.Count;
            if (totalCount > 0)
            {
                // SplitContainer: 左邊 ListView，右邊預覽
                SplitContainer splitContainer = new SplitContainer();
                splitContainer.SetDock(DockStyle.Fill);
                splitContainer.Orientation = Orientation.Vertical;
                splitContainer.SplitterDistance = 280;

                // 左邊：ListView
                ListView listView = new ListView();
                listView.SetDock(DockStyle.Fill);
                listView.View = View.Details;
                listView.FullRowSelect = true;
                listView.GridLines = true;
                listView.HideSelection = false;

                listView.Columns.Add("區域", 50);
                listView.Columns.Add("S32", 85);
                listView.Columns.Add("X", 40);
                listView.Columns.Add("Y", 40);
                listView.Columns.Add("Tile", 50);
                listView.Columns.Add("Idx", 40);

                // 左三角項目
                foreach (var (s32Name, s32Data, item) in leftItems)
                {
                    var lvItem = new ListViewItem("◀左");
                    lvItem.BackgroundColor = Colors.LightBlue;
                    lvItem.SubItems.Add(s32Name);
                    lvItem.SubItems.Add(item.X.ToString());
                    lvItem.SubItems.Add(item.Y.ToString());
                    lvItem.SubItems.Add(item.TileId.ToString());
                    lvItem.SubItems.Add(item.IndexId.ToString());
                    lvItem.Tag = (s32Data, item);
                    listView.Items.Add(lvItem);
                }

                // 右三角項目
                foreach (var (s32Name, s32Data, item) in rightItems)
                {
                    var lvItem = new ListViewItem("▶右");
                    lvItem.BackgroundColor = Colors.LightGreen;
                    lvItem.SubItems.Add(s32Name);
                    lvItem.SubItems.Add(item.X.ToString());
                    lvItem.SubItems.Add(item.Y.ToString());
                    lvItem.SubItems.Add(item.TileId.ToString());
                    lvItem.SubItems.Add(item.IndexId.ToString());
                    lvItem.Tag = (s32Data, item);
                    listView.Items.Add(lvItem);
                }

                splitContainer.Panel1.GetControls().Add(listView);

                // 右邊：預覽面板
                Panel previewPanel = new Panel();
                previewPanel.SetDock(DockStyle.Fill);
                previewPanel.BackgroundColor = Colors.Black;

                PictureBox previewPb = new PictureBox();
                previewPb.SetDock(DockStyle.Fill);
                previewPb.SetSizeMode(PictureBoxSizeMode.Zoom);
                previewPb.BackgroundColor = Colors.Black;
                previewPanel.GetControls().Add(previewPb);

                Label previewInfo = new Label();
                previewInfo.SetDock(DockStyle.Bottom);
                previewInfo.Height = 40;
                previewInfo.TextColor = Colors.White;
                previewInfo.BackgroundColor = Color.FromArgb(40, 40, 40);
                previewInfo.SetTextAlign(ContentAlignment.MiddleCenter);
                previewInfo.Text = "選取項目以預覽";
                previewPanel.GetControls().Add(previewInfo);

                Button btnDelete = new Button();
                btnDelete.Text = "刪除";
                btnDelete.SetDock(DockStyle.Top);
                btnDelete.Height = 25;
                btnDelete.BackgroundColor = WinFormsColors.IndianRed;
                btnDelete.TextColor = Colors.White;
                btnDelete.Enabled = false;
                previewPanel.GetControls().Add(btnDelete);

                splitContainer.Panel2.GetControls().Add(previewPanel);

                // 選取事件
                listView.SelectedIndexChanged += (s, e) =>
                {
                    if (listView.SelectedItems.Count > 0)
                    {
                        var selected = listView.SelectedItems[0];
                        var (s32Data, item) = ((S32Data, Layer2Item))selected.Tag;

                        previewPb.Image = LoadTileEnlarged(item.TileId, item.IndexId, 100);
                        previewInfo.Text = $"Tile: {item.TileId} | Idx: {item.IndexId}\n" +
                                           $"位置: ({item.X}, {item.Y})";
                        btnDelete.Enabled = true;
                        btnDelete.Tag = (s32Data, item);
                    }
                    else
                    {
                        previewPb.Image = null;
                        previewInfo.Text = "選取項目以預覽";
                        btnDelete.Enabled = false;
                    }
                };

                // 刪除事件
                btnDelete.Click += (s, e) =>
                {
                    if (btnDelete.Tag != null)
                    {
                        var (s32Data, item) = ((S32Data, Layer2Item))btnDelete.Tag;

                        if (WinFormsMessageBox.Show($"確定要刪除這個 Layer2 項目？\nTile: {item.TileId}, Idx: {item.IndexId}",
                            "確認刪除", MessageBoxButtons.YesNo, MessageBoxIcon.Question) == DialogResult.Yes)
                        {
                            s32Data.Layer2.Remove(item);
                            s32Data.IsModified = true;
                            ClearS32BlockCache();
                            RenderS32Map();

                            // 從 ListView 移除
                            listView.Items.Remove(listView.SelectedItems[0]);
                            previewPb.Image = null;
                            previewInfo.Text = "已刪除";
                            btnDelete.Enabled = false;

                            this.toolStripStatusLabel1.Text = $"已刪除 Layer2 項目 (Tile:{item.TileId})";
                        }
                    }
                };

                panel.GetControls().Add(splitContainer);
            }
            else
            {
                Label noData = new Label();
                noData.Text = $"此格子無 Layer2 資料\n\n(全域座標: {globalLayer1X}, {globalLayer1Y})";
                noData.SetDock(DockStyle.Fill);
                noData.SetTextAlign(ContentAlignment.MiddleCenter);
                panel.GetControls().Add(noData);
            }

            return panel;
        }

        // 創建第三層面板
        private Panel CreateLayer3Panel(int x, int y)
        {
            Panel panel = new Panel();
            panel.BorderStyle = BorderStyle.FixedSingle;
            panel.SetDock(DockStyle.Fill);
            panel.AutoScroll = true; // 內容過長時可捲動

            Label title = new Label();
            title.Text = "第3層 (屬性)";
            title.Font = new Font("Arial", 10, FontStyle.Bold);
            title.SetDock(DockStyle.Top);
            title.Height = 25;
            title.SetTextAlign(ContentAlignment.MiddleCenter);
            panel.GetControls().Add(title);

            // Layer3 使用遊戲座標 (0~63, 0~63)
            // Layer1 的 X 需要除以 2 轉換為遊戲座標
            int gameX = x / 2;
            if (gameX >= 64) gameX = 63;
            if (gameX < 0) gameX = 0;
            int gameY = y;
            if (gameY >= 64) gameY = 63;
            if (gameY < 0) gameY = 0;

            var attr = currentS32Data.Layer3[gameY, gameX];
            if (attr != null)
            {
                // 內容面板（放在可捲動區域內）
                Panel contentPanel = new Panel();
                contentPanel.SetDock(DockStyle.Top);
                contentPanel.SetAutoSize(true);
                contentPanel.Padding = new Padding(5);

                Label info = new Label();
                info.SetAutoSize(true);

                string attrText = $"遊戲座標: ({gameX}, {gameY})\n";
                attrText += $"(Layer1 X={x}, Y={y})\n";
                attrText += "─────────────\n";

                // Attribute1 (左上)
                short attr1 = attr.Attribute1;
                int low1 = attr1 & 0x0F;
                bool pass1 = (attr1 & 0x01) == 0;
                bool safe1 = (low1 & 0x04) != 0;
                bool combat1 = (low1 & 0x0C) == 0x08;
                string region1 = safe1 ? "安全" : (combat1 ? "戰鬥" : "一般");

                attrText += $"\n【Attr1 左上】\n";
                attrText += $"  值: 0x{attr1:X4}\n";
                attrText += $"  區域: {region1}\n";
                attrText += $"  通行: {(pass1 ? "可" : "不可")}\n";

                // Attribute2 (右上)
                short attr2 = attr.Attribute2;
                int low2 = attr2 & 0x0F;
                bool pass2 = (attr2 & 0x01) == 0;
                bool safe2 = (low2 & 0x04) != 0;
                bool combat2 = (low2 & 0x0C) == 0x08;
                string region2 = safe2 ? "安全" : (combat2 ? "戰鬥" : "一般");

                attrText += $"\n【Attr2 右上】\n";
                attrText += $"  值: 0x{attr2:X4}\n";
                attrText += $"  區域: {region2}\n";
                attrText += $"  通行: {(pass2 ? "可" : "不可")}";

                info.Text = attrText;
                info.SetLocation(new Point(5, 5));
                contentPanel.GetControls().Add(info);
                panel.GetControls().Add(contentPanel);

                // 刪除按鈕
                Button btnDelete = new Button();
                btnDelete.Text = "清除屬性";
                btnDelete.SetDock(DockStyle.Bottom);
                btnDelete.Height = 25;
                btnDelete.BackgroundColor = Colors.Red;
                btnDelete.TextColor = Colors.White;
                btnDelete.Click += (s, e) =>
                {
                    if (WinFormsMessageBox.Show("確定要清除此格的屬性嗎？", "確認", MessageBoxButtons.YesNo, MessageBoxIcon.Question) == DialogResult.Yes)
                    {
                        currentS32Data.Layer3[y, gameX] = new MapAttribute { Attribute1 = 0, Attribute2 = 0 };
                        isS32Modified = true;
                        RenderS32Map();
                        this.toolStripStatusLabel1.Text = $"已清除第3層 ({gameX},{y}) 的屬性";

                        // 更新當前面板顯示
                        info.Text = "已清除屬性";
                        btnDelete.Enabled = false;
                    }
                };
                panel.GetControls().Add(btnDelete);
            }
            else
            {
                Label noData = new Label();
                noData.Text = "無資料";
                noData.SetDock(DockStyle.Fill);
                noData.SetTextAlign(ContentAlignment.MiddleCenter);
                panel.GetControls().Add(noData);
            }

            return panel;
        }

        // 創建第四層面板 - 搜尋所有 S32，按左三角/右三角及不同 S32 分開顯示
        private Panel CreateLayer4Panel(int x, int y)
        {
            Panel panel = new Panel();
            panel.SetDock(DockStyle.Fill);

            // 計算當前格子的全域 Layer1 座標
            int normalizedX = (x / 2) * 2;  // 正規化為偶數（同一格的左半）
            int globalLayer1X = currentS32Data.SegInfo.nLinBeginX * 2 + normalizedX;
            int globalLayer1Y = currentS32Data.SegInfo.nLinBeginY + y;

            // 搜尋所有 S32 的 Layer4（因為相鄰 S32 的物件可能超出邊界）
            // 分類：左三角 (x偶數) 和 右三角 (x奇數)
            var leftObjects = new List<(string s32Name, S32Data s32Data, ObjectTile obj)>();
            var rightObjects = new List<(string s32Name, S32Data s32Data, ObjectTile obj)>();

            foreach (var s32Data in _document.S32Files.Values)
            {
                if (s32Data.Layer4.Count == 0) continue;

                int s32StartX = s32Data.SegInfo.nLinBeginX * 2;
                int s32StartY = s32Data.SegInfo.nLinBeginY;
                string s32Name = System.IO.Path.GetFileName(s32Data.FilePath);

                foreach (var obj in s32Data.Layer4)
                {
                    int objGlobalX = s32StartX + obj.X;
                    int objGlobalY = s32StartY + obj.Y;

                    // 檢查是否在目標格子範圍內（左半 x 或 右半 x+1）
                    if (objGlobalY == globalLayer1Y)
                    {
                        if (objGlobalX == globalLayer1X)
                        {
                            leftObjects.Add((s32Name, s32Data, obj));
                        }
                        else if (objGlobalX == globalLayer1X + 1)
                        {
                            rightObjects.Add((s32Name, s32Data, obj));
                        }
                    }
                }
            }

            int totalCount = leftObjects.Count + rightObjects.Count;
            if (totalCount > 0)
            {
                // SplitContainer: 左邊 ListView，右邊預覽
                SplitContainer splitContainer = new SplitContainer();
                splitContainer.SetDock(DockStyle.Fill);
                splitContainer.Orientation = Orientation.Vertical;
                splitContainer.SplitterDistance = 280;

                // 左邊：ListView
                ListView listView = new ListView();
                listView.SetDock(DockStyle.Fill);
                listView.View = View.Details;
                listView.FullRowSelect = true;
                listView.GridLines = true;
                listView.HideSelection = false;

                listView.Columns.Add("區域", 50);
                listView.Columns.Add("S32", 85);
                listView.Columns.Add("L", 30);
                listView.Columns.Add("Grp", 45);
                listView.Columns.Add("Tile", 45);
                listView.Columns.Add("Idx", 35);

                // 左三角物件
                foreach (var (s32Name, s32Data, obj) in leftObjects.OrderBy(o => o.obj.Layer))
                {
                    var item = new ListViewItem("◀左");
                    item.BackgroundColor = Colors.LightBlue;
                    item.SubItems.Add(s32Name);
                    item.SubItems.Add(obj.Layer.ToString());
                    item.SubItems.Add(obj.GroupId.ToString());
                    item.SubItems.Add(obj.TileId.ToString());
                    item.SubItems.Add(obj.IndexId.ToString());
                    item.Tag = (s32Data, obj);
                    listView.Items.Add(item);
                }

                // 右三角物件
                foreach (var (s32Name, s32Data, obj) in rightObjects.OrderBy(o => o.obj.Layer))
                {
                    var item = new ListViewItem("▶右");
                    item.BackgroundColor = Colors.LightGreen;
                    item.SubItems.Add(s32Name);
                    item.SubItems.Add(obj.Layer.ToString());
                    item.SubItems.Add(obj.GroupId.ToString());
                    item.SubItems.Add(obj.TileId.ToString());
                    item.SubItems.Add(obj.IndexId.ToString());
                    item.Tag = (s32Data, obj);
                    listView.Items.Add(item);
                }

                splitContainer.Panel1.GetControls().Add(listView);

                // 右邊：預覽面板
                Panel previewPanel = new Panel();
                previewPanel.SetDock(DockStyle.Fill);
                previewPanel.BackgroundColor = Colors.Black;

                PictureBox previewPb = new PictureBox();
                previewPb.SetDock(DockStyle.Fill);
                previewPb.SetSizeMode(PictureBoxSizeMode.Zoom);
                previewPb.BackgroundColor = Colors.Black;
                previewPanel.GetControls().Add(previewPb);

                Label previewInfo = new Label();
                previewInfo.SetDock(DockStyle.Bottom);
                previewInfo.Height = 40;
                previewInfo.TextColor = Colors.White;
                previewInfo.BackgroundColor = Color.FromArgb(40, 40, 40);
                previewInfo.SetTextAlign(ContentAlignment.MiddleCenter);
                previewInfo.Text = "選取項目以預覽";
                previewPanel.GetControls().Add(previewInfo);

                // 按鈕面板（放在頂部）
                Panel buttonPanel = new Panel();
                buttonPanel.SetDock(DockStyle.Top);
                buttonPanel.Height = 30;

                Button btnEdit = new Button();
                btnEdit.Text = "編輯";
                btnEdit.SetLocation(new Point(5, 2));
                btnEdit.Size = new Size(70, 25);
                btnEdit.BackgroundColor = WinFormsColors.SteelBlue;
                btnEdit.TextColor = Colors.White;
                btnEdit.Enabled = false;
                buttonPanel.GetControls().Add(btnEdit);

                Button btnDelete = new Button();
                btnDelete.Text = "刪除";
                btnDelete.SetLocation(new Point(80, 2));
                btnDelete.Size = new Size(70, 25);
                btnDelete.BackgroundColor = WinFormsColors.IndianRed;
                btnDelete.TextColor = Colors.White;
                btnDelete.Enabled = false;
                buttonPanel.GetControls().Add(btnDelete);

                previewPanel.GetControls().Add(buttonPanel);

                splitContainer.Panel2.GetControls().Add(previewPanel);

                // 選取變更時更新預覽
                listView.SelectedIndexChanged += (s, e) =>
                {
                    if (listView.SelectedItems.Count > 0)
                    {
                        var selItem = listView.SelectedItems[0];
                        var (s32Data, obj) = ((S32Data, ObjectTile))selItem.Tag;
                        previewPb.Image = LoadTileEnlarged(obj.TileId, obj.IndexId, 120);
                        previewInfo.Text = $"Tile:{obj.TileId} Idx:{obj.IndexId}\nL:{obj.Layer} G:{obj.GroupId} X:{obj.X} Y:{obj.Y}";
                        btnDelete.Enabled = true;
                        btnEdit.Enabled = true;
                        btnDelete.Tag = (s32Data, obj, selItem);
                        btnEdit.Tag = (s32Data, obj, selItem);
                    }
                    else
                    {
                        previewPb.Image = null;
                        previewInfo.Text = "選取項目以預覽";
                        btnDelete.Enabled = false;
                        btnEdit.Enabled = false;
                    }
                };

                // 編輯按鈕
                btnEdit.Click += (s, e) =>
                {
                    if (btnEdit.Tag == null) return;
                    var (s32Data, obj, selItem) = ((S32Data, ObjectTile, ListViewItem))btnEdit.Tag;
                    EditLayer4Object(s32Data, obj, selItem, listView, previewPb, previewInfo);
                };

                // 刪除按鈕
                btnDelete.Click += (s, e) =>
                {
                    if (btnDelete.Tag == null) return;
                    var (s32Data, obj, selItem) = ((S32Data, ObjectTile, ListViewItem))btnDelete.Tag;
                    string s32Name = selItem.SubItems[1].Text;
                    if (WinFormsMessageBox.Show($"確定要刪除此物件嗎？\n({s32Name})\nGroup:{obj.GroupId}, Layer:{obj.Layer}",
                        "確認", MessageBoxButtons.YesNo, MessageBoxIcon.Question) == DialogResult.Yes)
                    {
                        s32Data.Layer4.Remove(obj);
                        Layer4Index_Remove(s32Data, obj);
                        s32Data.IsModified = true;
                        RenderS32Map();
                        listView.Items.Remove(selItem);
                        previewPb.Image = null;
                        previewInfo.Text = "已刪除";
                        btnDelete.Enabled = false;
                        btnEdit.Enabled = false;
                        this.toolStripStatusLabel1.Text = $"已刪除物件 ({s32Name})";
                    }
                };

                // 右鍵選單
                listView.MouseClick += (s, e) =>
                {
                    if (e.Buttons == Eto.Forms.MouseButtons.Alternate && listView.SelectedItems.Count > 0)
                    {
                        var selItem = listView.SelectedItems[0];
                        var (s32Data, obj) = ((S32Data, ObjectTile))selItem.Tag;

                        var menu = new ContextMenuStrip();

                        var editItem = new ToolStripMenuItem("編輯此物件");
                        editItem.Click += (s2, e2) =>
                        {
                            EditLayer4Object(s32Data, obj, selItem, listView, previewPb, previewInfo);
                        };
                        menu.Items.Add(editItem);

                        var deleteItem = new ToolStripMenuItem("刪除此物件");
                        deleteItem.Click += (s2, e2) =>
                        {
                            string s32Name = selItem.SubItems[1].Text;
                            if (WinFormsMessageBox.Show($"確定要刪除此物件嗎？\n({s32Name})\nGroup:{obj.GroupId}, Layer:{obj.Layer}",
                                "確認", MessageBoxButtons.YesNo, MessageBoxIcon.Question) == DialogResult.Yes)
                            {
                                s32Data.Layer4.Remove(obj);
                                Layer4Index_Remove(s32Data, obj);
                                s32Data.IsModified = true;
                                RenderS32Map();
                                listView.Items.Remove(selItem);
                                previewPb.Image = null;
                                previewInfo.Text = "已刪除";
                                this.toolStripStatusLabel1.Text = $"已刪除物件 ({s32Name})";
                            }
                        };
                        menu.Items.Add(deleteItem);
                        menu.Show(listView, e.Location);
                    }
                };

                // 雙擊編輯
                listView.MouseDoubleClick += (s, e) =>
                {
                    if (listView.SelectedItems.Count > 0)
                    {
                        var selItem = listView.SelectedItems[0];
                        var (s32Data, obj) = ((S32Data, ObjectTile))selItem.Tag;
                        EditLayer4Object(s32Data, obj, selItem, listView, previewPb, previewInfo);
                    }
                };

                // 統計標籤
                Label statsLabel = new Label();
                statsLabel.Text = $"◀左: {leftObjects.Count} | ▶右: {rightObjects.Count} | 共 {totalCount}";
                statsLabel.SetDock(DockStyle.Top);
                statsLabel.Height = 20;
                statsLabel.SetTextAlign(ContentAlignment.MiddleCenter);
                statsLabel.BackgroundColor = Colors.WhiteSmoke;

                panel.GetControls().Add(splitContainer);
                panel.GetControls().Add(statsLabel);
            }
            else
            {
                Label noData = new Label();
                noData.Text = "此格無物件";
                noData.SetDock(DockStyle.Fill);
                noData.SetTextAlign(ContentAlignment.MiddleCenter);
                panel.GetControls().Add(noData);
            }

            return panel;
        }

        // 編輯 L4 物件
        private void EditLayer4Object(S32Data s32Data, ObjectTile obj, ListViewItem selItem, ListView listView, PictureBox previewPb, Label previewInfo)
        {
            using (var dialog = new L1MapViewer.Forms.L4EditDialog(obj, s32Data, _document.S32Files.Values))
            {
                if (dialog.ShowDialog(this) == DialogResult.Ok)
                {
                    // 檢查是否需要移動到其他 S32
                    var targetS32 = dialog.SelectedS32;
                    bool s32Changed = dialog.S32Changed && targetS32 != null && targetS32 != s32Data;

                    if (s32Changed)
                    {
                        // 從原 S32 移除
                        s32Data.Layer4.Remove(obj);
                        Layer4Index_Remove(s32Data, obj);
                        s32Data.IsModified = true;

                        // 更新物件屬性
                        obj.GroupId = dialog.GroupId;
                        obj.X = dialog.NewX;
                        obj.Y = dialog.NewY;
                        obj.Layer = dialog.Layer;
                        obj.IndexId = dialog.IndexId;
                        obj.TileId = dialog.TileId;

                        // 添加到新 S32
                        targetS32.Layer4.Add(obj);
                        Layer4Index_Add(targetS32, obj);
                        targetS32.IsModified = true;

                        // 更新 ListView 項目
                        string newS32Name = System.IO.Path.GetFileName(targetS32.FilePath);
                        selItem.SubItems[1].Text = newS32Name;
                        selItem.Tag = (targetS32, obj);

                        this.toolStripStatusLabel1.Text = $"已將物件移動到 {newS32Name}";
                    }
                    else
                    {
                        // 只更新屬性
                        obj.GroupId = dialog.GroupId;
                        obj.X = dialog.NewX;
                        obj.Y = dialog.NewY;
                        obj.Layer = dialog.Layer;
                        obj.IndexId = dialog.IndexId;
                        obj.TileId = dialog.TileId;

                        // 更新空間索引（座標可能變了）
                        Layer4Index_Remove(s32Data, obj);
                        Layer4Index_Add(s32Data, obj);
                        s32Data.IsModified = true;

                        this.toolStripStatusLabel1.Text = "已更新物件屬性";
                    }

                    // 更新 ListView 顯示
                    selItem.SubItems[2].Text = obj.Layer.ToString();
                    selItem.SubItems[3].Text = obj.GroupId.ToString();
                    selItem.SubItems[4].Text = obj.TileId.ToString();
                    selItem.SubItems[5].Text = obj.IndexId.ToString();

                    // 更新預覽
                    previewPb.Image = LoadTileEnlarged(obj.TileId, obj.IndexId, 120);
                    previewInfo.Text = $"Tile:{obj.TileId} Idx:{obj.IndexId}\nL:{obj.Layer} G:{obj.GroupId} X:{obj.X} Y:{obj.Y}";

                    // 重新渲染地圖
                    RenderS32Map();
                }
            }
        }

        // 建立 Layer4 物件面板（輔助方法）
        private void CreateLayer4ObjectPanels(FlowLayoutPanel flow, List<(string s32Name, S32Data s32Data, ObjectTile obj)> objects, int x, int y)
        {
            // 按 S32 分組
            var groupedByS32 = objects.GroupBy(o => o.s32Name).OrderBy(g => g.Key);

            foreach (var s32Group in groupedByS32)
            {
                // S32 標題
                Label s32Label = new Label();
                s32Label.Text = s32Group.Key;
                s32Label.Width = flow.Width - 30;
                s32Label.Height = 18;
                s32Label.BackgroundColor = Colors.DarkGray;
                s32Label.TextColor = Colors.White;
                s32Label.SetTextAlign(ContentAlignment.MiddleLeft);
                s32Label.Margin = new Padding(2);
                flow.GetControls().Add(s32Label);

                foreach (var (s32Name, s32Data, obj) in s32Group.OrderBy(o => o.obj.Layer))
                {
                    Panel objPanel = new Panel();
                    objPanel.Width = 130;
                    objPanel.Height = 170;
                    objPanel.BorderStyle = BorderStyle.FixedSingle;
                    objPanel.Margin = new Padding(3);

                    PictureBox pb = new PictureBox();
                    pb.SetDock(DockStyle.Top);
                    pb.Height = 80;
                    pb.SetSizeMode(PictureBoxSizeMode.Zoom);
                    pb.BackgroundColor = Colors.Black;
                    pb.Image = LoadTileEnlarged(obj.TileId, obj.IndexId, 80);
                    objPanel.GetControls().Add(pb);

                    Label info = new Label();
                    info.Text = $"L:{obj.Layer} G:{obj.GroupId}\nT:{obj.TileId} I:{obj.IndexId}";
                    info.SetDock(DockStyle.Top);
                    info.Height = 35;
                    info.Font = new Font("Consolas", 8);
                    info.SetTextAlign(ContentAlignment.MiddleCenter);
                    objPanel.GetControls().Add(info);

                    // 刪除按鈕
                    Button btnDeleteObj = new Button();
                    btnDeleteObj.Text = "刪除";
                    btnDeleteObj.SetDock(DockStyle.Bottom);
                    btnDeleteObj.Height = 22;
                    btnDeleteObj.BackgroundColor = WinFormsColors.IndianRed;
                    btnDeleteObj.TextColor = Colors.White;
                    btnDeleteObj.Font = new Font(Eto.Drawing.SystemFonts.Default().Family, 8);
                    var objToDelete = obj;
                    var s32ToModify = s32Data;
                    btnDeleteObj.Click += (s, e) =>
                    {
                        if (WinFormsMessageBox.Show($"確定要刪除此物件嗎？\n({s32Name})\nGroup:{objToDelete.GroupId}, Layer:{objToDelete.Layer}", "確認", MessageBoxButtons.YesNo, MessageBoxIcon.Question) == DialogResult.Yes)
                        {
                            s32ToModify.Layer4.Remove(objToDelete);
                            Layer4Index_Remove(s32ToModify, objToDelete);
                            s32ToModify.IsModified = true;
                            RenderS32Map();
                            this.toolStripStatusLabel1.Text = $"已刪除第4層物件 ({s32Name})";
                            pb.Image = null;
                            info.Text = "已刪除";
                            btnDeleteObj.Enabled = false;
                        }
                    };
                    objPanel.GetControls().Add(btnDeleteObj);

                    flow.GetControls().Add(objPanel);
                }
            }
        }

        // 創建第五層面板 - 可透明化的圖塊（只顯示該格子相關的項目）
        // 搜尋所有 S32 的 Layer5，因為 S32 的 Layer5 項目可能超出自己的邊界範圍
        private Panel CreateLayer5Panel(int x, int y)
        {
            Panel panel = new Panel();
            panel.SetDock(DockStyle.Fill);

            // 計算當前格子的全域 Layer1 座標
            // x 是 Layer1 座標 (0-127)，y 是 Layer3 座標 (0-63)
            // L5 的 X 偶數和奇數都是同一格（偶數=左半，奇數=右半），需要正規化為偶數
            int normalizedX = (x / 2) * 2;  // 正規化為偶數（同一格的左半）
            int globalLayer1X = currentS32Data.SegInfo.nLinBeginX * 2 + normalizedX;
            int globalLayer1Y = currentS32Data.SegInfo.nLinBeginY + y;

            // 搜尋所有 S32 的 Layer5（不只是當前 S32）
            // 因為相鄰 S32 的 Layer5 項目可能超出自己的邊界
            var cellLayer5Items = new List<(string s32Name, S32Data s32Data, int index, Layer5Item item, int gameX, int gameY)>();

            foreach (var s32Data in _document.S32Files.Values)
            {
                if (s32Data.Layer5.Count == 0) continue;

                // 計算該 S32 的全域座標起點
                int s32StartX = s32Data.SegInfo.nLinBeginX * 2;
                int s32StartY = s32Data.SegInfo.nLinBeginY;

                for (int i = 0; i < s32Data.Layer5.Count; i++)
                {
                    var item5 = s32Data.Layer5[i];

                    // 計算該 L5 項目的全域座標
                    int itemGlobalX = s32StartX + item5.X;
                    int itemGlobalY = s32StartY + item5.Y;

                    // 計算遊戲座標
                    int gameX = s32Data.SegInfo.nLinBeginX + item5.X / 2;
                    int gameY = s32Data.SegInfo.nLinBeginY + item5.Y;

                    // 檢查是否在目標格子範圍內（考慮 x 和 x+1）
                    if ((itemGlobalX == globalLayer1X || itemGlobalX == globalLayer1X + 1)
                        && itemGlobalY == globalLayer1Y)
                    {
                        string s32Name = System.IO.Path.GetFileName(s32Data.FilePath);
                        cellLayer5Items.Add((s32Name, s32Data, i, item5, gameX, gameY));
                    }
                }
            }

            // 新增 L5 按鈕（無論有無資料都顯示）
            Button btnAddL5 = new Button();
            btnAddL5.Text = "新增 L5";
            btnAddL5.SetDock(DockStyle.Top);
            btnAddL5.Height = 28;
            btnAddL5.Click += (sender, e) =>
            {
                using (var dialog = new L5EditDialog(0, 0, true))
                {
                    if (dialog.ShowDialog(this) == DialogResult.Ok)
                    {
                        // 建立新的 Layer5Item
                        var newItem = new Layer5Item
                        {
                            X = (byte)normalizedX,
                            Y = (byte)y,
                            ObjectIndex = (ushort)dialog.ObjectIndex,
                            Type = dialog.L5Type
                        };
                        currentS32Data.Layer5.Add(newItem);
                        currentS32Data.IsModified = true;
                        RenderS32Map();

                        // 關閉當前對話框並重新開啟以刷新
                        if (panel.Parent?.Parent is Form parentForm)
                        {
                            parentForm.Close();
                            ShowCellLayersDialog(x, y);
                        }
                    }
                }
            };

            if (cellLayer5Items.Count > 0)
            {
                Label countLabel = new Label();
                countLabel.Text = $"此格數量: {cellLayer5Items.Count}";
                countLabel.SetDock(DockStyle.Top);
                countLabel.Height = 20;
                countLabel.SetTextAlign(ContentAlignment.MiddleCenter);
                countLabel.BackgroundColor = Colors.WhiteSmoke;

                ListView listView = new ListView();
                listView.SetDock(DockStyle.Fill);
                listView.View = View.Details;
                listView.FullRowSelect = true;
                listView.GridLines = true;
                listView.Scrollable = true;
                listView.HeaderStyle = ColumnHeaderStyle.Clickable;  // 確保顯示表頭

                listView.Columns.Add("來源S32", -2);
                listView.Columns.Add("遊戲X", -2);
                listView.Columns.Add("遊戲Y", -2);
                listView.Columns.Add("L1 X", -2);
                listView.Columns.Add("L1 Y", -2);
                listView.Columns.Add("L4群組", -2);
                listView.Columns.Add("Type", -2);

                foreach (var (s32Name, s32Data, idx, item5, gameX, gameY) in cellLayer5Items)
                {
                    var lvItem = new ListViewItem(s32Name);
                    lvItem.SubItems.Add(gameX.ToString());
                    lvItem.SubItems.Add(gameY.ToString());
                    lvItem.SubItems.Add(item5.X.ToString());
                    lvItem.SubItems.Add(item5.Y.ToString());
                    lvItem.SubItems.Add(item5.ObjectIndex.ToString());
                    lvItem.SubItems.Add(item5.Type.ToString());
                    lvItem.Tag = (s32Data, idx);  // 保存來源 S32 和索引
                    listView.Items.Add(lvItem);
                }

                // 自動調整欄位寬度以適應內容
                listView.AutoResizeColumns(ColumnHeaderAutoResizeStyle.HeaderSize);

                // 右鍵選單 - 編輯/刪除 L5
                listView.MouseClick += (sender, e) =>
                {
                    if (e.Buttons == Eto.Forms.MouseButtons.Alternate && listView.SelectedItems.Count > 0)
                    {
                        var selectedItem = listView.SelectedItems[0];
                        var (tagS32Data, tagIndex) = ((S32Data, int))selectedItem.Tag;

                        var contextMenu = new ContextMenuStrip();

                        // 編輯 L5 項目
                        var editItem = new ToolStripMenuItem("編輯此 L5 項目");
                        editItem.Click += (s, ev) =>
                        {
                            if (tagIndex >= 0 && tagIndex < tagS32Data.Layer5.Count)
                            {
                                var item5 = tagS32Data.Layer5[tagIndex];
                                using (var dialog = new L5EditDialog(
                                    item5.ObjectIndex, item5.Type, item5.X, item5.Y,
                                    false, tagS32Data, _document.S32Files.Values))
                                {
                                    if (dialog.ShowDialog(this) == DialogResult.Ok)
                                    {
                                        if (dialog.S32Changed && dialog.SelectedS32 != null)
                                        {
                                            // 移動到其他 S32
                                            tagS32Data.Layer5.RemoveAt(tagIndex);
                                            tagS32Data.IsModified = true;

                                            var newItem = new Layer5Item
                                            {
                                                X = dialog.NewX,
                                                Y = dialog.NewY,
                                                ObjectIndex = (ushort)dialog.ObjectIndex,
                                                Type = dialog.L5Type
                                            };
                                            dialog.SelectedS32.Layer5.Add(newItem);
                                            dialog.SelectedS32.IsModified = true;

                                            // 從 ListView 移除
                                            listView.Items.Remove(selectedItem);
                                            countLabel.Text = $"此格數量: {listView.Items.Count}";
                                        }
                                        else
                                        {
                                            // 只修改屬性（包含座標）
                                            item5.X = dialog.NewX;
                                            item5.Y = dialog.NewY;
                                            item5.ObjectIndex = (ushort)dialog.ObjectIndex;
                                            item5.Type = dialog.L5Type;
                                            tagS32Data.Layer5[tagIndex] = item5;
                                            tagS32Data.IsModified = true;
                                            // 更新 ListView
                                            selectedItem.SubItems[3].Text = item5.X.ToString();
                                            selectedItem.SubItems[4].Text = item5.Y.ToString();
                                            selectedItem.SubItems[5].Text = item5.ObjectIndex.ToString();
                                            selectedItem.SubItems[6].Text = item5.Type.ToString();
                                        }
                                        RenderS32Map();
                                    }
                                }
                            }
                        };
                        contextMenu.Items.Add(editItem);

                        // 刪除 L5 項目
                        var deleteItem = new ToolStripMenuItem("刪除此 L5 項目");
                        deleteItem.Click += (s, ev) =>
                        {
                            if (tagIndex >= 0 && tagIndex < tagS32Data.Layer5.Count)
                            {
                                tagS32Data.Layer5.RemoveAt(tagIndex);
                                tagS32Data.IsModified = true;
                                RenderS32Map();
                                // 從 ListView 移除該項目
                                listView.Items.Remove(selectedItem);
                                countLabel.Text = $"此格數量: {listView.Items.Count}";
                            }
                        };
                        contextMenu.Items.Add(deleteItem);
                        contextMenu.Show(listView, e.Location);
                    }
                };

                // 雙擊編輯
                listView.DoubleClick += (sender, e) =>
                {
                    if (listView.SelectedItems.Count > 0)
                    {
                        var selectedItem = listView.SelectedItems[0];
                        var (tagS32Data, tagIndex) = ((S32Data, int))selectedItem.Tag;

                        if (tagIndex >= 0 && tagIndex < tagS32Data.Layer5.Count)
                        {
                            var item5 = tagS32Data.Layer5[tagIndex];
                            using (var dialog = new L5EditDialog(
                                item5.ObjectIndex, item5.Type, item5.X, item5.Y,
                                false, tagS32Data, _document.S32Files.Values))
                            {
                                if (dialog.ShowDialog(this) == DialogResult.Ok)
                                {
                                    if (dialog.S32Changed && dialog.SelectedS32 != null)
                                    {
                                        // 移動到其他 S32
                                        tagS32Data.Layer5.RemoveAt(tagIndex);
                                        tagS32Data.IsModified = true;

                                        var newItem = new Layer5Item
                                        {
                                            X = dialog.NewX,
                                            Y = dialog.NewY,
                                            ObjectIndex = (ushort)dialog.ObjectIndex,
                                            Type = dialog.L5Type
                                        };
                                        dialog.SelectedS32.Layer5.Add(newItem);
                                        dialog.SelectedS32.IsModified = true;

                                        RenderS32Map();

                                        // 關閉當前對話框並重新開啟以刷新 L5 列表
                                        if (panel.Parent?.Parent is Form parentForm)
                                        {
                                            parentForm.Close();
                                            ShowCellLayersDialog(x, y);
                                        }
                                        return;
                                    }
                                    else
                                    {
                                        // 只修改屬性（包含座標）
                                        item5.X = dialog.NewX;
                                        item5.Y = dialog.NewY;
                                        item5.ObjectIndex = (ushort)dialog.ObjectIndex;
                                        item5.Type = dialog.L5Type;
                                        tagS32Data.Layer5[tagIndex] = item5;
                                        tagS32Data.IsModified = true;
                                        // 更新 ListView
                                        selectedItem.SubItems[3].Text = item5.X.ToString();
                                        selectedItem.SubItems[4].Text = item5.Y.ToString();
                                        selectedItem.SubItems[5].Text = item5.ObjectIndex.ToString();
                                        selectedItem.SubItems[6].Text = item5.Type.ToString();
                                    }
                                    RenderS32Map();
                                }
                            }
                        }
                    }
                };

                // 先加入 Fill 的控件，再加入 Top 的控件（Dock 順序）
                panel.GetControls().Add(listView);
                panel.GetControls().Add(countLabel);
                panel.GetControls().Add(btnAddL5);
            }
            else
            {
                Label info = new Label();
                info.Text = "此格無資料";
                info.SetDock(DockStyle.Fill);
                info.SetTextAlign(ContentAlignment.MiddleCenter);
                panel.GetControls().Add(info);
                panel.GetControls().Add(btnAddL5);
            }

            return panel;
        }

        // 創建第六層面板 - 只顯示這一格用到的 Tile
        private Panel CreateLayer6Panel(int x, int y)
        {
            Panel panel = new Panel();
            panel.SetDock(DockStyle.Fill);

            // 收集這一格用到的 TileId
            var cellTileIds = new HashSet<int>();

            // Layer1 地板 (x, y) 和 (x+1, y) 如果是同一格
            int normalizedX = (x / 2) * 2;
            if (normalizedX < 128 && y < 64)
            {
                var cell1 = currentS32Data.Layer1[y, normalizedX];
                if (cell1 != null && cell1.TileId > 0)
                    cellTileIds.Add(cell1.TileId);

                if (normalizedX + 1 < 128)
                {
                    var cell2 = currentS32Data.Layer1[y, normalizedX + 1];
                    if (cell2 != null && cell2.TileId > 0)
                        cellTileIds.Add(cell2.TileId);
                }
            }

            // Layer4 物件
            foreach (var obj in currentS32Data.Layer4)
            {
                int objNormX = (obj.X / 2) * 2;
                if (objNormX == normalizedX && obj.Y == y)
                {
                    cellTileIds.Add(obj.TileId);
                }
            }

            // Layer2 項目
            foreach (var item2 in currentS32Data.Layer2)
            {
                int item2NormX = (item2.X / 2) * 2;
                if (item2NormX == normalizedX && item2.Y == y)
                {
                    cellTileIds.Add(item2.TileId);
                }
            }

            if (cellTileIds.Count > 0)
            {
                Label countLabel = new Label();
                countLabel.Text = $"此格使用 {cellTileIds.Count} 種 Tile";
                countLabel.SetDock(DockStyle.Top);
                countLabel.Height = 20;
                countLabel.SetTextAlign(ContentAlignment.MiddleCenter);
                countLabel.BackgroundColor = Colors.WhiteSmoke;

                ListView listView = new ListView();
                listView.SetDock(DockStyle.Fill);
                listView.View = View.Details;
                listView.FullRowSelect = true;
                listView.GridLines = true;

                listView.Columns.Add("TileId", -2);
                listView.Columns.Add("十六進位", -2);
                listView.Columns.Add("來源", -2);

                foreach (var tileId in cellTileIds.OrderBy(t => t))
                {
                    // 判斷來源
                    var sources = new List<string>();

                    // 檢查 Layer1
                    var cell1 = currentS32Data.Layer1[y, normalizedX];
                    if (cell1 != null && cell1.TileId == tileId) sources.Add("L1左");
                    if (normalizedX + 1 < 128)
                    {
                        var cell2 = currentS32Data.Layer1[y, normalizedX + 1];
                        if (cell2 != null && cell2.TileId == tileId) sources.Add("L1右");
                    }

                    // 檢查 Layer4
                    if (currentS32Data.Layer4.Any(o => (o.X / 2) * 2 == normalizedX && o.Y == y && o.TileId == tileId))
                        sources.Add("L4");

                    // 檢查 Layer2
                    if (currentS32Data.Layer2.Any(i => (i.X / 2) * 2 == normalizedX && i.Y == y && i.TileId == tileId))
                        sources.Add("L2");

                    var lvItem = new ListViewItem(tileId.ToString());
                    lvItem.SubItems.Add($"0x{tileId:X4}");
                    lvItem.SubItems.Add(string.Join(", ", sources));
                    listView.Items.Add(lvItem);
                }

                listView.AutoResizeColumns(ColumnHeaderAutoResizeStyle.HeaderSize);

                panel.GetControls().Add(listView);
                panel.GetControls().Add(countLabel);
            }
            else
            {
                Label info = new Label();
                info.Text = "此格無 Tile 資料";
                info.SetDock(DockStyle.Fill);
                info.SetTextAlign(ContentAlignment.MiddleCenter);
                panel.GetControls().Add(info);
            }

            return panel;
        }

        // 創建第七層面板 - 傳送點、入口點
        private Panel CreateLayer7Panel(int x, int y)
        {
            Panel panel = new Panel();
            panel.BorderStyle = BorderStyle.FixedSingle;
            panel.SetDock(DockStyle.Fill);

            Label title = new Label();
            title.Text = "第7層 (傳送點)";
            title.Font = new Font("Arial", 10, FontStyle.Bold);
            title.SetDock(DockStyle.Top);
            title.Height = 25;
            title.SetTextAlign(ContentAlignment.MiddleCenter);
            panel.GetControls().Add(title);

            if (currentS32Data.Layer7.Count > 0)
            {
                Label countLabel = new Label();
                countLabel.Text = $"數量: {currentS32Data.Layer7.Count}";
                countLabel.SetDock(DockStyle.Top);
                countLabel.Height = 20;
                countLabel.SetTextAlign(ContentAlignment.MiddleCenter);
                panel.GetControls().Add(countLabel);

                ListView listView = new ListView();
                listView.SetDock(DockStyle.Fill);
                listView.View = View.Details;
                listView.FullRowSelect = true;
                listView.GridLines = true;
                listView.Font = new Font("Consolas", 9, FontStyle.None);

                listView.Columns.Add("名稱", 80);
                listView.Columns.Add("X", 30);
                listView.Columns.Add("Y", 30);
                listView.Columns.Add("目標地圖", 60);
                listView.Columns.Add("傳送點ID", 60);

                for (int i = 0; i < currentS32Data.Layer7.Count; i++)
                {
                    var item7 = currentS32Data.Layer7[i];
                    var lvItem = new ListViewItem(item7.Name);
                    lvItem.SubItems.Add(item7.X.ToString());
                    lvItem.SubItems.Add(item7.Y.ToString());
                    lvItem.SubItems.Add(item7.TargetMapId.ToString());
                    lvItem.SubItems.Add(item7.PortalId.ToString());
                    listView.Items.Add(lvItem);
                }

                panel.GetControls().Add(listView);
            }
            else
            {
                Label info = new Label();
                info.Text = "無資料";
                info.SetDock(DockStyle.Fill);
                info.SetTextAlign(ContentAlignment.MiddleCenter);
                panel.GetControls().Add(info);
            }

            return panel;
        }

        // 創建第八層面板 - 特效、裝飾品（只顯示與當前格子相關的項目）
        private Panel CreateLayer8Panel(int x, int y)
        {
            Panel panel = new Panel();
            panel.BorderStyle = BorderStyle.FixedSingle;
            panel.SetDock(DockStyle.Fill);

            // 計算當前格子的全域座標
            int normX = (x / 2) * 2;
            int globalLayer1X = currentS32Data.SegInfo.nLinBeginX * 2 + normX;
            int globalLayer1Y = currentS32Data.SegInfo.nLinBeginY + y;

            // 收集與當前格子相關的 Layer8 項目（搜尋所有 S32）
            var cellLayer8Items = new List<(Layer8Item item, S32Data s32, int localX, int localY)>();

            foreach (var s32Data in _document.S32Files.Values)
            {
                if (s32Data.Layer8.Count == 0) continue;
                int s32StartX = s32Data.SegInfo.nLinBeginX * 2;
                int s32StartY = s32Data.SegInfo.nLinBeginY;

                foreach (var item8 in s32Data.Layer8)
                {
                    int itemGlobalX = s32StartX + item8.X;
                    int itemGlobalY = s32StartY + item8.Y;

                    // 檢查是否在當前格子範圍內（左右兩個三角都算）
                    if ((itemGlobalX == globalLayer1X || itemGlobalX == globalLayer1X + 1) && itemGlobalY == globalLayer1Y)
                    {
                        cellLayer8Items.Add((item8, s32Data, item8.X, item8.Y));
                    }
                }
            }

            // 標題
            Label title = new Label();
            title.Text = $"第8層 (特效) - 格子座標 ({x}, {y})";
            title.Font = new Font("Arial", 10, FontStyle.Bold);
            title.SetDock(DockStyle.Top);
            title.Height = 25;
            title.SetTextAlign(ContentAlignment.MiddleCenter);
            panel.GetControls().Add(title);

            if (cellLayer8Items.Count > 0)
            {
                // 數量標籤
                Label countLabel = new Label();
                countLabel.Text = $"此格子共 {cellLayer8Items.Count} 個特效";
                countLabel.SetDock(DockStyle.Top);
                countLabel.Height = 20;
                countLabel.SetTextAlign(ContentAlignment.MiddleCenter);
                countLabel.TextColor = Colors.Blue;
                panel.GetControls().Add(countLabel);

                // 資料表格
                ListView listView = new ListView();
                listView.SetDock(DockStyle.Fill);
                listView.View = View.Details;
                listView.FullRowSelect = true;
                listView.GridLines = true;
                listView.Font = new Font("Consolas", 9, FontStyle.None);

                listView.Columns.Add("SprId", 70);
                listView.Columns.Add("X", 50);
                listView.Columns.Add("Y", 50);
                listView.Columns.Add("ExtendedData", 100);
                listView.Columns.Add("S32 檔案", 200);

                foreach (var (item8, s32, localX, localY) in cellLayer8Items)
                {
                    var lvItem = new ListViewItem(item8.SprId.ToString());
                    lvItem.SubItems.Add(localX.ToString());
                    lvItem.SubItems.Add(localY.ToString());
                    lvItem.SubItems.Add($"0x{item8.ExtendedData:X8}");
                    lvItem.SubItems.Add(System.IO.Path.GetFileName(s32.FilePath));
                    lvItem.Tag = (item8, s32);
                    listView.Items.Add(lvItem);
                }

                panel.GetControls().Add(listView);
            }
            else
            {
                Label info = new Label();
                info.Text = "此格子無 Layer8 資料";
                info.SetDock(DockStyle.Fill);
                info.SetTextAlign(ContentAlignment.MiddleCenter);
                info.TextColor = Colors.Gray;
                panel.GetControls().Add(info);
            }

            return panel;
        }

        // Tile 雙擊事件 - 顯示預覽+詳細資料
        private void lvTiles_DoubleClick(object sender, EventArgs e)
        {
            if (lvTiles.SelectedItems.Count == 0)
                return;

            var selectedItem = lvTiles.SelectedItems[0];
            var tileInfo = selectedItem.Tag as TileInfo;
            if (tileInfo == null)
                return;

            // 顯示詳細資料視窗（含預覽）
            ShowTileInfoWithPreview(tileInfo);
        }

        // IconTextListControl 事件包裝器
        private void lvTiles_MouseUp_Eto(object sender, Eto.Forms.MouseEventArgs e)
        {
            lvTiles_MouseUp(sender, e);
        }

        private void lvMaterials_DoubleClick_Eto(object sender, EventArgs e)
        {
            // 使用選取項目直接處理（IconTextListControl 的 ItemDoubleClick 已經確認有選取項目）
            if (lvMaterials.SelectedItem?.Tag is string filePath)
            {
                try
                {
                    var library = new L1MapViewer.Helper.MaterialLibrary();
                    var material = library.LoadMaterial(filePath);
                    if (material != null)
                    {
                        StartMaterialPasteMode(material, filePath);
                    }
                    else
                    {
                        WinFormsMessageBox.Show("無法載入素材", "錯誤", MessageBoxButtons.OK, MessageBoxIcon.Error);
                    }
                }
                catch (Exception ex)
                {
                    WinFormsMessageBox.Show($"載入素材失敗: {ex.Message}", "錯誤", MessageBoxButtons.OK, MessageBoxIcon.Error);
                }
            }
        }

        private void lvMaterials_MouseUp_Eto(object sender, Eto.Forms.MouseEventArgs e)
        {
            lvMaterials_MouseUp(sender, e);
        }

        private void lvGroupThumbnails_MouseClick_Eto(object sender, Eto.Forms.MouseEventArgs e)
        {
            lvGroupThumbnails_MouseClick(sender, e);
        }

        private void lvGroupThumbnails_MouseUp_Eto(object sender, Eto.Forms.MouseEventArgs e)
        {
            lvGroupThumbnails_MouseUp(sender, e);
        }

        private void lvGroupThumbnails_SelectionChanged(object sender, EventArgs e)
        {
            lvGroupThumbnails_SelectedIndexChanged(sender, e);
        }

        // 顯示 Tile 預覽+詳細資料整合視窗
        private void ShowTileInfoWithPreview(TileInfo tileInfo)
        {
            // 收集所有使用此 TileId 的位置
            List<(int globalX, int globalY, string layer, int groupId, S32Data s32, int l4X, int l4Y)> locations =
                new List<(int, int, string, int, S32Data, int, int)>();

            foreach (var s32Data in _document.S32Files.Values)
            {
                int segStartX = s32Data.SegInfo.nLinBeginX;
                int segStartY = s32Data.SegInfo.nLinBeginY;

                // Layer1
                for (int y = 0; y < 64; y++)
                {
                    for (int x = 0; x < 128; x++)
                    {
                        var cell = s32Data.Layer1[y, x];
                        if (cell != null && cell.TileId == tileInfo.TileId)
                        {
                            int layer3X = x / 2;
                            int globalX = segStartX + layer3X;
                            int globalY = segStartY + y;
                            locations.Add((globalX, globalY, "L1", 0, s32Data, -1, -1));
                        }
                    }
                }

                // Layer4
                foreach (var obj in s32Data.Layer4)
                {
                    if (obj.TileId == tileInfo.TileId)
                    {
                        int layer3X = obj.X / 2;
                        int globalX = segStartX + layer3X;
                        int globalY = segStartY + obj.Y;
                        locations.Add((globalX, globalY, "L4", obj.GroupId, s32Data, obj.X, obj.Y));
                    }
                }
            }

            // 建立視窗
            Form infoForm = new Form
            {
                Text = $"Tile {tileInfo.TileId} 詳細資訊",
                Size = new Size(680, 480),
                StartPosition = FormStartPosition.CenterParent,
                FormBorderStyle = FormBorderStyle.Sizable,
                MinimizeBox = false
            };

            // 左側預覽區
            Panel previewPanel = new Panel
            {
                Location = new Point(10, 10),
                Size = new Size(150, 180),
                BorderStyle = BorderStyle.FixedSingle
            };

            Bitmap enlargedTile = LoadTileEnlarged(tileInfo.TileId, tileInfo.IndexId, 144);
            PictureBox pbPreview = new PictureBox
            {
                Image = enlargedTile,
                SizeMode = PictureBoxSizeMode.Zoom,
                Dock = DockStyle.Fill,
                BackColor = Colors.Black
            };
            previewPanel.GetControls().Add(pbPreview);

            // 基本資訊
            Label lblBasicInfo = new Label
            {
                Text = $"TileId: {tileInfo.TileId}\nIndexId: {tileInfo.IndexId}\n使用次數: {tileInfo.UsageCount}\n總共 {locations.Count} 個位置",
                Location = new Point(10, 195),
                Size = new Size(150, 80),
                Font = new Font(SystemFonts.Default().Family, 9, FontStyle.None)
            };

            // 右側區域 - 跳轉座標
            Label lblJump = new Label
            {
                Text = "跳轉座標:",
                Location = new Point(170, 10),
                Size = new Size(70, 23),
                TextAlign = ContentAlignment.MiddleLeft
            };

            TextBox txtJumpCoord = new TextBox
            {
                Location = new Point(240, 10),
                Size = new Size(120, 23),
                PlaceholderText = "輸入 X,Y"
            };

            Button btnJump = new Button
            {
                Text = "跳轉",
                Location = new Point(365, 9),
                Size = new Size(50, 25)
            };

            // 座標列表
            ListView lvLocations = new ListView
            {
                Location = new Point(170, 40),
                Size = new Size(480, 340),
                View = View.Details,
                FullRowSelect = true,
                GridLines = true,
                Anchor = AnchorStyles.Top | AnchorStyles.Bottom | AnchorStyles.Left | AnchorStyles.Right
            };
            lvLocations.Columns.Add("X", 55);
            lvLocations.Columns.Add("Y", 55);
            lvLocations.Columns.Add("圖層", 40);
            lvLocations.Columns.Add("GroupId", 55);
            lvLocations.Columns.Add("L4座標", 70);
            lvLocations.Columns.Add("S32檔案", 180);

            // 右鍵選單 - 複製整行
            ContextMenuStrip lvContextMenu = new ContextMenuStrip();
            ToolStripMenuItem copyRowItem = new ToolStripMenuItem("複製整行");
            copyRowItem.Click += (s, ev) =>
            {
                if (lvLocations.SelectedItems.Count > 0)
                {
                    var item = lvLocations.SelectedItems[0];
                    string rowText = $"{item.SubItems[0].Text},{item.SubItems[1].Text},{item.SubItems[2].Text},{item.SubItems[3].Text},{item.SubItems[4].Text},{item.SubItems[5].Text}";
                    ClipboardHelper.SetText(rowText);
                    this.toolStripStatusLabel1.Text = "已複製整行";
                }
            };
            lvContextMenu.Items.Add(copyRowItem);
            lvLocations.ContextMenuStrip = lvContextMenu;

            // 填充列表
            foreach (var loc in locations.OrderBy(l => l.globalX).ThenBy(l => l.globalY))
            {
                string s32FileName = Path.GetFileName(loc.s32.FilePath);
                var item = new ListViewItem(loc.globalX.ToString());
                item.SubItems.Add(loc.globalY.ToString());
                item.SubItems.Add(loc.layer);
                item.SubItems.Add(loc.groupId > 0 ? loc.groupId.ToString() : "-");
                item.SubItems.Add(loc.l4X >= 0 ? $"({loc.l4X},{loc.l4Y})" : "-");
                item.SubItems.Add(s32FileName);
                item.Tag = loc;
                lvLocations.Items.Add(item);
            }

            // 底部按鈕
            Button btnCopyAll = new Button
            {
                Text = "複製全部座標",
                Location = new Point(170, 390),
                Size = new Size(100, 28),
                Anchor = AnchorStyles.Bottom | AnchorStyles.Left
            };

            Button btnCopySelected = new Button
            {
                Text = "複製選中",
                Location = new Point(275, 390),
                Size = new Size(80, 28),
                Anchor = AnchorStyles.Bottom | AnchorStyles.Left
            };

            Button btnClose = new Button
            {
                Text = "關閉",
                Location = new Point(570, 390),
                Size = new Size(80, 28),
                Anchor = AnchorStyles.Bottom | AnchorStyles.Right
            };

            // 事件處理
            btnJump.Click += (s, ev) =>
            {
                string input = txtJumpCoord.Text.Trim();
                if (TryParseCoordinate(input, out int x, out int y))
                {
                    JumpToGameCoordinate(x, y);
                    this.toolStripStatusLabel1.Text = $"已跳轉到座標 ({x}, {y})";
                }
                else
                {
                    WinFormsMessageBox.Show("請輸入正確的座標格式，例如: 32800,32700", "格式錯誤", MessageBoxButtons.OK, MessageBoxIcon.Warning);
                }
            };

            txtJumpCoord.KeyDown += (s, ev) =>
            {
                if (ev.GetKeyCode() == Keys.Enter)
                {
                    btnJump.PerformClick();
                    ev.Handled = true;
                    ev.SetSuppressKeyPress(true);
                }
            };

            // 單擊列表項目跳轉並高亮
            lvLocations.SelectedIndexChanged += (s, ev) =>
            {
                if (lvLocations.SelectedItems.Count > 0)
                {
                    var loc = ((int globalX, int globalY, string layer, int groupId, S32Data s32, int l4X, int l4Y))lvLocations.SelectedItems[0].Tag;
                    JumpToGameCoordinate(loc.globalX, loc.globalY);
                    string l4Info = loc.l4X >= 0 ? $" L4座標:({loc.l4X},{loc.l4Y})" : "";
                    this.toolStripStatusLabel1.Text = $"已跳轉到座標 ({loc.globalX}, {loc.globalY}) - {loc.layer}" +
                        (loc.groupId > 0 ? $" GroupId:{loc.groupId}" : "") + l4Info;
                }
            };

            btnCopyAll.Click += (s, ev) =>
            {
                var coords = locations.Select(l => $"{l.globalX},{l.globalY}");
                string text = string.Join("\n", coords);
                ClipboardHelper.SetText(text);
                WinFormsMessageBox.Show($"已複製 {locations.Count} 個座標到剪貼簿", "複製成功", MessageBoxButtons.OK, MessageBoxIcon.Information);
            };

            btnCopySelected.Click += (s, ev) =>
            {
                if (lvLocations.SelectedItems.Count == 0)
                {
                    WinFormsMessageBox.Show("請先選取要複製的項目", "提示", MessageBoxButtons.OK, MessageBoxIcon.Information);
                    return;
                }
                var selectedRows = new List<string>();
                foreach (ListViewItem item in lvLocations.SelectedItems)
                {
                    string rowText = $"{item.SubItems[0].Text},{item.SubItems[1].Text},{item.SubItems[2].Text},{item.SubItems[3].Text},{item.SubItems[4].Text},{item.SubItems[5].Text}";
                    selectedRows.Add(rowText);
                }
                ClipboardHelper.SetText(string.Join("\n", selectedRows));
                WinFormsMessageBox.Show($"已複製 {selectedRows.Count} 筆資料到剪貼簿", "複製成功", MessageBoxButtons.OK, MessageBoxIcon.Information);
            };

            btnClose.Click += (s, ev) => infoForm.Close();

            infoForm.FormClosed += (s, ev) =>
            {
                enlargedTile?.Dispose();
            };

            // 加入控制項
            infoForm.GetControls().Add(previewPanel);
            infoForm.GetControls().Add(lblBasicInfo);
            infoForm.GetControls().Add(lblJump);
            infoForm.GetControls().Add(txtJumpCoord);
            infoForm.GetControls().Add(btnJump);
            infoForm.GetControls().Add(lvLocations);
            infoForm.GetControls().Add(btnCopyAll);
            infoForm.GetControls().Add(btnCopySelected);
            infoForm.GetControls().Add(btnClose);

            // 使用 Show 而非 ShowDialog，讓主視窗可以即時更新
            infoForm.Show(this);
        }

        // Tile 右鍵選單
        private void lvTiles_MouseUp(object sender, MouseEventArgs e)
        {
            if (e.Buttons != Eto.Forms.MouseButtons.Alternate)
                return;

            if (lvTiles.SelectedItems.Count == 0)
                return;

            var selectedItem = lvTiles.SelectedItems[0];
            var tileInfo = selectedItem.Tag as TileInfo;
            if (tileInfo == null)
                return;

            // 計算使用此 TileId 的各圖層數量
            int layer1Count = 0;
            int layer2Count = 0;
            int layer4Count = 0;
            foreach (var s32Data in _document.S32Files.Values)
            {
                // Layer1
                if (s32Data.Layer1 != null)
                {
                    for (int y = 0; y < 64; y++)
                    {
                        for (int x = 0; x < 128; x++)
                        {
                            var cell = s32Data.Layer1[y, x];
                            if (cell != null && cell.TileId == tileInfo.TileId)
                                layer1Count++;
                        }
                    }
                }
                // Layer2
                layer2Count += s32Data.Layer2.Count(o => o.TileId == tileInfo.TileId);
                // Layer4
                layer4Count += s32Data.Layer4.Count(o => o.TileId == tileInfo.TileId);
            }
            int totalCount = layer1Count + layer2Count + layer4Count;

            // 建立右鍵選單
            ContextMenuStrip menu = new ContextMenuStrip();

            // 刪除所有使用此 TileId 的 Layer4 物件
            ToolStripMenuItem deleteLayer4Item = new ToolStripMenuItem($"刪除所有 Layer4 物件 ({layer4Count} 個)");
            deleteLayer4Item.Enabled = layer4Count > 0;
            deleteLayer4Item.Click += (s, ev) =>
            {
                DeleteAllLayer4ByTileId(tileInfo.TileId);
            };

            // 刪除所有使用此 TileId 的引用（Layer1 + Layer2 + Layer4）
            ToolStripMenuItem deleteAllItem = new ToolStripMenuItem($"刪除所有引用 (L1:{layer1Count} L2:{layer2Count} L4:{layer4Count})");
            deleteAllItem.Enabled = totalCount > 0;
            deleteAllItem.Click += (s, ev) =>
            {
                DeleteAllReferencesByTileId(tileInfo.TileId, layer1Count, layer2Count, layer4Count);
            };

            // 查看 Tile 詳細資訊
            ToolStripMenuItem infoItem = new ToolStripMenuItem("查看詳細資訊");
            infoItem.Click += (s, ev) =>
            {
                ShowTileInfoWithPreview(tileInfo);
            };

            // 匯出選中的 Tile
            ToolStripMenuItem exportSelectedItem = new ToolStripMenuItem("匯出選中的 Tile 圖片");
            exportSelectedItem.Click += (s, ev) =>
            {
                var selectedTiles = new List<TileInfo>();
                foreach (IconTextListItem item in lvTiles.SelectedItems)
                {
                    if (item.Tag is TileInfo ti)
                        selectedTiles.Add(ti);
                }
                if (selectedTiles.Count > 0)
                    ExportTilesToZip(selectedTiles);
            };

            // 匯出全部 Tile
            ToolStripMenuItem exportAllItem = new ToolStripMenuItem($"匯出全部 Tile ({lvTiles.Items.Count} 個)");
            exportAllItem.Click += (s, ev) =>
            {
                var allTiles = new List<TileInfo>();
                foreach (IconTextListItem item in lvTiles.Items)
                {
                    if (item.Tag is TileInfo ti)
                        allTiles.Add(ti);
                }
                if (allTiles.Count > 0)
                    ExportTilesToZip(allTiles);
            };

            // 重新編號 TileId（支援多選）
            int selectedCount = lvTiles.SelectedItems.Count;
            ToolStripMenuItem renumberItem = new ToolStripMenuItem($"重新編號 TileId ({selectedCount} 個)");
            renumberItem.Enabled = selectedCount > 0;
            renumberItem.Click += (s, ev) =>
            {
                var selectedTiles = new List<TileInfo>();
                foreach (IconTextListItem item in lvTiles.SelectedItems)
                {
                    if (item.Tag is TileInfo ti)
                        selectedTiles.Add(ti);
                }
                if (selectedTiles.Count > 0)
                    RenumberTileIds(selectedTiles);
            };

            menu.Items.Add(infoItem);
            menu.Items.Add(new ToolStripSeparator());
            menu.Items.Add(renumberItem);
            menu.Items.Add(deleteLayer4Item);
            menu.Items.Add(deleteAllItem);
            menu.Items.Add(new ToolStripSeparator());
            menu.Items.Add(exportSelectedItem);
            menu.Items.Add(exportAllItem);

            menu.Show(lvTiles, e.Location);
        }

        // 匯出 Tile 到 ZIP 檔案
        private void ExportTilesToZip(List<TileInfo> tiles)
        {
            if (tiles.Count == 0)
            {
                WinFormsMessageBox.Show("沒有要匯出的 Tile", "提示", MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            // 檢查是否有 R 版 Tile
            var distinctTileIds = tiles.Select(t => t.TileId).Distinct().ToList();
            int remasterCount = distinctTileIds.Count(id => TileProvider.Instance.IsRemaster(id));
            bool hasRemasterTiles = remasterCount > 0;

            // 詢問匯出選項
            using (var optionForm = new Form())
            {
                optionForm.Text = "匯出選項";
                optionForm.ClientSize = new Size(300, hasRemasterTiles ? 180 : 150);
                optionForm.SetFormBorderStyle(FormBorderStyle.FixedDialog);
                optionForm.SetStartPosition(FormStartPosition.CenterParent);
                optionForm.SetMaximizeBox(false);
                optionForm.SetMinimizeBox(false);

                var chkExportTil = new CheckBox { Text = "匯出 .til 原始檔案", Size = new Size(260, 24), Checked = true };
                chkExportTil.SetLocation(new Point(20, 15));
                var chkExportPng = new CheckBox { Text = "匯出 .png 預覽圖片", Size = new Size(260, 24), Checked = false };
                chkExportPng.SetLocation(new Point(20, 45));
                var chkDownscale = new CheckBox { Text = $"R版縮小至 24x24 ({remasterCount} 個)", Size = new Size(260, 24), Checked = false, Enabled = hasRemasterTiles };
                chkDownscale.SetLocation(new Point(20, 75));

                int infoY = hasRemasterTiles ? 105 : 75;
                int btnY = hasRemasterTiles ? 140 : 110;
                var lblInfo = new Label { Text = $"共 {distinctTileIds.Count} 個 til 檔案", Size = new Size(260, 20), ForeColor = Colors.Gray };
                lblInfo.SetLocation(new Point(20, infoY));

                var btnOK = new Button { Text = "匯出", Size = new Size(80, 28), DialogResult = DialogResult.Ok };
                btnOK.SetLocation(new Point(100, btnY));
                var btnCancel = new Button { Text = "取消", Size = new Size(80, 28), DialogResult = DialogResult.Cancel };
                btnCancel.SetLocation(new Point(190, btnY));

                optionForm.GetControls().Add(chkExportTil);
                optionForm.GetControls().Add(chkExportPng);
                optionForm.GetControls().Add(chkDownscale);
                optionForm.GetControls().Add(lblInfo);
                optionForm.GetControls().Add(btnOK);
                optionForm.GetControls().Add(btnCancel);
                optionForm.AcceptButton = btnOK;
                optionForm.CancelButton = btnCancel;

                if (optionForm.ShowDialog(this) != DialogResult.Ok)
                    return;

                if (chkExportTil.Checked != true && chkExportPng.Checked != true)
                {
                    WinFormsMessageBox.Show("請至少選擇一種匯出格式", "提示", MessageBoxButtons.OK, MessageBoxIcon.Warning);
                    return;
                }

                bool exportTil = chkExportTil.Checked == true;
                bool exportPng = chkExportPng.Checked == true;
                bool downscale = chkDownscale.Checked == true;

                using (var saveDialog = new SaveFileDialog())
                {
                    saveDialog.Filter = "ZIP 檔案|*.zip";
                    saveDialog.FileName = $"Tiles_Export_{DateTime.Now:yyyyMMdd_HHmmss}.zip";
                    saveDialog.Title = "匯出 Tile";

                    if (saveDialog.ShowDialog(this) != DialogResult.Ok)
                        return;

                    try
                    {
                        // 按 TileId 分組
                        var tilesByNumber = tiles.GroupBy(t => t.TileId).OrderBy(g => g.Key).ToList();

                        using (var zipStream = new FileStream(saveDialog.FileName, FileMode.Create))
                        using (var archive = new System.IO.Compression.ZipArchive(zipStream, System.IO.Compression.ZipArchiveMode.Create))
                        {
                            int tilExportedCount = 0;
                            int pngExportedCount = 0;
                            int errorCount = 0;

                            foreach (var group in tilesByNumber)
                            {
                                int tileId = group.Key;

                                try
                                {
                                    // 載入 til 檔案
                                    string key = $"{tileId}.til";
                                    byte[] data = L1PakReader.UnPack("Tile", key);
                                    if (data == null)
                                    {
                                        errorCount++;
                                        continue;
                                    }

                                    // 如果需要縮小且是 R 版
                                    byte[] exportData = data;
                                    if (downscale && L1Til.IsRemaster(data))
                                    {
                                        exportData = L1Til.DownscaleTil(data);
                                    }

                                    // 匯出 .til 原始檔案
                                    if (exportTil)
                                    {
                                        string tilEntryName = $"{tileId}.til";
                                        var tilEntry = archive.CreateEntry(tilEntryName, System.IO.Compression.CompressionLevel.Optimal);
                                        using (var entryStream = tilEntry.Open())
                                        {
                                            entryStream.Write(exportData, 0, exportData.Length);
                                        }
                                        tilExportedCount++;
                                    }

                                    // 匯出 .png 預覽圖片
                                    if (exportPng)
                                    {
                                        var tilArray = L1Til.Parse(exportData);
                                        string folderName = $"preview/til_{tileId:D6}";

                                        foreach (var tile in group)
                                        {
                                            if (tile.IndexId >= tilArray.Count)
                                            {
                                                errorCount++;
                                                continue;
                                            }

                                            byte[] tilData = tilArray[tile.IndexId];
                                            // 使用既有的 RenderTileEnlarged 方法來正確渲染 2.5D 格式
                                            using (var bitmap = RenderTileEnlarged(tilData, tileId, 48))
                                            {
                                                if (bitmap != null)
                                                {
                                                    string entryName = $"{folderName}/index_{tile.IndexId:D3}.png";
                                                    var entry = archive.CreateEntry(entryName, System.IO.Compression.CompressionLevel.Optimal);

                                                    using (var entryStream = entry.Open())
                                                    {
                                                        bitmap.Save(entryStream, ImageFormat.Png);
                                                    }
                                                    pngExportedCount++;
                                                }
                                                else
                                                {
                                                    errorCount++;
                                                }
                                            }
                                        }
                                    }
                                }
                                catch
                                {
                                    errorCount++;
                                }
                            }

                            var resultParts = new List<string>();
                            if (exportTil) resultParts.Add($".til 檔案: {tilExportedCount} 個");
                            if (exportPng) resultParts.Add($".png 圖片: {pngExportedCount} 個");
                            if (errorCount > 0) resultParts.Add($"失敗: {errorCount} 個");

                            // 儲存結果資訊，等關閉檔案後再顯示
                            string resultMessage = $"匯出完成！\n\n{string.Join("\n", resultParts)}\n\n儲存至: {saveDialog.FileName}";
                            string savedFileName = System.IO.Path.GetFileName(saveDialog.FileName);

                            // 先關閉 ZIP 檔案
                            archive.Dispose();
                            zipStream.Close();

                            // 再顯示訊息
                            WinFormsMessageBox.Show(resultMessage, "匯出結果", MessageBoxButtons.OK, MessageBoxIcon.Information);
                            this.toolStripStatusLabel1.Text = $"已匯出 Tile 到 {savedFileName}";
                        }
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine($"[Export] Error: {ex}");
                        WinFormsMessageBox.Show($"匯出失敗: {ex.Message}\n\n{ex.StackTrace}", "錯誤", MessageBoxButtons.OK, MessageBoxIcon.Error);
                    }
                }
            }
        }

        // 重新編號 TileId
        private void RenumberTileIds(List<TileInfo> tiles)
        {
            if (tiles.Count == 0) return;

            // 按原始 TileId 排序
            var sortedTiles = tiles.OrderBy(t => t.TileId).ToList();
            var oldTileIds = sortedTiles.Select(t => t.TileId).Distinct().ToList();

            // 顯示輸入對話框
            using (var inputForm = new Form())
            {
                inputForm.Text = "重新編號 TileId";
                inputForm.ClientSize = new Size(350, 180);
                inputForm.SetFormBorderStyle(FormBorderStyle.FixedDialog);
                inputForm.SetStartPosition(FormStartPosition.CenterParent);
                inputForm.SetMaximizeBox(false);
                inputForm.SetMinimizeBox(false);

                var lblInfo = new Label
                {
                    Text = $"選中 {oldTileIds.Count} 個 TileId:\n{string.Join(", ", oldTileIds.Take(10))}{(oldTileIds.Count > 10 ? " ..." : "")}",
                    Size = new Size(320, 40)
                };
                lblInfo.SetLocation(new Point(15, 15));

                var lblStart = new Label { Text = "起始編號:", Size = new Size(80, 20) };
                lblStart.SetLocation(new Point(15, 65));
                var txtStart = new TextBox { Text = oldTileIds.Min().ToString(), Size = new Size(100, 24) };
                txtStart.SetLocation(new Point(100, 62));

                var lblPreview = new Label
                {
                    Text = "",
                    Size = new Size(320, 40),
                    ForeColor = Colors.Gray
                };
                lblPreview.SetLocation(new Point(15, 95));

                // 預覽重編結果
                Action updatePreview = () =>
                {
                    if (int.TryParse(txtStart.Text, out int startId) && startId > 0)
                    {
                        var preview = new List<string>();
                        for (int i = 0; i < Math.Min(oldTileIds.Count, 5); i++)
                        {
                            preview.Add($"{oldTileIds[i]} → {startId + i}");
                        }
                        if (oldTileIds.Count > 5)
                            preview.Add("...");
                        lblPreview.Text = "預覽: " + string.Join(", ", preview);
                    }
                    else
                    {
                        lblPreview.Text = "請輸入有效的起始編號 (> 0)";
                    }
                };

                txtStart.TextChanged += (s, ev) => updatePreview();
                updatePreview();

                var btnOK = new Button { Text = "確定", Size = new Size(80, 28), DialogResult = DialogResult.Ok };
                btnOK.SetLocation(new Point(160, 140));
                var btnCancel = new Button { Text = "取消", Size = new Size(80, 28), DialogResult = DialogResult.Cancel };
                btnCancel.SetLocation(new Point(250, 140));

                inputForm.GetControls().Add(lblInfo);
                inputForm.GetControls().Add(lblStart);
                inputForm.GetControls().Add(txtStart);
                inputForm.GetControls().Add(lblPreview);
                inputForm.GetControls().Add(btnOK);
                inputForm.GetControls().Add(btnCancel);
                inputForm.AcceptButton = btnOK;
                inputForm.CancelButton = btnCancel;

                if (inputForm.ShowDialog(this) != DialogResult.Ok)
                    return;

                if (!int.TryParse(txtStart.Text, out int startTileId) || startTileId <= 0)
                {
                    WinFormsMessageBox.Show("請輸入有效的起始編號 (> 0)", "錯誤", MessageBoxButtons.OK, MessageBoxIcon.Error);
                    return;
                }

                // 建立 oldTileId -> newTileId 的對應表
                var tileIdMapping = new Dictionary<int, int>();
                for (int i = 0; i < oldTileIds.Count; i++)
                {
                    tileIdMapping[oldTileIds[i]] = startTileId + i;
                }

                // 檢查是否有衝突（新編號與現有未選中的 TileId 重複）
                var allCurrentTileIds = new HashSet<int>();
                foreach (var s32Data in _document.S32Files.Values)
                {
                    foreach (var cell in s32Data.Layer1)
                    {
                        if (cell != null && cell.TileId > 0)
                            allCurrentTileIds.Add(cell.TileId);
                    }
                    foreach (var obj in s32Data.Layer4)
                    {
                        if (obj.TileId > 0)
                            allCurrentTileIds.Add(obj.TileId);
                    }
                }

                // 移除要重編的 TileId
                foreach (var oldId in oldTileIds)
                {
                    allCurrentTileIds.Remove(oldId);
                }

                // 檢查新編號是否與現有編號衝突
                var conflicts = new List<int>();
                foreach (var newId in tileIdMapping.Values)
                {
                    if (allCurrentTileIds.Contains(newId))
                        conflicts.Add(newId);
                }

                if (conflicts.Count > 0)
                {
                    var result = WinFormsMessageBox.Show(
                        $"新的 TileId 與現有 TileId 有衝突:\n{string.Join(", ", conflicts.Take(10))}{(conflicts.Count > 10 ? " ..." : "")}\n\n是否繼續？（會合併這些 TileId）",
                        "警告",
                        MessageBoxButtons.YesNo,
                        MessageBoxIcon.Warning);
                    if (result != DialogResult.Yes)
                        return;
                }

                // 檢查是否要同時更新 Tile.idx/Tile.pak
                bool updateTilePak = false;
                if (!string.IsNullOrEmpty(Share.LineagePath))
                {
                    var pakResult = WinFormsMessageBox.Show(
                        $"是否要同時將 til 檔案以新編號寫入 Tile.idx/Tile.pak？\n\n" +
                        $"選擇「是」：讀取原始 til 並以新編號附加到 pak\n" +
                        $"選擇「否」：僅更新 S32 中的引用（需手動處理 til 檔案）",
                        "更新 Tile.pak",
                        MessageBoxButtons.YesNoCancel,
                        MessageBoxIcon.Question);
                    if (pakResult == DialogResult.Cancel)
                        return;
                    updateTilePak = (pakResult == DialogResult.Yes);
                }

                // 確認執行
                string confirmMsg = $"確定要重新編號嗎？\n\n" +
                    $"這將更新所有 S32 檔案中的 Layer1、Layer2 和 Layer4 引用。\n" +
                    $"共 {oldTileIds.Count} 個 TileId 將被重新編號。";
                if (updateTilePak)
                    confirmMsg += "\n\n同時會將 til 檔案以新編號寫入 Tile.pak。";

                var confirmResult = WinFormsMessageBox.Show(confirmMsg, "確認", MessageBoxButtons.YesNo, MessageBoxIcon.Question);
                if (confirmResult != DialogResult.Yes)
                    return;

                // 如果要更新 pak，先讀取所有原始 til 資料
                Dictionary<int, byte[]> tilDataCache = new Dictionary<int, byte[]>();
                if (updateTilePak)
                {
                    foreach (var oldTileId in oldTileIds)
                    {
                        string key = $"{oldTileId}.til";
                        byte[] data = L1PakReader.UnPack("Tile", key);
                        if (data != null)
                        {
                            tilDataCache[oldTileId] = data;
                        }
                    }
                }

                // 執行重編
                int layer1Updated = 0;
                int layer2Updated = 0;
                int layer4Updated = 0;

                foreach (var s32Data in _document.S32Files.Values)
                {
                    // 更新 Layer1
                    for (int y = 0; y < 64; y++)
                    {
                        for (int x = 0; x < 128; x++)
                        {
                            var cell = s32Data.Layer1[y, x];
                            if (cell != null && tileIdMapping.TryGetValue(cell.TileId, out int newTileId))
                            {
                                cell.TileId = newTileId;
                                layer1Updated++;
                            }
                        }
                    }

                    // 更新 Layer2
                    foreach (var item in s32Data.Layer2)
                    {
                        if (tileIdMapping.TryGetValue(item.TileId, out int newTileId))
                        {
                            item.TileId = (ushort)newTileId;
                            layer2Updated++;
                        }
                    }

                    // 更新 Layer4
                    foreach (var obj in s32Data.Layer4)
                    {
                        if (tileIdMapping.TryGetValue(obj.TileId, out int newTileId))
                        {
                            obj.TileId = newTileId;
                            layer4Updated++;
                        }
                    }
                }

                // 寫入 Tile.pak
                int tilWrittenCount = 0;
                int tilSkippedCount = 0;
                if (updateTilePak && tilDataCache.Count > 0)
                {
                    var filesToWrite = new Dictionary<string, byte[]>();
                    foreach (var kvp in tileIdMapping)
                    {
                        int oldId = kvp.Key;
                        int newId = kvp.Value;
                        if (tilDataCache.TryGetValue(oldId, out byte[] data))
                        {
                            string newFileName = $"{newId}.til";
                            // 檢查新編號是否已存在
                            if (!L1PakWriter.FileExists("Tile", newFileName))
                            {
                                filesToWrite[newFileName] = data;
                            }
                            else
                            {
                                tilSkippedCount++;
                            }
                        }
                    }
                    tilWrittenCount = L1PakWriter.AppendFiles("Tile", filesToWrite);
                }

                // 標記為已修改
                foreach (var s32Data in _document.S32Files.Values)
                {
                    s32Data.IsModified = true;
                }

                // 清除快取
                cachedAggregatedTiles.Clear();
                _renderCache.TilFileCache.Clear();
                _renderCache.TilRemasterCache.Clear();

                // 重新整理 Tile 列表（兩者並行執行）
                UpdateGroupThumbnailsList();  // 異步，立即返回
                UpdateTileList(txtTileSearch.Text);  // 同步執行，但群組縮圖已在背景處理

                // 強制重新渲染地圖
                _viewState.SetRenderResult(0, 0, 0, 0, 0);
                _mapViewerControl.Refresh();

                // 建構結果訊息
                var resultMsg = $"TileId 重新編號完成！\n\n" +
                    $"更新 Layer1: {layer1Updated} 格\n" +
                    $"更新 Layer2: {layer2Updated} 項\n" +
                    $"更新 Layer4: {layer4Updated} 個物件\n";

                if (updateTilePak)
                {
                    resultMsg += $"\n寫入 Tile.pak: {tilWrittenCount} 個 til 檔案";
                    if (tilSkippedCount > 0)
                        resultMsg += $"\n跳過（已存在）: {tilSkippedCount} 個";
                }

                resultMsg += $"\n\n對應表:\n{string.Join("\n", tileIdMapping.Select(kv => $"  {kv.Key} → {kv.Value}"))}";

                WinFormsMessageBox.Show(resultMsg, "完成", MessageBoxButtons.OK, MessageBoxIcon.Information);

                toolStripStatusLabel1.Text = $"已重新編號 {oldTileIds.Count} 個 TileId";
            }
        }

        // 刪除所有使用指定 TileId 的 Layer4 物件
        private void DeleteAllLayer4ByTileId(int tileId)
        {
            // 計算要刪除的數量
            int totalCount = 0;
            foreach (var s32Data in _document.S32Files.Values)
            {
                totalCount += s32Data.Layer4.Count(o => o.TileId == tileId);
            }

            if (totalCount == 0)
            {
                WinFormsMessageBox.Show($"沒有找到使用 TileId {tileId} 的 Layer4 物件。", "提示", MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            // 確認刪除
            DialogResult result = WinFormsMessageBox.Show(
                $"確定要刪除所有使用 TileId {tileId} 的 Layer4 物件嗎？\n" +
                $"這將移除 {totalCount} 個物件。",
                "確認刪除",
                MessageBoxButtons.YesNo,
                MessageBoxIcon.Warning);

            if (result != DialogResult.Yes)
                return;

            // 執行刪除
            int deletedCount = 0;
            foreach (var s32Data in _document.S32Files.Values)
            {
                // 先收集要刪除的物件以更新空間索引
                var toRemove = s32Data.Layer4.Where(o => o.TileId == tileId).ToList();
                if (toRemove.Count > 0)
                {
                    s32Data.Layer4.RemoveAll(o => o.TileId == tileId);
                    Layer4Index_RemoveRange(s32Data, toRemove);
                    deletedCount += toRemove.Count;
                    s32Data.IsModified = true;
                }
            }

            // 重新渲染
            RenderS32Map();

            // 更新 Tile 清單和群組縮圖（並行執行）
            cachedAggregatedTiles.Clear();
            UpdateGroupThumbnailsList();  // 異步，立即返回
            UpdateTileList(txtTileSearch.Text);  // 同步執行，但群組縮圖已在背景處理

            this.toolStripStatusLabel1.Text = $"已刪除 TileId {tileId} 的所有 Layer4 物件，共 {deletedCount} 個";
        }

        // 刪除所有使用指定 TileId 的引用（Layer1 + Layer2 + Layer4）
        private void DeleteAllReferencesByTileId(int tileId, int layer1Count, int layer2Count, int layer4Count)
        {
            int totalCount = layer1Count + layer2Count + layer4Count;
            if (totalCount == 0)
            {
                WinFormsMessageBox.Show($"沒有找到使用 TileId {tileId} 的引用。", "提示", MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            // 確認刪除
            DialogResult result = WinFormsMessageBox.Show(
                $"確定要刪除所有使用 TileId {tileId} 的引用嗎？\n\n" +
                $"Layer1 地板: {layer1Count} 個\n" +
                $"Layer2 裝飾: {layer2Count} 個\n" +
                $"Layer4 物件: {layer4Count} 個\n\n" +
                $"總計: {totalCount} 個",
                "確認刪除",
                MessageBoxButtons.YesNo,
                MessageBoxIcon.Warning);

            if (result != DialogResult.Yes)
                return;

            // 執行刪除
            int deletedL1 = 0;
            int deletedL2 = 0;
            int deletedL4 = 0;

            foreach (var s32Data in _document.S32Files.Values)
            {
                bool modified = false;

                // Layer1 - 將 TileId 設為 0
                if (s32Data.Layer1 != null)
                {
                    for (int y = 0; y < 64; y++)
                    {
                        for (int x = 0; x < 128; x++)
                        {
                            var cell = s32Data.Layer1[y, x];
                            if (cell != null && cell.TileId == tileId)
                            {
                                cell.TileId = 0;
                                cell.IndexId = 0;
                                deletedL1++;
                                modified = true;
                            }
                        }
                    }
                }

                // Layer2 - 移除物件
                int l2Removed = s32Data.Layer2.RemoveAll(o => o.TileId == tileId);
                if (l2Removed > 0)
                {
                    deletedL2 += l2Removed;
                    modified = true;
                }

                // Layer4 - 移除物件並更新空間索引
                var toRemove = s32Data.Layer4.Where(o => o.TileId == tileId).ToList();
                if (toRemove.Count > 0)
                {
                    s32Data.Layer4.RemoveAll(o => o.TileId == tileId);
                    Layer4Index_RemoveRange(s32Data, toRemove);
                    deletedL4 += toRemove.Count;
                    modified = true;
                }

                if (modified)
                {
                    s32Data.IsModified = true;
                }
            }

            // 重新渲染
            RenderS32Map();

            // 更新 Tile 清單和群組縮圖
            cachedAggregatedTiles.Clear();
            UpdateGroupThumbnailsList();
            UpdateTileList(txtTileSearch.Text);

            this.toolStripStatusLabel1.Text = $"已刪除 TileId {tileId} 的所有引用 (L1:{deletedL1} L2:{deletedL2} L4:{deletedL4})";
        }

        // 在地圖上高亮顯示使用指定 TileId 的物件
        private void HighlightTileOnMap(int tileId)
        {
            // 找到第一個使用此 TileId 的物件並跳轉
            foreach (var s32Data in _document.S32Files.Values)
            {
                var obj = s32Data.Layer4.FirstOrDefault(o => o.TileId == tileId);
                if (obj != null)
                {
                    // 計算全域座標並跳轉
                    int globalX = s32Data.SegInfo.nLinBeginX * 2 + obj.X;
                    int globalY = s32Data.SegInfo.nLinBeginY + obj.Y;

                    // 跳轉到該位置
                    JumpToGameCoordinate(globalX, globalY);

                    this.toolStripStatusLabel1.Text = $"跳轉到 TileId {tileId} 的物件位置 ({globalX}, {globalY})";
                    return;
                }
            }

            WinFormsMessageBox.Show($"沒有找到使用 TileId {tileId} 的 Layer4 物件。", "提示", MessageBoxButtons.OK, MessageBoxIcon.Information);
        }

        // 顯示 Tile 詳細資訊（含座標列表和跳轉功能）
        private void ShowTileInfo(TileInfo tileInfo)
        {
            // 收集所有使用此 TileId 的位置 (增加 l4X, l4Y 儲存 Layer4 原始座標)
            List<(int globalX, int globalY, string layer, int groupId, S32Data s32, int l4X, int l4Y)> locations =
                new List<(int, int, string, int, S32Data, int, int)>();

            foreach (var s32Data in _document.S32Files.Values)
            {
                int segStartX = s32Data.SegInfo.nLinBeginX;
                int segStartY = s32Data.SegInfo.nLinBeginY;

                // Layer1 (64x128，但遊戲座標用 Layer3 的 64x64)
                for (int y = 0; y < 64; y++)
                {
                    for (int x = 0; x < 128; x++)
                    {
                        var cell = s32Data.Layer1[y, x];
                        if (cell != null && cell.TileId == tileInfo.TileId)
                        {
                            // Layer1 的 x 要除以 2 來對應 Layer3 座標
                            int layer3X = x / 2;
                            int globalX = segStartX + layer3X;
                            int globalY = segStartY + y;
                            locations.Add((globalX, globalY, "L1", 0, s32Data, -1, -1));
                        }
                    }
                }

                // Layer4 (obj.X 是 Layer1 座標 0-127，obj.Y 是 Layer3 座標 0-63)
                foreach (var obj in s32Data.Layer4)
                {
                    if (obj.TileId == tileInfo.TileId)
                    {
                        // Layer4 的 X 也要除以 2 來對應 Layer3 座標
                        int layer3X = obj.X / 2;
                        int globalX = segStartX + layer3X;
                        int globalY = segStartY + obj.Y;
                        locations.Add((globalX, globalY, "L4", obj.GroupId, s32Data, obj.X, obj.Y));
                    }
                }
            }

            // 建立詳細資訊視窗
            Form infoForm = new Form
            {
                Text = $"Tile {tileInfo.TileId} 詳細資訊",
                Size = new Size(500, 450),
                StartPosition = FormStartPosition.CenterParent,
                FormBorderStyle = FormBorderStyle.Sizable,
                MinimizeBox = false
            };

            // 基本資訊標籤
            Label lblBasicInfo = new Label
            {
                Text = $"TileId: {tileInfo.TileId}  |  IndexId: {tileInfo.IndexId}  |  總共 {locations.Count} 個位置",
                Location = new Point(10, 10),
                Size = new Size(460, 20),
                Font = new Font(SystemFonts.Default().Family, 9, FontStyle.Bold)
            };

            // 座標跳轉輸入框
            Label lblJump = new Label
            {
                Text = "跳轉座標:",
                Location = new Point(10, 38),
                Size = new Size(70, 23),
                TextAlign = ContentAlignment.MiddleLeft
            };

            TextBox txtJumpCoord = new TextBox
            {
                Location = new Point(80, 38),
                Size = new Size(150, 23),
                PlaceholderText = "輸入 X,Y 座標"
            };

            Button btnJump = new Button
            {
                Text = "跳轉",
                Location = new Point(235, 37),
                Size = new Size(60, 25)
            };

            // 座標列表
            ListView lvLocations = new ListView
            {
                Location = new Point(10, 70),
                Size = new Size(460, 280),
                View = View.Details,
                FullRowSelect = true,
                GridLines = true,
                Anchor = AnchorStyles.Top | AnchorStyles.Bottom | AnchorStyles.Left | AnchorStyles.Right
            };
            lvLocations.Columns.Add("X", 55);
            lvLocations.Columns.Add("Y", 55);
            lvLocations.Columns.Add("圖層", 40);
            lvLocations.Columns.Add("GroupId", 55);
            lvLocations.Columns.Add("L4座標", 70);
            lvLocations.Columns.Add("S32檔案", 130);

            // 右鍵選單 - 複製整行
            ContextMenuStrip lvContextMenu = new ContextMenuStrip();
            ToolStripMenuItem copyRowItem = new ToolStripMenuItem("複製整行");
            copyRowItem.Click += (s, ev) =>
            {
                if (lvLocations.SelectedItems.Count > 0)
                {
                    var item = lvLocations.SelectedItems[0];
                    string rowText = $"{item.SubItems[0].Text},{item.SubItems[1].Text},{item.SubItems[2].Text},{item.SubItems[3].Text},{item.SubItems[4].Text},{item.SubItems[5].Text}";
                    ClipboardHelper.SetText(rowText);
                    this.toolStripStatusLabel1.Text = "已複製整行";
                }
            };
            lvContextMenu.Items.Add(copyRowItem);
            lvLocations.ContextMenuStrip = lvContextMenu;

            // 填充座標列表
            foreach (var loc in locations.OrderBy(l => l.globalX).ThenBy(l => l.globalY))
            {
                string s32FileName = Path.GetFileName(loc.s32.FilePath);
                var item = new ListViewItem(loc.globalX.ToString());
                item.SubItems.Add(loc.globalY.ToString());
                item.SubItems.Add(loc.layer);
                item.SubItems.Add(loc.groupId > 0 ? loc.groupId.ToString() : "-");
                item.SubItems.Add(loc.l4X >= 0 ? $"({loc.l4X},{loc.l4Y})" : "-");
                item.SubItems.Add(s32FileName);
                item.Tag = loc;
                lvLocations.Items.Add(item);
            }

            // 複製按鈕
            Button btnCopyAll = new Button
            {
                Text = "複製全部座標",
                Location = new Point(10, 360),
                Size = new Size(100, 28),
                Anchor = AnchorStyles.Bottom | AnchorStyles.Left
            };

            Button btnCopySelected = new Button
            {
                Text = "複製選中",
                Location = new Point(115, 360),
                Size = new Size(80, 28),
                Anchor = AnchorStyles.Bottom | AnchorStyles.Left
            };

            Button btnClose = new Button
            {
                Text = "關閉",
                Location = new Point(390, 360),
                Size = new Size(80, 28),
                Anchor = AnchorStyles.Bottom | AnchorStyles.Right
            };

            // 事件處理
            btnJump.Click += (s, ev) =>
            {
                string input = txtJumpCoord.Text.Trim();
                if (TryParseCoordinate(input, out int x, out int y))
                {
                    JumpToGameCoordinate(x, y);
                    this.toolStripStatusLabel1.Text = $"已跳轉到座標 ({x}, {y})";
                }
                else
                {
                    WinFormsMessageBox.Show("請輸入正確的座標格式，例如: 32800,32700", "格式錯誤", MessageBoxButtons.OK, MessageBoxIcon.Warning);
                }
            };

            txtJumpCoord.KeyDown += (s, ev) =>
            {
                if (ev.GetKeyCode() == Keys.Enter)
                {
                    btnJump.PerformClick();
                    ev.Handled = true;
                    ev.SetSuppressKeyPress(true);
                }
            };

            // 單擊列表項目跳轉並高亮
            lvLocations.SelectedIndexChanged += (s, ev) =>
            {
                if (lvLocations.SelectedItems.Count > 0)
                {
                    var loc = ((int globalX, int globalY, string layer, int groupId, S32Data s32, int l4X, int l4Y))lvLocations.SelectedItems[0].Tag;
                    JumpToGameCoordinate(loc.globalX, loc.globalY);
                    string l4Info = loc.l4X >= 0 ? $" L4座標:({loc.l4X},{loc.l4Y})" : "";
                    this.toolStripStatusLabel1.Text = $"已跳轉到座標 ({loc.globalX}, {loc.globalY}) - {loc.layer}" +
                        (loc.groupId > 0 ? $" GroupId:{loc.groupId}" : "") + l4Info;
                }
            };

            btnCopyAll.Click += (s, ev) =>
            {
                var coords = locations.Select(l => $"{l.globalX},{l.globalY}");
                string text = string.Join("\n", coords);
                ClipboardHelper.SetText(text);
                WinFormsMessageBox.Show($"已複製 {locations.Count} 個座標到剪貼簿", "複製成功", MessageBoxButtons.OK, MessageBoxIcon.Information);
            };

            btnCopySelected.Click += (s, ev) =>
            {
                if (lvLocations.SelectedItems.Count == 0)
                {
                    WinFormsMessageBox.Show("請先選取要複製的座標", "提示", MessageBoxButtons.OK, MessageBoxIcon.Information);
                    return;
                }
                var selectedCoords = new List<string>();
                foreach (ListViewItem item in lvLocations.SelectedItems)
                {
                    selectedCoords.Add(item.SubItems[4].Text);
                }
                ClipboardHelper.SetText(string.Join("\n", selectedCoords));
                WinFormsMessageBox.Show($"已複製 {selectedCoords.Count} 個座標到剪貼簿", "複製成功", MessageBoxButtons.OK, MessageBoxIcon.Information);
            };

            btnClose.Click += (s, ev) => infoForm.Close();

            // 加入控制項
            infoForm.GetControls().Add(lblBasicInfo);
            infoForm.GetControls().Add(lblJump);
            infoForm.GetControls().Add(txtJumpCoord);
            infoForm.GetControls().Add(btnJump);
            infoForm.GetControls().Add(lvLocations);
            infoForm.GetControls().Add(btnCopyAll);
            infoForm.GetControls().Add(btnCopySelected);
            infoForm.GetControls().Add(btnClose);

            infoForm.ShowDialog(this);
        }

        // [TryParseCoordinate, toolStripJumpButton_Click, toolStripJumpTextBox_KeyDown,
        //  toolStripCopyMoveCmd_Click 已移至 MapForm.Coordinates.cs]

        // 顯示全部 L8 按鈕點擊事件 - 顯示地圖中所有 Layer8 SPR
        private void toolStripShowAllL8_Click(object sender, EventArgs e)
        {
            if (_document.S32Files.Count == 0)
            {
                this.toolStripStatusLabel1.Text = LocalizationManager.L("Message_PleaseLoadMap");
                return;
            }

            int addedCount = 0;

            // 顯示全部地圖的 Layer8
            foreach (var s32Data in _document.S32Files.Values)
            {
                if (s32Data.Layer8.Count == 0) continue;

                for (int i = 0; i < s32Data.Layer8.Count; i++)
                {
                    var item = s32Data.Layer8[i];

                    // 檢查座標是否有效
                    int localL3X = item.X - s32Data.SegInfo.nLinBeginX;
                    int localL3Y = item.Y - s32Data.SegInfo.nLinBeginY;

                    if (localL3X < 0 || localL3X > 63 || localL3Y < 0 || localL3Y > 63)
                        continue;

                    var key = (s32Data.FilePath, i);
                    if (!_editState.EnabledLayer8Items.Contains(key))
                    {
                        _editState.EnabledLayer8Items.Add(key);
                        _renderCache.Layer8AnimFrame[key] = 0;
                        addedCount++;
                    }
                }
            }

            // 啟動動畫計時器
            if (addedCount > 0 && _layer8AnimTimer != null && !_layer8AnimTimer.Enabled)
            {
                _layer8AnimTimer.Start();
            }

            // 確保 Layer8 顯示已開啟
            if (!_viewState.ShowLayer8Spr)
            {
                _viewState.ShowLayer8Spr = true;
                chkFloatLayer8Spr.Checked = true;
            }

            this.toolStripStatusLabel1.Text = string.Format(LocalizationManager.L("L8_EnabledCount"), addedCount, _editState.EnabledLayer8Items.Count);
            RenderS32Map();
        }

        // [PerformCoordinateJump, JumpToGameCoordinate 已移至 MapForm.Coordinates.cs]

        // 載入放大的 Tile
        private Bitmap LoadTileEnlarged(int tileId, int indexId, int size)
        {
            try
            {
                string key = $"{tileId}.til";
                byte[] data = L1PakReader.UnPack("Tile", key);
                if (data == null) return CreatePlaceholderThumbnail(tileId);

                var tilArray = L1Til.Parse(data);
                if (indexId >= tilArray.Count) return CreatePlaceholderThumbnail(tileId);

                // 繪製實際的 tile 圖片（放大版本）
                byte[] tilData = tilArray[indexId];
                return RenderTileEnlarged(tilData, tileId, size);
            }
            catch
            {
                return CreatePlaceholderThumbnail(tileId);
            }
        }

        // 創建所有相關物件面板（包含周圍物件）
        private Panel CreateAllRelatedObjectsPanel(int cellX, int cellY)
        {
            Panel panel = new Panel();
            panel.SetDock(DockStyle.Fill);
            panel.AutoScroll = true;

            // 找出所有可能影響該格子顯示的物件
            // 包含：該格子的物件 + 周圍格子的大型物件
            List<ObjectTile> relatedObjects = new List<ObjectTile>();

            // 搜索範圍：當前格子 ± 5 格（大型物件可能很大）
            int searchRange = 5;
            for (int dy = -searchRange; dy <= searchRange; dy++)
            {
                for (int dx = -searchRange; dx <= searchRange; dx++)
                {
                    int checkX = cellX + dx;
                    int checkY = cellY + dy;

                    // 在範圍內
                    if (checkX >= 0 && checkX < 128 && checkY >= 0 && checkY < 64)
                    {
                        var objectsAtPos = currentS32Data.Layer4.Where(o => o.X == checkX && o.Y == checkY).ToList();
                        foreach (var obj in objectsAtPos)
                        {
                            // 計算物件與目標格子的距離
                            int distance = Math.Abs(dx) + Math.Abs(dy);
                            relatedObjects.Add(obj);
                        }
                    }
                }
            }

            // 按距離和層次排序
            relatedObjects = relatedObjects
                .OrderBy(o => Math.Abs(o.X - cellX) + Math.Abs(o.Y - cellY))
                .ThenBy(o => o.Layer)
                .ToList();

            if (relatedObjects.Count > 0)
            {
                FlowLayoutPanel flow = new FlowLayoutPanel();
                flow.SetDock(DockStyle.Fill);
                flow.AutoScroll = true;
                flow.FlowDirection = FlowDirection.TopDown;
                flow.WrapContents = false;

                Label header = new Label();
                header.Text = $"找到 {relatedObjects.Count} 個相關物件";
                header.Font = new Font("Arial", 10, FontStyle.Bold);
                header.Height = 30;
                header.SetTextAlign(ContentAlignment.MiddleLeft);
                flow.GetControls().Add(header);

                foreach (var obj in relatedObjects)
                {
                    Panel objPanel = new Panel();
                    objPanel.Width = flow.Width - 25;
                    objPanel.Height = 240;
                    objPanel.BorderStyle = BorderStyle.FixedSingle;
                    objPanel.Margin = new Padding(5);
                    objPanel.BackgroundColor = (obj.X == cellX && obj.Y == cellY) ? Colors.LightYellow : Colors.White;

                    // 位置標籤
                    Label posLabel = new Label();
                    int distance = Math.Abs(obj.X - cellX) + Math.Abs(obj.Y - cellY);
                    posLabel.Text = distance == 0
                        ? $"[此格子] 位置: ({obj.X},{obj.Y})"
                        : $"[距離{distance}] 位置: ({obj.X},{obj.Y})";
                    posLabel.SetDock(DockStyle.Top);
                    posLabel.Height = 20;
                    posLabel.BackgroundColor = distance == 0 ? Colors.Yellow : Colors.LightGrey;
                    posLabel.SetTextAlign(ContentAlignment.MiddleCenter);
                    posLabel.Font = new Font("Arial", 8, FontStyle.Bold);
                    objPanel.GetControls().Add(posLabel);

                    PictureBox pb = new PictureBox();
                    pb.SetDock(DockStyle.Top);
                    pb.Height = 128;
                    pb.SetSizeMode(PictureBoxSizeMode.Zoom);
                    pb.BackgroundColor = Colors.Black;
                    pb.Image = LoadTileEnlarged(obj.TileId, obj.IndexId, 128);
                    objPanel.GetControls().Add(pb);

                    Label info = new Label();
                    info.Text = $"Tile ID: {obj.TileId} | Index: {obj.IndexId}\n" +
                               $"Layer: {obj.Layer} | Group: {obj.GroupId}\n" +
                               $"位置: ({obj.X},{obj.Y})";
                    info.SetDock(DockStyle.Bottom);
                    info.Height = 60;
                    info.SetTextAlign(ContentAlignment.MiddleCenter);
                    objPanel.GetControls().Add(info);

                    // 刪除按鈕
                    Button btnDeleteObj = new Button();
                    btnDeleteObj.Text = "刪除此物件";
                    btnDeleteObj.SetDock(DockStyle.Bottom);
                    btnDeleteObj.Height = 25;
                    btnDeleteObj.BackgroundColor = Colors.Red;
                    btnDeleteObj.TextColor = Colors.White;
                    var objToDelete = obj;
                    btnDeleteObj.Click += (s, e) =>
                    {
                        if (WinFormsMessageBox.Show($"確定要刪除此物件嗎？\n位置:({objToDelete.X},{objToDelete.Y})\nGroup:{objToDelete.GroupId}, Layer:{objToDelete.Layer}",
                            "確認", MessageBoxButtons.YesNo, MessageBoxIcon.Question) == DialogResult.Yes)
                        {
                            currentS32Data.Layer4.Remove(objToDelete);
                            Layer4Index_Remove(currentS32Data, objToDelete);

                            isS32Modified = true;
                            RenderS32Map();
                            this.toolStripStatusLabel1.Text = $"已刪除物件 ({objToDelete.X},{objToDelete.Y})";

                            // 更新當前面板顯示
                            pb.Image = null;
                            info.Text = "已刪除";
                            btnDeleteObj.Enabled = false;
                            objPanel.BackgroundColor = Colors.LightGrey;
                        }
                    };
                    objPanel.GetControls().Add(btnDeleteObj);

                    flow.GetControls().Add(objPanel);
                }

                panel.GetControls().Add(flow);
            }
            else
            {
                Label noData = new Label();
                noData.Text = "附近沒有物件";
                noData.SetDock(DockStyle.Fill);
                noData.SetTextAlign(ContentAlignment.MiddleCenter);
                panel.GetControls().Add(noData);
            }

            return panel;
        }

        // 創建渲染資訊面板
        private Panel CreateRenderInfoPanel(int cellX, int cellY)
        {
            Panel panel = new Panel();
            panel.SetDock(DockStyle.Fill);
            panel.AutoScroll = true;
            panel.BackgroundColor = Colors.White;

            TextBox txtInfo = new TextBox();
            txtInfo.Multiline = true;
            txtInfo.SetDock(DockStyle.Fill);
            txtInfo.Font = new Font("Consolas", 9);
            txtInfo.ScrollBars = ScrollBars.Both;
            txtInfo.WordWrap = false;

            // 計算遊戲座標（Layer3 尺度）
            int layer3X = cellX / 2;
            if (layer3X >= 64) layer3X = 63;
            int gameX = currentS32FileItem.SegInfo.nLinBeginX + layer3X;
            int gameY = currentS32FileItem.SegInfo.nLinBeginY + cellY;

            StringBuilder info = new StringBuilder();
            info.AppendLine("==================== 格子渲染資訊 ====================");
            info.AppendLine($"格子座標: ({cellX}, {cellY})");
            info.AppendLine($"遊戲座標: ({gameX}, {gameY})");
            info.AppendLine();

            // 第一層資訊
            info.AppendLine("【第1層 - 地板】");
            // 計算全域座標（正規化為偶數）
            int normX = (cellX / 2) * 2;
            int globalLayer1X_Even = currentS32Data.SegInfo.nLinBeginX * 2 + normX;      // 左三角（偶數）
            int globalLayer1X_Odd = globalLayer1X_Even + 1;                               // 右三角（奇數）
            int globalLayer1Y = currentS32Data.SegInfo.nLinBeginY + cellY;

            // 左三角（X=偶數）
            info.AppendLine("  ◀ 左三角 (X=偶數):");
            bool foundLeft = false;
            foreach (var s32Data in _document.S32Files.Values)
            {
                int s32StartX = s32Data.SegInfo.nLinBeginX * 2;
                int s32StartY = s32Data.SegInfo.nLinBeginY;
                int localX = globalLayer1X_Even - s32StartX;
                int localY = globalLayer1Y - s32StartY;

                if (localX >= 0 && localX < 128 && localY >= 0 && localY < 64)
                {
                    var cell = s32Data.Layer1[localY, localX];
                    if (cell != null && cell.TileId > 0)
                    {
                        info.AppendLine($"    Tile ID: {cell.TileId}, Index: {cell.IndexId}");
                        info.AppendLine($"    來源: {System.IO.Path.GetFileName(s32Data.FilePath)}");
                        foundLeft = true;
                        break;
                    }
                }
            }
            if (!foundLeft) info.AppendLine("    (空)");

            // 右三角（X=奇數）
            info.AppendLine("  ▶ 右三角 (X=奇數):");
            bool foundRight = false;
            foreach (var s32Data in _document.S32Files.Values)
            {
                int s32StartX = s32Data.SegInfo.nLinBeginX * 2;
                int s32StartY = s32Data.SegInfo.nLinBeginY;
                int localX = globalLayer1X_Odd - s32StartX;
                int localY = globalLayer1Y - s32StartY;

                if (localX >= 0 && localX < 128 && localY >= 0 && localY < 64)
                {
                    var cell = s32Data.Layer1[localY, localX];
                    if (cell != null && cell.TileId > 0)
                    {
                        info.AppendLine($"    Tile ID: {cell.TileId}, Index: {cell.IndexId}");
                        info.AppendLine($"    來源: {System.IO.Path.GetFileName(s32Data.FilePath)}");
                        foundRight = true;
                        break;
                    }
                }
            }
            if (!foundRight) info.AppendLine("    (空)");
            info.AppendLine();

            // 第二層資訊
            info.AppendLine("【第2層 - 資料】");
            info.AppendLine($"  總共有 {currentS32Data.Layer2.Count} 項資料");
            info.AppendLine("  (此層不對應具體格子)");
            info.AppendLine();

            // 第三層資訊
            info.AppendLine("【第3層 - 屬性】");
            // 計算全域 Layer3 座標（遊戲座標）
            int globalGameX = currentS32Data.SegInfo.nLinBeginX + layer3X;
            int globalGameY = currentS32Data.SegInfo.nLinBeginY + cellY;

            // 搜尋所有 S32 找到有效範圍內的資料
            bool foundLayer3 = false;
            foreach (var s32Data in _document.S32Files.Values)
            {
                int s32GameStartX = s32Data.SegInfo.nLinBeginX;
                int s32GameStartY = s32Data.SegInfo.nLinBeginY;
                int localGameX = globalGameX - s32GameStartX;
                int localGameY = globalGameY - s32GameStartY;

                // 檢查是否在此 S32 的有效範圍內
                if (localGameX >= 0 && localGameX < 64 && localGameY >= 0 && localGameY < 64)
                {
                    var attr = s32Data.Layer3[localGameY, localGameX];
                    if (attr != null && (attr.Attribute1 != 0 || attr.Attribute2 != 0))
                    {
                        info.AppendLine($"  左上邊: 0x{attr.Attribute1:X4} ({attr.Attribute1})");
                        info.AppendLine($"  右上邊: 0x{attr.Attribute2:X4} ({attr.Attribute2})");

                        // 左上邊標記
                        List<string> flags1 = new List<string>();
                        if ((attr.Attribute1 & 0x01) != 0)
                            flags1.Add("不可通行");
                        else
                            flags1.Add("可通行");
                        int val1 = attr.Attribute1 & 0x0F;
                        if ((val1 & 0x04) != 0) flags1.Add("安全區");
                        else if ((val1 & 0x0C) == 0x08) flags1.Add("戰鬥區");
                        if ((attr.Attribute1 & 0x02) != 0) flags1.Add("標記2");
                        if ((attr.Attribute1 & 0x10) != 0) flags1.Add("標記16");
                        info.AppendLine($"  左上邊標記: {string.Join(", ", flags1)}");

                        // 右上邊標記
                        List<string> flags2 = new List<string>();
                        if ((attr.Attribute2 & 0x01) != 0)
                            flags2.Add("不可通行");
                        else
                            flags2.Add("可通行");
                        int val2 = attr.Attribute2 & 0x0F;
                        if ((val2 & 0x04) != 0) flags2.Add("安全區");
                        else if ((val2 & 0x0C) == 0x08) flags2.Add("戰鬥區");
                        if ((attr.Attribute2 & 0x02) != 0) flags2.Add("標記2");
                        if ((attr.Attribute2 & 0x10) != 0) flags2.Add("標記16");
                        info.AppendLine($"  右上邊標記: {string.Join(", ", flags2)}");
                        info.AppendLine($"  來源 S32: {System.IO.Path.GetFileName(s32Data.FilePath)}");
                        foundLayer3 = true;
                        break;
                    }
                }
            }
            if (!foundLayer3)
            {
                info.AppendLine("  (空)");
            }
            info.AppendLine();

            // 第四層資訊
            info.AppendLine("【第4層 - 物件】");
            // 搜尋所有 S32 找到此格子的物件，分左右三角
            var leftObjects = new List<(ObjectTile obj, S32Data s32)>();
            var rightObjects = new List<(ObjectTile obj, S32Data s32)>();

            foreach (var s32Data in _document.S32Files.Values)
            {
                int s32StartX = s32Data.SegInfo.nLinBeginX * 2;
                int s32StartY = s32Data.SegInfo.nLinBeginY;

                foreach (var obj in s32Data.Layer4)
                {
                    int objGlobalX = s32StartX + obj.X;
                    int objGlobalY = s32StartY + obj.Y;

                    if (objGlobalY == globalLayer1Y)
                    {
                        if (objGlobalX == globalLayer1X_Even)
                            leftObjects.Add((obj, s32Data));
                        else if (objGlobalX == globalLayer1X_Odd)
                            rightObjects.Add((obj, s32Data));
                    }
                }
            }

            // 左三角物件（X=偶數）
            info.AppendLine("  ◀ 左三角 (X=偶數):");
            if (leftObjects.Count > 0)
            {
                foreach (var (obj, s32) in leftObjects.OrderBy(x => x.obj.Layer))
                {
                    info.AppendLine($"    區域:{obj.X},{obj.Y} S32:{System.IO.Path.GetFileName(s32.FilePath)} 高度:{obj.Layer} 群組:{obj.GroupId} Tile:{obj.TileId}/{obj.IndexId}");
                }
            }
            else
            {
                info.AppendLine("    (無物件)");
            }

            // 右三角物件（X=奇數）
            info.AppendLine("  ▶ 右三角 (X=奇數):");
            if (rightObjects.Count > 0)
            {
                foreach (var (obj, s32) in rightObjects.OrderBy(x => x.obj.Layer))
                {
                    info.AppendLine($"    區域:{obj.X},{obj.Y} S32:{System.IO.Path.GetFileName(s32.FilePath)} 高度:{obj.Layer} 群組:{obj.GroupId} Tile:{obj.TileId}/{obj.IndexId}");
                }
            }
            else
            {
                info.AppendLine("    (無物件)");
            }
            info.AppendLine();

            // 周圍物件統計（使用全域座標）
            info.AppendLine("【周圍物件統計】");
            int nearbyCount = 0;
            foreach (var s32Data in _document.S32Files.Values)
            {
                int s32StartX = s32Data.SegInfo.nLinBeginX * 2;
                int s32StartY = s32Data.SegInfo.nLinBeginY;
                nearbyCount += s32Data.Layer4.Count(o =>
                    Math.Abs((s32StartX + o.X) - globalLayer1X_Even) <= 10 &&
                    Math.Abs((s32StartY + o.Y) - globalLayer1Y) <= 5);
            }
            info.AppendLine($"  5格範圍內物件數: {nearbyCount}");
            info.AppendLine();

            // 檔案資訊
            info.AppendLine("【S32 檔案資訊】");
            info.AppendLine($"  檔案: {Path.GetFileName(currentS32FileItem.FilePath)}");
            info.AppendLine($"  Block 座標: ({currentS32FileItem.SegInfo.nBlockX:X4}, {currentS32FileItem.SegInfo.nBlockY:X4})");
            info.AppendLine($"  遊戲座標範圍: [{currentS32FileItem.SegInfo.nLinBeginX},{currentS32FileItem.SegInfo.nLinBeginY}] ~ [{currentS32FileItem.SegInfo.nLinEndX},{currentS32FileItem.SegInfo.nLinEndY}]");
            info.AppendLine($"  已修改: {(isS32Modified ? "是" : "否")}");
            info.AppendLine();

            // 使用的 Tile 統計
            info.AppendLine("【使用的 Tile 統計】");
            info.AppendLine($"  總共使用 {currentS32Data.UsedTiles.Count} 種不同的 Tile");
            info.AppendLine($"  第1層格子數: {64 * 128} (64x128)");
            info.AppendLine($"  第3層格子數: {64 * 64} (64x64)");
            info.AppendLine($"  第4層物件數: {currentS32Data.Layer4.Count}");

            txtInfo.Text = info.ToString();
            panel.GetControls().Add(txtInfo);

            return panel;
        }

        // 保存 S32 按鈕點擊事件 - 保存所有被修改的 S32 檔案
        private void btnSaveS32_Click(object sender, EventArgs e)
        {
            // 檢查是否按住 Shift 鍵（跳過 GroupId 重編）
            bool skipReindex = (ControlCompat.ModifierKeys & Keys.Shift) == Keys.Shift;

            // 找出所有被修改的 S32 檔案
            var modifiedFiles = _document.S32Files.Where(kvp => kvp.Value.IsModified).ToDictionary(kvp => kvp.Key, kvp => kvp.Value);

            if (modifiedFiles.Count == 0)
            {
                this.toolStripStatusLabel1.Text = "沒有需要保存的修改";
                return;
            }

            // 檢查 Layer5 異常
            if (!CheckLayer5IssuesAndConfirm(modifiedFiles, "保存"))
                return;

            int successCount = 0;
            int failCount = 0;
            StringBuilder errors = new StringBuilder();

            foreach (var kvp in modifiedFiles)
            {
                try
                {
                    SaveS32File(kvp.Key, skipReindex);
                    kvp.Value.IsModified = false;
                    successCount++;
                }
                catch (Exception ex)
                {
                    failCount++;
                    errors.AppendLine($"{Path.GetFileName(kvp.Key)}: {ex.Message}");
                }
            }

            // 只在狀態列顯示結果
            string reindexNote = skipReindex ? " (未重編GroupId)" : "";
            if (failCount == 0)
            {
                this.toolStripStatusLabel1.Text = $"成功保存 {successCount} 個 S32 檔案{reindexNote}";
            }
            else
            {
                this.toolStripStatusLabel1.Text = $"保存完成：成功 {successCount} 個，失敗 {failCount} 個{reindexNote}";
                // 只有失敗時才顯示錯誤訊息
                WinFormsMessageBox.Show(
                    $"保存完成：\n成功: {successCount} 個\n失敗: {failCount} 個\n\n失敗詳情：\n{errors}",
                    "部分失敗",
                    MessageBoxButtons.OK,
                    MessageBoxIcon.Warning);
            }
        }

        // 保存 S32 檔案（安全模式：只更新修改過的部分）
        private void SaveS32File(string filePath, bool skipReindex = false)
        {
            // 從字典中取得對應的 S32Data
            if (!_document.S32Files.ContainsKey(filePath))
            {
                throw new InvalidOperationException($"S32 檔案不在記憶體中: {filePath}");
            }

            S32Data s32Data = _document.S32Files[filePath];

            using (MemoryStream ms = new MemoryStream())
            using (BinaryWriter bw = new BinaryWriter(ms))
            {
                // 第一步：寫入前四層之前的數據（如果有的話，通常第一層從0開始）
                if (s32Data.Layer1Offset > 0)
                {
                    bw.Write(s32Data.OriginalFileData, 0, s32Data.Layer1Offset);
                }

                // 第二步：寫入第一層（地板）- 64x128
                for (int y = 0; y < 64; y++)
                {
                    for (int x = 0; x < 128; x++)
                    {
                        var cell = s32Data.Layer1[y, x];
                        if (cell != null)
                        {
                            bw.Write((byte)cell.IndexId);
                            bw.Write((ushort)cell.TileId);
                            bw.Write((byte)0); // nk
                        }
                        else
                        {
                            bw.Write((byte)0);
                            bw.Write((ushort)0);
                            bw.Write((byte)0);
                        }
                    }
                }

                // 第三步：寫入第二層
                bw.Write((ushort)s32Data.Layer2.Count);
                foreach (var item in s32Data.Layer2)
                {
                    bw.Write(item.X);
                    bw.Write(item.Y);
                    bw.Write(item.IndexId);
                    bw.Write(item.TileId);
                    bw.Write(item.UK);
                }

                // 第四步：寫入第三層（地圖屬性）- 64x64
                for (int y = 0; y < 64; y++)
                {
                    for (int x = 0; x < 64; x++)
                    {
                        var attr = s32Data.Layer3[y, x];
                        if (attr != null)
                        {
                            bw.Write(attr.Attribute1);
                            bw.Write(attr.Attribute2);
                        }
                        else
                        {
                            bw.Write((short)0);
                            bw.Write((short)0);
                        }
                    }
                }

                // 第五步：寫入第四層（物件）
                IEnumerable<IGrouping<int, ObjectTile>> groupedObjects;

                if (skipReindex)
                {
                    // 跳過重編：直接使用現有的 GroupId
                    groupedObjects = s32Data.Layer4
                        .GroupBy(o => o.GroupId)
                        .OrderBy(g => g.Key)
                        .ToList();
                }
                else
                {
                    // 重新編排 GroupId 從 0 開始
                    // 收集所有 Layer5 引用的 GroupId
                    var layer5ReferencedGroups = new HashSet<int>(s32Data.Layer5.Select(l5 => (int)l5.ObjectIndex));

                    // 將所有群組分組
                    var allGroups = s32Data.Layer4
                        .GroupBy(o => o.GroupId)
                        .ToList();

                    // 排序：有 Layer5 引用的在前，其餘按原 GroupId 排序
                    var sortedGroups = allGroups
                        .OrderByDescending(g => layer5ReferencedGroups.Contains(g.Key) ? 1 : 0)
                        .ThenBy(g => g.Key)
                        .ToList();

                    // 建立舊 GroupId -> 新 GroupId 的映射
                    var groupIdMapping = new Dictionary<int, int>();
                    for (int idx = 0; idx < sortedGroups.Count; idx++)
                    {
                        groupIdMapping[sortedGroups[idx].Key] = idx;
                    }

                    // 更新記憶體中的 Layer4 GroupId
                    foreach (var obj in s32Data.Layer4)
                    {
                        if (groupIdMapping.TryGetValue(obj.GroupId, out int newId))
                        {
                            obj.GroupId = newId;
                        }
                    }

                    // 更新記憶體中的 Layer5 ObjectIndex
                    foreach (var l5Item in s32Data.Layer5)
                    {
                        int oldIndex = l5Item.ObjectIndex;
                        if (groupIdMapping.TryGetValue(oldIndex, out int newIndex))
                        {
                            l5Item.ObjectIndex = (ushort)newIndex;
                        }
                    }

                    // 重新分組（使用新的 GroupId）
                    groupedObjects = s32Data.Layer4
                        .GroupBy(o => o.GroupId)
                        .OrderBy(g => g.Key)
                        .ToList();
                }

                bw.Write(groupedObjects.Count()); // 組數

                foreach (var group in groupedObjects)
                {
                    var objects = group.OrderBy(o => o.Layer).ToList();
                    bw.Write((short)group.Key); // GroupId (新編號)
                    bw.Write((ushort)objects.Count); // 該組的物件數

                    foreach (var obj in objects)
                    {
                        bw.Write((byte)obj.X);
                        bw.Write((byte)obj.Y);
                        bw.Write((byte)obj.Layer);  // h (圖層高度)
                        // tiledata = indexId | (tileId << 8)
                        uint tileData = (uint)(obj.IndexId & 0xFF) | (uint)((obj.TileId & 0xFFFFFF) << 8);
                        bw.Write(tileData);
                    }
                }

                // 第六步：寫入第5-8層數據（從解析後的資料重新生成）
                // 第五層 - 事件（只寫入 X 為偶數的項目）
                var layer5EvenX = s32Data.Layer5.Where(item => item.X % 2 == 0).ToList();
                bw.Write(layer5EvenX.Count);
                foreach (var item in layer5EvenX)
                {
                    bw.Write(item.X);
                    bw.Write(item.Y);
                    bw.Write(item.ObjectIndex);
                    bw.Write(item.Type);
                }

                // 第六層 - 使用的 til（重新計算並排序）
                // 收集 Layer1 和 Layer4 使用的所有 TileId
                HashSet<int> usedTileIds = new HashSet<int>();

                // 從 Layer1 收集
                for (int y = 0; y < 64; y++)
                {
                    for (int x = 0; x < 128; x++)
                    {
                        var cell = s32Data.Layer1[y, x];
                        if (cell != null && cell.TileId > 0)
                        {
                            usedTileIds.Add(cell.TileId);
                        }
                    }
                }

                // 從 Layer4 收集
                foreach (var obj in s32Data.Layer4)
                {
                    if (obj.TileId > 0)
                    {
                        usedTileIds.Add(obj.TileId);
                    }
                }

                // 排序後寫入
                List<int> sortedTileIds = usedTileIds.OrderBy(id => id).ToList();
                bw.Write(sortedTileIds.Count);
                foreach (var tilId in sortedTileIds)
                {
                    bw.Write(tilId);
                }

                // 更新記憶體中的 Layer6 資料
                s32Data.Layer6.Clear();
                s32Data.Layer6.AddRange(sortedTileIds);

                // 第七層 - 傳送點、入口點
                bw.Write((ushort)s32Data.Layer7.Count);
                foreach (var item in s32Data.Layer7)
                {
                    byte[] nameBytes = Encoding.Default.GetBytes(item.Name ?? "");
                    bw.Write((byte)nameBytes.Length);
                    bw.Write(nameBytes);
                    bw.Write(item.X);
                    bw.Write(item.Y);
                    bw.Write(item.TargetMapId);
                    bw.Write(item.PortalId);
                }

                // 第八層 - 特效、裝飾品
                ushort lv8Count = (ushort)s32Data.Layer8.Count;
                if (s32Data.Layer8HasExtendedData)
                {
                    lv8Count |= 0x8000;  // 設置高位表示有擴展資料
                }
                bw.Write(lv8Count);
                foreach (var item in s32Data.Layer8)
                {
                    bw.Write(item.SprId);
                    bw.Write(item.X);
                    bw.Write(item.Y);
                    if (s32Data.Layer8HasExtendedData)
                    {
                        bw.Write(item.ExtendedData);
                    }
                }

                // 第七步：將完整數據寫入文件
                byte[] outputData = ms.ToArray();
                File.WriteAllBytes(filePath, outputData);
            }
        }

        // 繪製放大的 Tile 到指定大小
        private unsafe Bitmap RenderTileEnlarged(byte[] tilData, int tileId, int size)
        {
            try
            {
                // 創建指定大小的縮圖
                Bitmap thumbnail = new Bitmap(size, size, PixelFormat.Format16bppRgb555);

                Rectangle rect = new Rectangle(0, 0, thumbnail.Width, thumbnail.Height);
                BitmapData bmpData = thumbnail.LockBits(rect, ImageLockMode.ReadWrite, thumbnail.PixelFormat);
                int rowpix = bmpData.Stride;
                byte* ptr = (byte*)bmpData.Scan0;

                // 固定 tilData 陣列以取得指標
                fixed (byte* til_ptr_fixed = tilData)
                {
                    byte* til_ptr = til_ptr_fixed;
                    byte type = *(til_ptr++);

                    // 計算縮放比例和偏移（置中並放大）
                    double scale = size / 48.0; // 48 是原始大小
                    int offsetX = (int)((size - 24 * scale) / 2);
                    int offsetY = (int)((size - 24 * scale) / 2);

                    if ((type & 0x02) == 0 && (type & 0x01) != 0)
                    {
                        // 下半部 2.5D 方塊
                        for (int ty = 0; ty < 24; ty++)
                        {
                            int n = (ty <= 11) ? (ty + 1) * 2 : (23 - ty) * 2;
                            int tx = 0;
                            for (int p = 0; p < n; p++)
                            {
                                ushort color = (ushort)(*(til_ptr++) | (*(til_ptr++) << 8));

                                // 放大繪製
                                int baseX = (int)(offsetX + tx * scale);
                                int baseY = (int)(offsetY + ty * scale);

                                for (int sy = 0; sy < (int)scale + 1; sy++)
                                {
                                    for (int sx = 0; sx < (int)scale + 1; sx++)
                                    {
                                        int px = baseX + sx;
                                        int py = baseY + sy;
                                        if (px >= 0 && px < size && py >= 0 && py < size)
                                        {
                                            int v = py * rowpix + (px * 2);
                                            *(ptr + v) = (byte)(color & 0x00FF);
                                            *(ptr + v + 1) = (byte)((color & 0xFF00) >> 8);
                                        }
                                    }
                                }
                                tx++;
                            }
                        }
                    }
                    else if (type == 0 || type == 8 || type == 16)
                    {
                        // 上半部 2.5D 方塊
                        for (int ty = 0; ty < 24; ty++)
                        {
                            int n = (ty <= 11) ? (ty + 1) * 2 : (23 - ty) * 2;
                            int tx = 24 - n;
                            for (int p = 0; p < n; p++)
                            {
                                ushort color = (ushort)(*(til_ptr++) | (*(til_ptr++) << 8));

                                // 放大繪製
                                int baseX = (int)(offsetX + tx * scale);
                                int baseY = (int)(offsetY + ty * scale);

                                for (int sy = 0; sy < (int)scale + 1; sy++)
                                {
                                    for (int sx = 0; sx < (int)scale + 1; sx++)
                                    {
                                        int px = baseX + sx;
                                        int py = baseY + sy;
                                        if (px >= 0 && px < size && py >= 0 && py < size)
                                        {
                                            int v = py * rowpix + (px * 2);
                                            *(ptr + v) = (byte)(color & 0x00FF);
                                            *(ptr + v + 1) = (byte)((color & 0xFF00) >> 8);
                                        }
                                    }
                                }
                                tx++;
                            }
                        }
                    }
                    else
                    {
                        // 壓縮格式
                        byte x_offset = *(til_ptr++);
                        byte y_offset = *(til_ptr++);
                        byte xxLen = *(til_ptr++);
                        byte yLen = *(til_ptr++);

                        for (int ty = 0; ty < yLen && ty < size; ty++)
                        {
                            int tx = x_offset;
                            byte xSegmentCount = *(til_ptr++);
                            for (int nx = 0; nx < xSegmentCount; nx++)
                            {
                                tx += *(til_ptr++) / 2;
                                int xLen = *(til_ptr++);
                                for (int p = 0; p < xLen; p++)
                                {
                                    ushort color = (ushort)(*(til_ptr++) | (*(til_ptr++) << 8));

                                    // 放大繪製
                                    int baseX = (int)(offsetX + tx * scale);
                                    int baseY = (int)(offsetY + (ty + y_offset) * scale);

                                    for (int sy = 0; sy < (int)scale + 1; sy++)
                                    {
                                        for (int sx = 0; sx < (int)scale + 1; sx++)
                                        {
                                            int px = baseX + sx;
                                            int py = baseY + sy;
                                            if (px >= 0 && px < size && py >= 0 && py < size)
                                            {
                                                int v = py * rowpix + (px * 2);
                                                *(ptr + v) = (byte)(color & 0x00FF);
                                                *(ptr + v + 1) = (byte)((color & 0xFF00) >> 8);
                                            }
                                        }
                                    }
                                    tx++;
                                }
                            }
                        }
                    }
                }

                thumbnail.UnlockBits(bmpData);
                return thumbnail;
            }
            catch
            {
                return CreatePlaceholderThumbnail(tileId);
            }
         }


        // 更新附近群組縮圖（透明編輯模式用）
        private void UpdateNearbyGroupThumbnails(S32Data clickedS32Data, int cellX, int cellY, int radius)
        {
            // 計算點擊位置的遊戲座標
            int clickedGameX = clickedS32Data.SegInfo.nLinBeginX + cellX / 2;
            int clickedGameY = clickedS32Data.SegInfo.nLinBeginY + cellY;

            // 先收集點擊格子的 Layer5 設定（用於判斷群組是否有設定）
            var clickedCellLayer5 = new Dictionary<int, byte>();  // GroupId -> Type
            foreach (var item in clickedS32Data.Layer5)
            {
                if (item.X == cellX && item.Y == cellY)
                {
                    if (!clickedCellLayer5.ContainsKey(item.ObjectIndex))
                    {
                        clickedCellLayer5[item.ObjectIndex] = item.Type;
                    }
                }
            }

            // 使用空間索引收集附近的群組（從 O(n) 降到 O(1)）
            var indexedGroups = _layer4SpatialIndex.CollectNearbyGroups(clickedGameX, clickedGameY, radius);

            // 加入 Layer5 設定資訊
            var nearbyGroups = new Dictionary<int, (int distance, List<(S32Data s32, ObjectTile obj)> objects, bool hasLayer5, byte layer5Type)>();
            foreach (var kvp in indexedGroups)
            {
                int groupId = kvp.Key;
                var (distance, objects) = kvp.Value;
                bool hasLayer5 = clickedCellLayer5.TryGetValue(groupId, out byte layer5Type);
                nearbyGroups[groupId] = (distance, objects, hasLayer5, layer5Type);
            }

            if (nearbyGroups.Count == 0)
            {
                lblGroupThumbnails.Text = string.Format(LocalizationManager.L("Label_NearbyGroupsCount"), 0);
                lvGroupThumbnails.Items.Clear();
                return;
            }

            // 排序：有 Layer5 設定的優先，然後按距離排序
            var sortedGroups = nearbyGroups
                .OrderByDescending(g => g.Value.hasLayer5)  // 有 Layer5 設定的排前面
                .ThenBy(g => g.Value.distance)              // 距離近的排前面
                .ThenBy(g => g.Key)                         // 相同時按 GroupId 排序
                .ToList();

            // Debug: 輸出排序結果
            Console.WriteLine($"[Layer5Edit] clickedCellLayer5 count: {clickedCellLayer5.Count}");
            foreach (var g in sortedGroups.Take(10))
            {
                Console.WriteLine($"  GroupId={g.Key}, hasL5={g.Value.hasLayer5}, dist={g.Value.distance}");
            }

            // 計算有 Layer5 設定的群組數量
            int l5Count = sortedGroups.Count(g => g.Value.hasLayer5);

            // 更新群組縮圖列表
            lblGroupThumbnails.Text = string.Format(LocalizationManager.L("Label_NearbyGroupsLoading"), sortedGroups.Count, l5Count);

            // 取消之前的縮圖產生任務
            if (_groupThumbnailCts != null)
            {
                _groupThumbnailCts.Cancel();
                _groupThumbnailCts.Dispose();
            }
            _groupThumbnailCts = new System.Threading.CancellationTokenSource();
            var cancellationToken = _groupThumbnailCts.Token;

            // 清空快取和搜尋框
            _cachedGroupItems.Clear();
            txtGroupSearch.Text = "";

            int totalGroups = sortedGroups.Count;

            // 在背景執行緒並行產生縮圖
            Task.Run(() =>
            {
                var stopwatch = Stopwatch.StartNew();
                var thumbnailResults = new System.Collections.Concurrent.ConcurrentDictionary<int, (int groupId, int objectCount, Bitmap thumbnail, List<(S32Data s32, ObjectTile obj)> objects, bool hasLayer5, byte layer5Type, int distance)>();

                Parallel.ForEach(sortedGroups, new ParallelOptions { MaxDegreeOfParallelism = Environment.ProcessorCount }, (kvp, state) =>
                {
                    if (cancellationToken.IsCancellationRequested)
                    {
                        state.Stop();
                        return;
                    }

                    int groupId = kvp.Key;
                    var info = kvp.Value;

                    // 生成群組縮圖（傳遞 Layer5 設定以繪製邊框）
                    Bitmap thumbnail = GenerateGroupThumbnail(info.objects, 80, info.hasLayer5, info.layer5Type);

                    if (thumbnail != null && !cancellationToken.IsCancellationRequested)
                    {
                        // DEBUG: 保存縮圖到測試資料夾
                        try
                        {
                            string debugDir = @"C:\workspaces\lineage\L1MapViewer\tests\thumbnails";
                            if (!Directory.Exists(debugDir)) Directory.CreateDirectory(debugDir);
                            string debugPath = Path.Combine(debugDir, $"G{groupId}.png");
                            thumbnail.Save(debugPath, ImageFormat.Png);
                        }
                        catch { }

                        thumbnailResults[groupId] = (groupId, info.objects.Count, thumbnail, info.objects, info.hasLayer5, info.layer5Type, info.distance);
                    }
                });

                stopwatch.Stop();
                long elapsedMs = stopwatch.ElapsedMilliseconds;

                if (cancellationToken.IsCancellationRequested)
                {
                    foreach (var result in thumbnailResults.Values)
                    {
                        result.thumbnail?.Dispose();
                    }
                    return;
                }

                // 在 UI 執行緒更新 ListView（保持排序順序）
                try
                {
                    this.BeginInvoke((MethodInvoker)delegate
                    {
                        if (cancellationToken.IsCancellationRequested) return;

                        ImageList imageList = new ImageList();
                        imageList.ImageSize = new Size(80, 80);
                        imageList.ColorDepth = ColorDepth.Depth32Bit;

                        lvGroupThumbnails.BeginUpdate();  // 暫停重繪
                        try
                        {
                            lvGroupThumbnails.Items.Clear();
                            if (lvGroupThumbnails.LargeImageList != null)
                            {
                                lvGroupThumbnails.LargeImageList.Dispose();
                            }

                            // 批量準備項目
                            var items = new List<IconTextListItem>();
                            int thumbnailIndex = 0;
                            // 按原始排序順序添加（有 Layer5 的優先，然後按距離）
                            foreach (var kvp in sortedGroups)
                            {
                                if (!thumbnailResults.TryGetValue(kvp.Key, out var result)) continue;

                                imageList.Images.Add(result.thumbnail);

                                string distanceText = result.distance == 0 ? "●" : $"D{result.distance}";
                                var item = new IconTextListItem
                                {
                                    Text = $"{distanceText} G{result.groupId} ({result.objectCount})",
                                    ImageIndex = thumbnailIndex,
                                    Image = result.thumbnail  // 直接設定圖片，不依賴 ImageList
                                };

                                // 取得第一個 S32（附近群組通常來自同一個 S32）
                                S32Data firstS32 = result.objects.Count > 0 ? result.objects[0].s32 : null;
                                item.Tag = new GroupThumbnailInfo
                                {
                                    GroupId = result.groupId,
                                    S32Data = firstS32,
                                    S32FileName = firstS32?.FilePath != null ? System.IO.Path.GetFileName(firstS32.FilePath) : "",
                                    DistanceCode = result.distance,
                                    Objects = result.objects.Select(o => o.obj).ToList(),
                                    HasLayer5Setting = result.hasLayer5,
                                    Layer5Type = result.layer5Type
                                };
                                items.Add(item);

                                thumbnailIndex++;
                            }

                            // 快取項目和 ImageList（用於過濾）
                            _cachedGroupItems = items;
                            _cachedGroupImageList = imageList;

                            // 先設定 ImageList，再添加 Items（順序很重要！）
                            lvGroupThumbnails.LargeImageList = imageList;
                            lvGroupThumbnails.Items.AddRange(items);
                        }
                        finally
                        {
                            lvGroupThumbnails.EndUpdate();  // 恢復重繪
                        }
                        lblGroupThumbnails.Text = string.Format(LocalizationManager.L("Label_NearbyGroupsTime"), totalGroups, elapsedMs);
                    });
                }
                catch { }
            });
        }

        // 素材面板 - 雙擊選擇素材
        private void lvMaterials_MouseDoubleClick(object sender, MouseEventArgs e)
        {
            // 使用 HitTest 確認點擊位置
            var hitInfo = lvMaterials.HitTest(e.Location);
            if (hitInfo.Item == null)
                return;

            var item = hitInfo.Item;
            if (item.Tag is string filePath)
            {
                try
                {
                    // 載入素材
                    var library = new L1MapViewer.Helper.MaterialLibrary();
                    var material = library.LoadMaterial(filePath);
                    if (material != null)
                    {
                        StartMaterialPasteMode(material, filePath);
                    }
                    else
                    {
                        WinFormsMessageBox.Show("無法載入素材", "錯誤", MessageBoxButtons.OK, MessageBoxIcon.Error);
                    }
                }
                catch (Exception ex)
                {
                    WinFormsMessageBox.Show($"載入素材失敗: {ex.Message}", "錯誤", MessageBoxButtons.OK, MessageBoxIcon.Error);
                }
            }
        }

        // 素材面板 - 右鍵選單
        private void lvMaterials_MouseUp(object sender, MouseEventArgs e)
        {
            if (e.Buttons != Eto.Forms.MouseButtons.Alternate)
                return;

            if (lvMaterials.SelectedItems.Count == 0)
                return;

            var item = lvMaterials.SelectedItems[0];
            if (!(item.Tag is string filePath))
                return;

            var menu = new ContextMenuStrip();

            // 查看詳情
            var detailItem = new ToolStripMenuItem("查看詳情...");
            detailItem.Click += (s, ev) => ShowMaterialDetails(filePath);
            menu.Items.Add(detailItem);

            // 使用素材
            var useItem = new ToolStripMenuItem("使用素材");
            useItem.Click += (s, ev) =>
            {
                try
                {
                    var library = new L1MapViewer.Helper.MaterialLibrary();
                    var material = library.LoadMaterial(filePath);
                    if (material != null)
                    {
                        StartMaterialPasteMode(material, filePath);
                    }
                }
                catch { }
            };
            menu.Items.Add(useItem);

            menu.Items.Add(new ToolStripSeparator());

            // 重新命名
            var renameItem = new ToolStripMenuItem("重新命名...");
            renameItem.Click += (s, ev) => RenameMaterial(filePath, item);
            menu.Items.Add(renameItem);

            // 複製檔案路徑
            var copyPathItem = new ToolStripMenuItem("複製檔案路徑");
            copyPathItem.Click += (s, ev) =>
            {
                ClipboardHelper.SetText(filePath);
                toolStripStatusLabel1.Text = "已複製路徑到剪貼簿";
            };
            menu.Items.Add(copyPathItem);

            // 匯出（另存新檔）
            var exportItem = new ToolStripMenuItem("匯出素材...");
            exportItem.Click += (s, ev) => ExportMaterial(filePath);
            menu.Items.Add(exportItem);

            menu.Items.Add(new ToolStripSeparator());

            // 刪除素材
            var deleteItem = new ToolStripMenuItem("刪除素材");
            deleteItem.Click += (s, ev) =>
            {
                if (WinFormsMessageBox.Show($"確定要刪除素材 \"{item.Text}\" 嗎？", "確認刪除",
                    MessageBoxButtons.YesNo, MessageBoxIcon.Warning) == DialogResult.Yes)
                {
                    var library = new L1MapViewer.Helper.MaterialLibrary();
                    if (library.DeleteMaterial(filePath))
                    {
                        RefreshMaterialsList();
                        toolStripStatusLabel1.Text = $"已刪除素材: {item.Text}";
                    }
                }
            };
            menu.Items.Add(deleteItem);

            menu.Show(lvMaterials, e.Location);
        }

        // 拖放進入事件
        private void lvMaterials_DragEnter(object sender, DragEventArgs e)
        {
            if (e.Data.GetDataPresent(DataFormats.FileDrop))
            {
                string[] files = e.Data.GetFileDropData();
                // 檢查是否有 .fs32p 檔案
                if (files.Any(f => f.EndsWith(".fs32p", StringComparison.OrdinalIgnoreCase)))
                {
                    e.SetEffect(DragDropEffects.Copy);
                    return;
                }
            }
            e.SetEffect(DragDropEffects.None);
        }

        // 拖放經過事件（必須持續設定 Effect 才能允許放下）
        private void lvMaterials_DragOver(object sender, DragEventArgs e)
        {
            if (e.Data.GetDataPresent(DataFormats.FileDrop))
            {
                string[] files = e.Data.GetFileDropData();
                if (files.Any(f => f.EndsWith(".fs32p", StringComparison.OrdinalIgnoreCase)))
                {
                    e.SetEffect(DragDropEffects.Copy);
                    return;
                }
            }
            e.SetEffect(DragDropEffects.None);
        }

        // 拖放放下事件
        private void lvMaterials_DragDrop(object sender, DragEventArgs e)
        {
            if (!e.Data.GetDataPresent(DataFormats.FileDrop))
                return;

            string[] files = e.Data.GetFileDropData();
            var library = new L1MapViewer.Helper.MaterialLibrary();
            int imported = 0;

            foreach (var file in files)
            {
                if (!file.EndsWith(".fs32p", StringComparison.OrdinalIgnoreCase))
                    continue;

                try
                {
                    // 驗證檔案
                    if (!L1MapViewer.CLI.Fs3pParser.IsValidFs3pFile(file))
                    {
                        WinFormsMessageBox.Show($"無效的素材檔案: {Path.GetFileName(file)}", "錯誤", MessageBoxButtons.OK, MessageBoxIcon.Warning);
                        continue;
                    }

                    // 加到最近使用
                    library.AddToRecent(file);
                    imported++;
                }
                catch (Exception ex)
                {
                    WinFormsMessageBox.Show($"匯入失敗: {Path.GetFileName(file)}\n{ex.Message}", "錯誤", MessageBoxButtons.OK, MessageBoxIcon.Error);
                }
            }

            if (imported > 0)
            {
                RefreshMaterialsList();
                toolStripStatusLabel1.Text = $"已匯入 {imported} 個素材";
            }
        }

        // 匯入素材選單點擊事件
        private void importMaterialToolStripMenuItem_Click(object sender, EventArgs e)
        {
            using (var ofd = new OpenFileDialog())
            {
                ofd.Filter = "素材檔案|*.fs32p|所有檔案|*.*";
                ofd.Title = "匯入素材";
                ofd.Multiselect = true;

                if (ofd.ShowDialog(this) != DialogResult.Ok)
                    return;

                var library = new L1MapViewer.Helper.MaterialLibrary();
                int imported = 0;

                foreach (var file in ofd.FileNames)
                {
                    try
                    {
                        if (!L1MapViewer.CLI.Fs3pParser.IsValidFs3pFile(file))
                        {
                            WinFormsMessageBox.Show($"無效的素材檔案: {Path.GetFileName(file)}", "錯誤", MessageBoxButtons.OK, MessageBoxIcon.Warning);
                            continue;
                        }

                        library.AddToRecent(file);
                        imported++;
                    }
                    catch (Exception ex)
                    {
                        WinFormsMessageBox.Show($"匯入失敗: {Path.GetFileName(file)}\n{ex.Message}", "錯誤", MessageBoxButtons.OK, MessageBoxIcon.Error);
                    }
                }

                if (imported > 0)
                {
                    RefreshMaterialsList();
                    toolStripStatusLabel1.Text = $"已匯入 {imported} 個素材";
                }
            }
        }

        // 匯入地圖包到新地圖選單點擊事件
        private void importFs32ToNewMapToolStripMenuItem_Click(object sender, EventArgs e)
        {
            // 檢查是否已開啟天堂客戶端
            if (string.IsNullOrEmpty(Share.LineagePath) || !Directory.Exists(Share.LineagePath))
            {
                WinFormsMessageBox.Show(
                    LocalizationManager.L("ImportNewMap_PleaseOpenClient"),
                    LocalizationManager.L("ImportNewMap_Title"),
                    MessageBoxButtons.OK,
                    MessageBoxIcon.Warning);
                return;
            }

            // 選擇 fs32 檔案
            using (var openDialog = new OpenFileDialog())
            {
                openDialog.Filter = "FS32 地圖包|*.fs32|所有檔案|*.*";
                openDialog.Title = LocalizationManager.L("ImportNewMap_SelectFile");

                if (openDialog.ShowDialog(this) != DialogResult.Ok)
                    return;

                string fs32FilePath = openDialog.FileName;

                // 輸入地圖編號
                string mapIdInput = ShowInputDialog(
                    LocalizationManager.L("ImportNewMap_Title"),
                    LocalizationManager.L("ImportNewMap_EnterMapId"),
                    "");

                if (string.IsNullOrWhiteSpace(mapIdInput))
                    return;

                // 驗證地圖編號是否為數字
                if (!int.TryParse(mapIdInput.Trim(), out int mapIdNumber))
                {
                    WinFormsMessageBox.Show(
                        LocalizationManager.L("ImportNewMap_InvalidMapId"),
                        LocalizationManager.L("ImportNewMap_Title"),
                        MessageBoxButtons.OK,
                        MessageBoxIcon.Warning);
                    return;
                }

                string mapId = mapIdNumber.ToString();
                string mapPath = Path.Combine(Share.LineagePath, "map", mapId);

                // 檢查地圖資料夾是否已存在
                if (Directory.Exists(mapPath))
                {
                    // 地圖已存在，詢問是否使用既有匯入流程
                    var result = WinFormsMessageBox.Show(
                        string.Format(LocalizationManager.L("ImportNewMap_MapExists"), mapId),
                        LocalizationManager.L("ImportNewMap_Title"),
                        MessageBoxButtons.YesNo,
                        MessageBoxIcon.Question);

                    if (result == DialogResult.Yes)
                    {
                        // 使用既有匯入流程：先切換到該地圖，再執行匯入
                        SwitchToMapAndImportFs32(mapId, fs32FilePath);
                    }
                    return;
                }

                // 建立新地圖資料夾並匯入
                try
                {
                    toolStripStatusLabel1.Text = LocalizationManager.L("ImportNewMap_CreatingFolder");
                    ApplicationHelper.DoEvents();

                    // 建立地圖資料夾
                    Directory.CreateDirectory(mapPath);

                    toolStripStatusLabel1.Text = LocalizationManager.L("ImportNewMap_Importing");
                    ApplicationHelper.DoEvents();

                    // 載入 fs32
                    var fs32 = Fs32Parser.ParseFile(fs32FilePath);
                    if (fs32 == null || fs32.Blocks.Count == 0)
                    {
                        // 刪除剛建立的空資料夾
                        try { Directory.Delete(mapPath); } catch { }
                        WinFormsMessageBox.Show("無效的 fs32 檔案或不包含任何區塊", "錯誤", MessageBoxButtons.OK, MessageBoxIcon.Error);
                        return;
                    }

                    // 處理 Tiles（如果有）
                    TileMappingResult tileMapping = null;
                    if (fs32.Tiles.Count > 0)
                    {
                        tileMapping = ProcessFs32Tiles(fs32);
                        if (tileMapping == null)
                        {
                            // 用戶取消，刪除資料夾
                            try { Directory.Delete(mapPath); } catch { }
                            return;
                        }
                    }

                    // 直接寫入 S32 區塊（因為是新地圖，不需要計算 MapInfo）
                    int importedCount = 0;
                    var errors = new List<string>();

                    foreach (var block in fs32.Blocks)
                    {
                        try
                        {
                            if (block.S32Data == null || block.S32Data.Length == 0)
                            {
                                continue;
                            }

                            // 解析 S32 資料
                            var s32Data = S32Parser.Parse(block.S32Data);
                            if (s32Data == null)
                            {
                                errors.Add($"區塊 {block.BlockX:X4}{block.BlockY:X4}: 解析失敗");
                                continue;
                            }

                            // 應用 TileId 映射
                            if (tileMapping != null && tileMapping.IdMapping.Count > 0)
                            {
                                ApplyTileMappingToS32(s32Data, tileMapping);
                            }

                            // 寫入 S32 檔案
                            string s32FileName = $"{block.BlockX:X4}{block.BlockY:X4}.s32";
                            string s32FilePath = Path.Combine(mapPath, s32FileName);
                            S32Writer.Write(s32Data, s32FilePath);
                            importedCount++;
                        }
                        catch (Exception ex)
                        {
                            errors.Add($"區塊 {block.BlockX:X4}{block.BlockY:X4}: {ex.Message}");
                        }
                    }

                    // 顯示結果
                    string resultMessage = string.Format(LocalizationManager.L("ImportNewMap_Success"), mapId) +
                                           $"\n\n匯入 {importedCount} 個區塊";
                    if (fs32.Tiles.Count > 0)
                    {
                        resultMessage += $", {fs32.Tiles.Count} 個圖塊";
                    }
                    if (errors.Count > 0)
                    {
                        resultMessage += $"\n\n⚠️ {errors.Count} 個區塊發生錯誤";
                    }

                    WinFormsMessageBox.Show(resultMessage, LocalizationManager.L("ImportNewMap_Title"),
                        MessageBoxButtons.OK, MessageBoxIcon.Information);

                    toolStripStatusLabel1.Text = string.Format(LocalizationManager.L("ImportNewMap_Success"), mapId);

                    // 重新載入地圖列表
                    if (!string.IsNullOrEmpty(Share.LineagePath))
                    {
                        LoadMap(Share.LineagePath);
                    }
                }
                catch (Exception ex)
                {
                    WinFormsMessageBox.Show(
                        string.Format(LocalizationManager.L("ImportNewMap_Failed"), ex.Message),
                        LocalizationManager.L("ImportNewMap_Title"),
                        MessageBoxButtons.OK,
                        MessageBoxIcon.Error);
                }
            }
        }

        // 切換到指定地圖並匯入 fs32
        private void SwitchToMapAndImportFs32(string mapId, string fs32FilePath)
        {
            // 先切換到該地圖
            for (int i = 0; i < lstMaps.Items.Count; i++)
            {
                string itemText = lstMaps.Items[i].ToString();
                string itemMapId = itemText.Contains("-") ? itemText.Split('-')[0].Trim() : itemText;

                if (itemMapId == mapId)
                {
                    lstMaps.SelectedIndex = i;
                    ApplicationHelper.DoEvents();

                    // 等待地圖載入完成
                    System.Threading.Thread.Sleep(500);
                    ApplicationHelper.DoEvents();

                    // 執行匯入
                    ImportFs32ToCurrentMapWithFile(fs32FilePath);
                    return;
                }
            }

            // 如果在列表中找不到，嘗試直接設定 MapId
            WinFormsMessageBox.Show($"找不到地圖 {mapId}，請手動選擇地圖後再匯入",
                LocalizationManager.L("ImportNewMap_Title"),
                MessageBoxButtons.OK, MessageBoxIcon.Information);
        }

        // 使用指定檔案匯入 fs32 到當前地圖
        private void ImportFs32ToCurrentMapWithFile(string fs32FilePath)
        {
            if (string.IsNullOrEmpty(_document.MapId))
            {
                WinFormsMessageBox.Show("請先載入地圖", "提示", MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            string mapPath = Path.Combine(Share.LineagePath, "Map", _document.MapId);

            try
            {
                // 1. 載入 fs32
                toolStripStatusLabel1.Text = "正在載入 fs32...";
                ApplicationHelper.DoEvents();

                var fs32 = Fs32Parser.ParseFile(fs32FilePath);
                if (fs32 == null || fs32.Blocks.Count == 0)
                {
                    WinFormsMessageBox.Show("無效的 fs32 檔案或不包含任何區塊", "錯誤", MessageBoxButtons.OK, MessageBoxIcon.Error);
                    return;
                }

                // 2. 統計 Layer8 項目並顯示警告
                int totalL8Items = 0;
                HashSet<int> l8SprIds = new HashSet<int>();
                foreach (var block in fs32.Blocks)
                {
                    try
                    {
                        var tempS32 = S32Parser.Parse(block.S32Data);
                        if (tempS32?.Layer8 != null)
                        {
                            totalL8Items += tempS32.Layer8.Count;
                            foreach (var l8 in tempS32.Layer8)
                                l8SprIds.Add(l8.SprId);
                        }
                    }
                    catch { }
                }

                if (totalL8Items > 0)
                {
                    string l8Warning = $"⚠️ 警告：包含 {totalL8Items} 個 Layer8 項目 (使用 {l8SprIds.Count} 種 SPR)\n\n";
                    if (fs32.Sprs.Count > 0)
                    {
                        l8Warning += $"fs32 已包含 {fs32.Sprs.Count} 個 SPR 檔案\n";
                        l8Warning += "• spr/file/*.spr → 匯入至 Client\n";
                        l8Warning += "• spr/code/*.sprtxt → 加入您的 list.spr 編碼檔\n";
                    }
                    else
                    {
                        l8Warning += "fs32 不包含 SPR 檔案\n請自行準備對應的 SPR 編碼檔\n";
                    }
                    l8Warning += "\n否則可能導致遊戲閃退！\n\n確定要繼續匯入嗎？";

                    var l8Result = WinFormsMessageBox.Show(l8Warning, "Layer8 警告",
                        MessageBoxButtons.YesNo, MessageBoxIcon.Warning);
                    if (l8Result != DialogResult.Yes)
                        return;
                }

                // 3. 顯示匯入資訊並選擇匯入模式
                string infoMessage = $"fs32 地圖包資訊：\n\n" +
                                     $"• 來源地圖: {fs32.SourceMapId}\n" +
                                     $"• 區塊數量: {fs32.Blocks.Count}\n" +
                                     $"• 圖塊數量: {fs32.Tiles.Count}\n" +
                                     $"• SPR 數量: {fs32.Sprs.Count}\n\n" +
                                     $"將匯入至當前地圖: {_document.MapId}";

                var importModeResult = ShowImportModeDialog(infoMessage);

                if (importModeResult == null)
                    return;

                bool isFullReplace = importModeResult.Value;

                // 全部取代需要二次確認
                if (isFullReplace)
                {
                    var warningResult = WinFormsMessageBox.Show(
                        "⚠️ 警告：全部取代模式 ⚠️\n\n" +
                        "這將會刪除當前地圖的所有既有區塊！\n" +
                        "整張地圖可能會消失，只剩下匯入的區塊。\n\n" +
                        "此操作無法復原！\n\n" +
                        "確定要繼續嗎？",
                        "危險操作確認",
                        MessageBoxButtons.YesNo,
                        MessageBoxIcon.Warning,
                        MessageBoxDefaultButton.Button2);

                    if (warningResult != DialogResult.Yes)
                        return;
                }

                // 3. 處理 Tiles（如果有）
                TileMappingResult tileMapping = null;
                if (fs32.Tiles.Count > 0)
                {
                    tileMapping = ProcessFs32Tiles(fs32);
                    if (tileMapping == null)
                        return;
                }

                // 4. 全部取代模式：刪除既有 S32 檔案
                if (isFullReplace)
                {
                    toolStripStatusLabel1.Text = "正在刪除既有區塊...";
                    ApplicationHelper.DoEvents();

                    var existingS32Files = Directory.GetFiles(mapPath, "*.s32");
                    foreach (var file in existingS32Files)
                    {
                        try { File.Delete(file); } catch { }
                    }
                }

                // 5. 解析並寫入 S32 區塊
                toolStripStatusLabel1.Text = "正在匯入區塊...";
                ApplicationHelper.DoEvents();

                int importedCount = 0;
                var errors = new List<string>();

                // 取得 MapInfo
                int mapMinBlockX = 0x7FFF;
                int mapMinBlockY = 0x7FFF;
                int mapBlockCountX = 1;

                if (_document.MapInfo != null)
                {
                    mapMinBlockX = _document.MapInfo.nMinBlockX;
                    mapMinBlockY = _document.MapInfo.nMinBlockY;
                    mapBlockCountX = _document.MapInfo.nBlockCountX;
                }
                else if (_document.S32Files.Count > 0)
                {
                    var firstS32 = _document.S32Files.Values.First();
                    if (firstS32.SegInfo != null)
                    {
                        mapMinBlockX = firstS32.SegInfo.nMapMinBlockX;
                        mapMinBlockY = firstS32.SegInfo.nMapMinBlockY;
                        mapBlockCountX = firstS32.SegInfo.nMapBlockCountX;
                    }
                }

                foreach (var block in fs32.Blocks)
                {
                    try
                    {
                        if (block.S32Data == null || block.S32Data.Length == 0)
                            continue;

                        var s32Data = S32Parser.Parse(block.S32Data);
                        if (s32Data == null)
                        {
                            errors.Add($"區塊 {block.BlockX:X4}{block.BlockY:X4}: 解析失敗");
                            continue;
                        }

                        // 更新 SegInfo
                        if (s32Data.SegInfo != null)
                        {
                            s32Data.SegInfo.nMapMinBlockX = mapMinBlockX;
                            s32Data.SegInfo.nMapMinBlockY = mapMinBlockY;
                            s32Data.SegInfo.nMapBlockCountX = mapBlockCountX;
                        }

                        // 應用 TileId 映射
                        if (tileMapping != null && tileMapping.IdMapping.Count > 0)
                        {
                            ApplyTileMappingToS32(s32Data, tileMapping);
                        }

                        string s32FileName = $"{block.BlockX:X4}{block.BlockY:X4}.s32";
                        string s32FilePath = Path.Combine(mapPath, s32FileName);
                        S32Writer.Write(s32Data, s32FilePath);
                        importedCount++;
                    }
                    catch (Exception ex)
                    {
                        errors.Add($"區塊 {block.BlockX:X4}{block.BlockY:X4}: {ex.Message}");
                    }
                }

                // 6. 重新載入地圖
                ReloadCurrentMap();

                // 7. 顯示結果
                string resultMessage = $"匯入完成！\n\n" +
                                       $"成功匯入 {importedCount} 個區塊";
                if (fs32.Tiles.Count > 0)
                    resultMessage += $"\n處理 {fs32.Tiles.Count} 個圖塊";
                if (errors.Count > 0)
                    resultMessage += $"\n\n⚠️ {errors.Count} 個區塊發生錯誤";

                WinFormsMessageBox.Show(resultMessage, "匯入完成", MessageBoxButtons.OK, MessageBoxIcon.Information);
                toolStripStatusLabel1.Text = $"已匯入 {importedCount} 個區塊";
            }
            catch (Exception ex)
            {
                WinFormsMessageBox.Show($"匯入失敗: {ex.Message}", "錯誤", MessageBoxButtons.OK, MessageBoxIcon.Error);
            }
        }

        // 重新命名素材
        private void RenameMaterial(string filePath, IconTextListItem listItem)
        {
            try
            {
                var material = L1MapViewer.CLI.Fs3pParser.ParseFile(filePath);
                if (material == null)
                {
                    WinFormsMessageBox.Show("無法載入素材", "錯誤", MessageBoxButtons.OK, MessageBoxIcon.Error);
                    return;
                }

                string currentName = material.Name ?? "未命名";
                string newName = ShowInputDialog("重新命名素材", "請輸入新的素材名稱:", currentName);

                if (string.IsNullOrWhiteSpace(newName) || newName == currentName)
                    return;

                // 更新素材名稱
                material.Name = newName;

                // 重新寫入檔案
                L1MapViewer.CLI.Fs3pWriter.Write(material, filePath);

                // 更新列表顯示
                listItem.Text = newName;
                toolStripStatusLabel1.Text = $"素材已重新命名為: {newName}";
            }
            catch (Exception ex)
            {
                WinFormsMessageBox.Show($"重新命名失敗: {ex.Message}", "錯誤", MessageBoxButtons.OK, MessageBoxIcon.Error);
            }
        }

        // 簡易輸入對話框
        private string ShowInputDialog(string title, string prompt, string defaultValue)
        {
            using (var form = new Form())
            {
                form.Text = title;
                form.Size = new Size(350, 150);
                form.SetFormBorderStyle(FormBorderStyle.FixedDialog);
                form.SetStartPosition(FormStartPosition.CenterParent);
                form.SetMaximizeBox(false);
                form.SetMinimizeBox(false);

                var label = new Label { Text = prompt, Width = 310 };
                label.SetLocation(new Point(10, 15));
                var textBox = new TextBox { Text = defaultValue, Width = 310 };
                textBox.SetLocation(new Point(10, 40));
                var okButton = new Button { Text = "確定", Width = 80, DialogResult = DialogResult.Ok };
                okButton.SetLocation(new Point(150, 75));
                var cancelButton = new Button { Text = "取消", Width = 80, DialogResult = DialogResult.Cancel };
                cancelButton.SetLocation(new Point(240, 75));

                form.GetControls().Add(label);
                form.GetControls().Add(textBox);
                form.GetControls().Add(okButton);
                form.GetControls().Add(cancelButton);
                form.AcceptButton = okButton;
                form.CancelButton = cancelButton;

                return form.ShowDialog(this) == DialogResult.Ok ? textBox.Text : defaultValue;
            }
        }

        // 匯入模式選擇對話框 (返回 true=全部取代, false=部份取代, null=取消)
        private bool? ShowImportModeDialog(string infoMessage)
        {
            using (var form = new Form())
            {
                form.Text = "選擇匯入模式";
                form.Size = new Size(420, 220);
                form.SetFormBorderStyle(FormBorderStyle.FixedDialog);
                form.SetStartPosition(FormStartPosition.CenterParent);
                form.SetMaximizeBox(false);
                form.SetMinimizeBox(false);

                var lblInfo = new Label
                {
                    Text = infoMessage,
                    Location = new Point(15, 15),
                    Size = new Size(380, 100),
                    AutoSize = false
                };
                form.GetControls().Add(lblInfo);

                var btnPartial = new Button
                {
                    Text = "部份取代（推薦）",
                    Location = new Point(30, 130),
                    Size = new Size(140, 35),
                    DialogResult = DialogResult.Yes
                };
                form.GetControls().Add(btnPartial);

                var btnFull = new Button
                {
                    Text = "全部取代",
                    Location = new Point(180, 130),
                    Size = new Size(100, 35),
                    DialogResult = DialogResult.No
                };
                form.GetControls().Add(btnFull);

                var btnCancel = new Button
                {
                    Text = "取消",
                    Location = new Point(290, 130),
                    Size = new Size(80, 35),
                    DialogResult = DialogResult.Cancel
                };
                form.GetControls().Add(btnCancel);

                form.AcceptButton = btnPartial;
                form.CancelButton = btnCancel;

                var result = form.ShowDialog(this);
                if (result == DialogResult.Cancel)
                    return null;
                return result == DialogResult.No; // No = 全部取代
            }
        }

        // 匯出素材
        private void ExportMaterial(string filePath)
        {
            try
            {
                using (var sfd = new SaveFileDialog())
                {
                    sfd.Filter = "素材檔案|*.fs32p";
                    sfd.Title = "匯出素材";
                    sfd.FileName = Path.GetFileName(filePath);

                    if (sfd.ShowDialog(this) == DialogResult.Ok)
                    {
                        File.Copy(filePath, sfd.FileName, true);
                        toolStripStatusLabel1.Text = $"素材已匯出至: {sfd.FileName}";
                    }
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"[Export] Error: {ex}");
                        WinFormsMessageBox.Show($"匯出失敗: {ex.Message}\n\n{ex.StackTrace}", "錯誤", MessageBoxButtons.OK, MessageBoxIcon.Error);
            }
        }

        // 顯示素材詳細資料
        private void ShowMaterialDetails(string filePath)
        {
            try
            {
                var material = L1MapViewer.CLI.Fs3pParser.ParseFile(filePath);
                if (material == null)
                {
                    WinFormsMessageBox.Show("無法載入素材", "錯誤", MessageBoxButtons.OK, MessageBoxIcon.Error);
                    return;
                }

                var sb = new System.Text.StringBuilder();
                sb.AppendLine($"素材名稱: {material.Name}");
                sb.AppendLine($"檔案路徑: {filePath}");
                sb.AppendLine();
                sb.AppendLine($"尺寸: {material.Width} x {material.Height}");
                sb.AppendLine($"原點偏移: ({material.OriginOffsetX}, {material.OriginOffsetY})");
                sb.AppendLine();

                // Layer 資訊
                sb.AppendLine("=== 圖層資料 ===");
                if (material.HasLayer1)
                    sb.AppendLine($"Layer1 (地板): {material.Layer1Items.Count} 項");
                if (material.HasLayer2)
                    sb.AppendLine($"Layer2 (裝飾): {material.Layer2Items.Count} 項");
                if (material.HasLayer3)
                    sb.AppendLine($"Layer3 (屬性): {material.Layer3Items.Count} 項");
                if (material.HasLayer4)
                    sb.AppendLine($"Layer4 (物件): {material.Layer4Items.Count} 項");

                if (!material.HasLayer1 && !material.HasLayer2 && !material.HasLayer3 && !material.HasLayer4)
                    sb.AppendLine("(無圖層資料)");

                // Layer1 詳細列表
                if (material.HasLayer1 && material.Layer1Items.Count > 0)
                {
                    sb.AppendLine();
                    sb.AppendLine("=== Layer1 明細 (地板) ===");
                    sb.AppendLine("  X\t  Y\tIndexId\tTileId");
                    sb.AppendLine("────────────────────────────────");
                    foreach (var item in material.Layer1Items.OrderBy(i => i.RelativeY).ThenBy(i => i.RelativeX))
                    {
                        sb.AppendLine($"{item.RelativeX,4}\t{item.RelativeY,4}\t{item.IndexId,4}\t{item.TileId,6}");
                    }
                }

                // Layer2 詳細列表
                if (material.HasLayer2 && material.Layer2Items.Count > 0)
                {
                    sb.AppendLine();
                    sb.AppendLine("=== Layer2 明細 (裝飾) ===");
                    sb.AppendLine("  X\t  Y\tIndexId\tTileId\tUK");
                    sb.AppendLine("────────────────────────────────────────");
                    foreach (var item in material.Layer2Items.OrderBy(i => i.RelativeY).ThenBy(i => i.RelativeX))
                    {
                        sb.AppendLine($"{item.RelativeX,4}\t{item.RelativeY,4}\t{item.IndexId,4}\t{item.TileId,6}\t{item.UK,3}");
                    }
                }

                // Layer4 詳細列表
                if (material.HasLayer4 && material.Layer4Items.Count > 0)
                {
                    sb.AppendLine();
                    sb.AppendLine("=== Layer4 明細 (物件) ===");
                    sb.AppendLine("  X\t  Y\tGroupId\tLayer\tIndexId\tTileId");
                    sb.AppendLine("──────────────────────────────────────────────────");
                    foreach (var item in material.Layer4Items.OrderBy(i => i.GroupId).ThenBy(i => i.Layer))
                    {
                        sb.AppendLine($"{item.RelativeX,4}\t{item.RelativeY,4}\t{item.GroupId,5}\t{item.Layer,3}\t{item.IndexId,4}\t{item.TileId,6}");
                    }
                }

                sb.AppendLine();

                // Tile 資訊
                sb.AppendLine("=== Tile 資料 ===");
                if (material.Tiles.Count > 0)
                {
                    sb.AppendLine($"包含 {material.Tiles.Count} 個 Tiles:");
                    foreach (var tile in material.Tiles.OrderBy(t => t.Key))
                    {
                        sb.AppendLine($"  - Tile {tile.Key} ({tile.Value.TilData?.Length ?? 0} bytes)");
                    }
                }
                else
                {
                    sb.AppendLine("(未包含 Tile 資料)");
                }

                sb.AppendLine();

                // 使用的 TileId 統計
                var usedTileIds = new HashSet<int>();
                foreach (var item in material.Layer1Items)
                    if (item.TileId > 0) usedTileIds.Add(item.TileId);
                foreach (var item in material.Layer2Items)
                    if (item.TileId > 0) usedTileIds.Add(item.TileId);
                foreach (var item in material.Layer4Items)
                    if (item.TileId > 0) usedTileIds.Add(item.TileId);

                if (usedTileIds.Count > 0)
                {
                    sb.AppendLine($"=== 使用的 TileId ({usedTileIds.Count} 個) ===");
                    var sortedIds = usedTileIds.OrderBy(x => x).ToList();
                    for (int i = 0; i < sortedIds.Count; i += 10)
                    {
                        var batch = sortedIds.Skip(i).Take(10);
                        sb.AppendLine(string.Join(", ", batch));
                    }
                }

                // Metadata
                sb.AppendLine();
                sb.AppendLine("=== 中繼資料 ===");
                if (material.CreatedTime > 0)
                {
                    var created = DateTimeOffset.FromUnixTimeSeconds(material.CreatedTime).LocalDateTime;
                    sb.AppendLine($"建立時間: {created:yyyy-MM-dd HH:mm:ss}");
                }
                if (material.ModifiedTime > 0)
                {
                    var modified = DateTimeOffset.FromUnixTimeSeconds(material.ModifiedTime).LocalDateTime;
                    sb.AppendLine($"修改時間: {modified:yyyy-MM-dd HH:mm:ss}");
                }
                if (material.Tags.Count > 0)
                {
                    sb.AppendLine($"標籤: {string.Join(", ", material.Tags)}");
                }

                // 使用可複製的對話框
                using (var detailForm = new Form())
                {
                    detailForm.Text = $"素材詳情 - {material.Name}";
                    detailForm.Size = new Size(700, 600);
                    detailForm.SetStartPosition(FormStartPosition.CenterParent);
                    detailForm.SetFormBorderStyle(FormBorderStyle.Sizable);
                    detailForm.MinimumSize = new Size(500, 400);

                    var textBox = new TextBox
                    {
                        Multiline = true,
                        ReadOnly = true,
                        ScrollBars = ScrollBars.Both,
                        Dock = DockStyle.Fill,
                        Font = new Font("Consolas", 9),
                        Text = sb.ToString(),
                        SelectionStart = 0,
                        SelectionLength = 0
                    };

                    var btnPanel = new Panel
                    {
                        Dock = DockStyle.Bottom,
                        Height = 40
                    };

                    var btnCopy = new Button
                    {
                        Text = "複製全部",
                        Size = new Size(80, 28),
                        Location = new Point(10, 6)
                    };
                    btnCopy.Click += (s, ev) =>
                    {
                        ClipboardHelper.SetText(sb.ToString());
                        toolStripStatusLabel1.Text = "已複製素材詳情到剪貼簿";
                    };

                    var btnClose = new Button
                    {
                        Text = "關閉",
                        Size = new Size(80, 28),
                        Location = new Point(100, 6),
                        DialogResult = DialogResult.Ok
                    };

                    btnPanel.GetControls().Add(btnCopy);
                    btnPanel.GetControls().Add(btnClose);
                    detailForm.GetControls().Add(textBox);
                    detailForm.GetControls().Add(btnPanel);
                    detailForm.AcceptButton = btnClose;

                    detailForm.ShowDialog(this);
                }
            }
            catch (Exception ex)
            {
                WinFormsMessageBox.Show($"讀取素材失敗: {ex.Message}", "錯誤", MessageBoxButtons.OK, MessageBoxIcon.Error);
            }
        }

        // 素材面板 - 更多按鈕
        private void btnMoreMaterials_Click(object sender, EventArgs e)
        {
            using (var browser = new L1MapViewer.Forms.MaterialBrowserForm())
            {
                if (browser.ShowDialog(this) == DialogResult.Ok && browser.SelectedMaterial != null)
                {
                    // 進入素材貼上預覽模式
                    StartMaterialPasteMode(browser.SelectedMaterial, browser.SelectedFilePath);
                }
            }
        }

        // 在指定位置貼上素材
        private void PasteMaterialAtPosition(int gameX, int gameY)
        {
            if (_pendingMaterial == null)
                return;

            try
            {
                var material = _pendingMaterial;

                // 計算貼上原點（Layer1 座標）- 點擊位置為素材底部
                int pasteOriginX = gameX * 2;
                int pasteOriginY = gameY;

                // 檢查並修正 RelativeX/Y 偏移（舊素材可能沒有正規化）
                // 計算所有圖層的 RelativeX/Y 範圍
                int minRelX = int.MaxValue;
                int minRelY = int.MaxValue;
                int maxRelY = int.MinValue;

                foreach (var item in material.Layer1Items)
                {
                    if (item.RelativeX < minRelX) minRelX = item.RelativeX;
                    if (item.RelativeY < minRelY) minRelY = item.RelativeY;
                    if (item.RelativeY > maxRelY) maxRelY = item.RelativeY;
                }
                foreach (var item in material.Layer2Items)
                {
                    if (item.RelativeX < minRelX) minRelX = item.RelativeX;
                    if (item.RelativeY < minRelY) minRelY = item.RelativeY;
                    if (item.RelativeY > maxRelY) maxRelY = item.RelativeY;
                }
                foreach (var item in material.Layer3Items)
                {
                    // Layer3 使用不同座標系統，暫時跳過
                }
                foreach (var item in material.Layer4Items)
                {
                    if (item.RelativeX < minRelX) minRelX = item.RelativeX;
                    if (item.RelativeY < minRelY) minRelY = item.RelativeY;
                    if (item.RelativeY > maxRelY) maxRelY = item.RelativeY;
                }

                // 如果沒有任何項目，設為 0
                if (minRelX == int.MaxValue) minRelX = 0;
                if (minRelY == int.MaxValue) minRelY = 0;
                if (maxRelY == int.MinValue) maxRelY = 0;

                // 偏移修正值 - 使用 maxRelY 作為基準點（素材底部對齊點擊位置）
                int offsetFixX = minRelX;
                int offsetFixY = maxRelY;

                int layer1Count = 0, layer2Count = 0, layer3Count = 0, layer4Count = 0;
                int skippedCount = 0;

                // 建立 Undo 記錄
                var undoAction = new UndoAction
                {
                    Description = $"貼上素材 {material.Name}"
                };

                // 貼上 Layer1 資料（地板）
                if (material.HasLayer1)
                {
                    foreach (var item in material.Layer1Items)
                    {
                        // 套用偏移修正
                        int targetGlobalX = pasteOriginX + item.RelativeX - offsetFixX;
                        int targetGlobalY = pasteOriginY + item.RelativeY - offsetFixY;
                        int targetGameX = targetGlobalX / 2;
                        int targetGameY = targetGlobalY;

                        S32Data targetS32 = GetS32DataByGameCoords(targetGameX, targetGameY);
                        if (targetS32 == null)
                        {
                            skippedCount++;
                            continue;
                        }

                        int localX = targetGlobalX - targetS32.SegInfo.nLinBeginX * 2;
                        int localY = targetGlobalY - targetS32.SegInfo.nLinBeginY;

                        if (localX < 0 || localX >= 128 || localY < 0 || localY >= 64)
                        {
                            skippedCount++;
                            continue;
                        }

                        var oldCell = targetS32.Layer1[localY, localX];
                        undoAction.ModifiedLayer1.Add(new UndoLayer1Info
                        {
                            S32FilePath = targetS32.FilePath,
                            LocalX = localX,
                            LocalY = localY,
                            OldTileId = oldCell?.TileId ?? 0,
                            OldIndexId = oldCell?.IndexId ?? 0,
                            NewTileId = item.TileId,
                            NewIndexId = item.IndexId
                        });

                        targetS32.Layer1[localY, localX] = new TileCell
                        {
                            X = localX,
                            Y = localY,
                            TileId = item.TileId,
                            IndexId = item.IndexId
                        };
                        if (item.TileId > 0) layer1Count++;
                        targetS32.IsModified = true;
                    }
                }

                // 貼上 Layer3 資料（屬性）
                if (material.HasLayer3)
                {
                    foreach (var item in material.Layer3Items)
                    {
                        int targetGlobalX = pasteOriginX + item.RelativeX * 2;  // Layer3 是遊戲座標
                        int targetGlobalY = pasteOriginY + item.RelativeY;
                        int targetGameX = targetGlobalX / 2;
                        int targetGameY = targetGlobalY;

                        S32Data targetS32 = GetS32DataByGameCoords(targetGameX, targetGameY);
                        if (targetS32 == null)
                        {
                            skippedCount++;
                            continue;
                        }

                        int layer3X = targetGameX - targetS32.SegInfo.nLinBeginX;
                        int localY = targetGameY - targetS32.SegInfo.nLinBeginY;

                        if (layer3X < 0 || layer3X >= 64 || localY < 0 || localY >= 64)
                        {
                            skippedCount++;
                            continue;
                        }

                        var oldAttr = targetS32.Layer3[localY, layer3X];
                        undoAction.ModifiedLayer3.Add(new UndoLayer3Info
                        {
                            S32FilePath = targetS32.FilePath,
                            LocalX = layer3X,
                            LocalY = localY,
                            OldAttribute1 = oldAttr?.Attribute1 ?? 0,
                            OldAttribute2 = oldAttr?.Attribute2 ?? 0,
                            NewAttribute1 = item.Attribute1,
                            NewAttribute2 = item.Attribute2
                        });

                        targetS32.Layer3[localY, layer3X] = new MapAttribute
                        {
                            Attribute1 = item.Attribute1,
                            Attribute2 = item.Attribute2
                        };
                        layer3Count++;
                        targetS32.IsModified = true;
                    }
                }

                // 計算新的 GroupId 起始值（Layer4 和 Layer5 共用）
                int maxGroupId = 0;
                foreach (var s32 in _document.S32Files.Values)
                {
                    foreach (var obj in s32.Layer4)
                    {
                        if (obj.GroupId > maxGroupId)
                            maxGroupId = obj.GroupId;
                    }
                }
                int baseGroupId = maxGroupId + 1;

                // 貼上 Layer4 資料（物件）
                if (material.HasLayer4)
                {
                    foreach (var item in material.Layer4Items)
                    {
                        // 套用偏移修正（舊素材的 RelativeX/Y 可能不是從 0 開始）
                        int targetGlobalX = pasteOriginX + item.RelativeX - offsetFixX;
                        int targetGlobalY = pasteOriginY + item.RelativeY - offsetFixY;
                        int targetGameX = targetGlobalX / 2;
                        int targetGameY = targetGlobalY;

                        S32Data targetS32 = GetS32DataByGameCoords(targetGameX, targetGameY);
                        if (targetS32 == null)
                        {
                            skippedCount++;
                            continue;
                        }

                        int objLocalX = targetGlobalX - targetS32.SegInfo.nLinBeginX * 2;
                        int objLocalY = targetGlobalY - targetS32.SegInfo.nLinBeginY;

                        if (objLocalY < 0 || objLocalY >= 64)
                        {
                            skippedCount++;
                            continue;
                        }

                        var newObj = new ObjectTile
                        {
                            GroupId = baseGroupId + item.GroupId,  // 重新映射 GroupId
                            X = objLocalX,
                            Y = objLocalY,
                            Layer = item.Layer,
                            IndexId = item.IndexId,
                            TileId = item.TileId
                        };
                        targetS32.Layer4.Add(newObj);
                        Layer4Index_Add(targetS32, newObj);
                        layer4Count++;

                        undoAction.AddedObjects.Add(new UndoObjectInfo
                        {
                            S32FilePath = targetS32.FilePath,
                            GameX = targetS32.SegInfo.nLinBeginX + objLocalX / 2,
                            GameY = targetS32.SegInfo.nLinBeginY + objLocalY,
                            LocalX = newObj.X,
                            LocalY = newObj.Y,
                            GroupId = newObj.GroupId,
                            Layer = newObj.Layer,
                            IndexId = newObj.IndexId,
                            TileId = newObj.TileId
                        });

                        targetS32.IsModified = true;
                    }
                }

                // 貼上 Layer5 資料（事件/透明化）
                int layer5Count = 0;
                if (material.HasLayer5 && material.Layer5Items.Count > 0)
                {
                    foreach (var item in material.Layer5Items)
                    {
                        // 套用偏移修正（與 Layer4 相同）
                        int targetGlobalX = pasteOriginX + item.RelativeX - offsetFixX;
                        int targetGlobalY = pasteOriginY + item.RelativeY - offsetFixY;
                        int targetGameX = targetGlobalX / 2;
                        int targetGameY = targetGlobalY;

                        S32Data targetS32 = GetS32DataByGameCoords(targetGameX, targetGameY);
                        if (targetS32 == null)
                        {
                            continue;
                        }

                        // Layer5 的 X 是 0-127 (Layer1 座標)，Y 是 0-63
                        int localX = targetGlobalX - targetS32.SegInfo.nLinBeginX * 2;
                        int localY = targetGlobalY - targetS32.SegInfo.nLinBeginY;

                        if (localX < 0 || localX >= 128 || localY < 0 || localY >= 64)
                        {
                            continue;
                        }

                        // 計算新的 GroupId（與 Layer4 相同映射）
                        int newGroupId = baseGroupId + item.GroupId;

                        // 檢查是否已存在相同的 Layer5 項目
                        if (!targetS32.Layer5.Any(l => l.X == localX && l.Y == localY && l.ObjectIndex == newGroupId))
                        {
                            targetS32.Layer5.Add(new Layer5Item
                            {
                                X = (byte)localX,
                                Y = (byte)localY,
                                ObjectIndex = (ushort)newGroupId,
                                Type = item.Type
                            });
                            layer5Count++;
                            targetS32.IsModified = true;
                        }
                    }
                }

                // 加入 Undo 記錄
                if (undoAction.ModifiedLayer1.Count > 0 || undoAction.ModifiedLayer3.Count > 0 ||
                    undoAction.AddedObjects.Count > 0)
                {
                    _editState.UndoHistory.Push(undoAction);
                    _editState.RedoHistory.Clear();
                }

                // 重新渲染
                RenderS32Map();

                // 更新 Layer5 異常檢查按鈕
                if (layer5Count > 0)
                {
                    UpdateMapValidateButton();
                }

                // 更新狀態（包含座標資訊以便偵錯）
                string info = $"已貼上素材: {material.Name} 於 ({gameX}, {gameY})";
                if (layer1Count > 0) info += $", {layer1Count} 地板";
                if (layer3Count > 0) info += $", {layer3Count} 屬性";
                if (layer4Count > 0) info += $", {layer4Count} 物件";
                if (layer5Count > 0) info += $", {layer5Count} 事件";
                if (skippedCount > 0) info += $" (跳過 {skippedCount})";
                toolStripStatusLabel1.Text = info;

                // 結束貼上模式
                CancelMaterialPasteMode();
            }
            catch (Exception ex)
            {
                WinFormsMessageBox.Show($"貼上素材失敗: {ex.Message}", "錯誤", MessageBoxButtons.OK, MessageBoxIcon.Error);
            }
        }

        // 開始素材貼上預覽模式
        private void StartMaterialPasteMode(Fs3pData material, string filePath)
        {
            // 處理素材中的 Tiles - 檢查 MD5 並匯入
            if (material.Tiles != null && material.Tiles.Count > 0)
            {
                var mappingResult = ProcessMaterialTiles(material);
                if (mappingResult == null)
                {
                    // 使用者取消
                    return;
                }

                // 根據 mapping 更新素材中的 TileId
                ApplyTileMappingToMaterial(material, mappingResult);
            }

            _pendingMaterial = material;
            _pendingMaterialPath = filePath;

            // 提示用戶
            toolStripStatusLabel1.Text = $"素材貼上模式：點擊地圖選擇貼上位置，ESC 取消 | {material.Name} ({material.Width}x{material.Height})";

            // 更新素材列表並高亮選中項目
            RefreshMaterialsList();
            HighlightPendingMaterial();

            // 隱藏預設提示
            UpdateDefaultHintVisibility();
        }

        // 處理素材中的 Tiles - 檢查 MD5 並決定是否需要匯入
        private TileMappingResult ProcessMaterialTiles(Fs3pData material)
        {
            // 先進行預覽分析 - 不實際匯入
            var previewResult = PreviewTileImport(material.Tiles);

            // 如果所有 tiles 都可以重用（MD5 一致），直接返回
            if (previewResult.NeedImportCount == 0 && previewResult.NeedRemapCount == 0)
            {
                // 靜默處理，直接使用 TileImportManager 建立 mapping（不會實際寫入）
                var importer = new TileImportManager { StartSearchId = 10000 };
                return BuildMappingWithoutImport(material.Tiles);
            }

            // 需要匯入新 tiles，顯示對話框讓使用者確認
            string message = $"素材包含 {material.Tiles.Count} 個圖塊：\n\n" +
                             $"• 可重用 (MD5 相符): {previewResult.ReuseCount} 個\n" +
                             $"• 需重新編號 (ID 衝突): {previewResult.NeedRemapCount} 個\n" +
                             $"• 需新增匯入: {previewResult.NeedImportCount} 個\n\n" +
                             $"請輸入新圖塊的起始編號 (將從此編號開始尋找未使用的 ID)：";

            using (var dialog = new Form())
            {
                dialog.Text = "圖塊匯入設定";
                dialog.Size = new Size(420, 220);
                dialog.SetStartPosition(FormStartPosition.CenterParent);
                dialog.SetFormBorderStyle(FormBorderStyle.FixedDialog);
                dialog.SetMaximizeBox(false);
                dialog.SetMinimizeBox(false);

                var lblMessage = new Label
                {
                    Text = message,
                    Location = new Point(15, 15),
                    Size = new Size(380, 100),
                    AutoSize = false
                };
                dialog.GetControls().Add(lblMessage);

                var lblStartId = new Label
                {
                    Text = "起始編號：",
                    Location = new Point(15, 125),
                    Size = new Size(75, 20)
                };
                dialog.GetControls().Add(lblStartId);

                var txtStartId = new TextBox
                {
                    Text = "10000",
                    Location = new Point(95, 122),
                    Size = new Size(100, 23)
                };
                dialog.GetControls().Add(txtStartId);

                var btnOK = new Button
                {
                    Text = "確定匯入",
                    DialogResult = DialogResult.Ok,
                    Location = new Point(220, 145),
                    Size = new Size(85, 28)
                };
                dialog.GetControls().Add(btnOK);

                var btnCancel = new Button
                {
                    Text = "取消",
                    DialogResult = DialogResult.Cancel,
                    Location = new Point(310, 145),
                    Size = new Size(85, 28)
                };
                dialog.GetControls().Add(btnCancel);

                dialog.AcceptButton = btnOK;
                dialog.CancelButton = btnCancel;

                if (dialog.ShowDialog(this) != DialogResult.Ok)
                    return null;

                if (!int.TryParse(txtStartId.Text, out int startId) || startId < 1)
                {
                    WinFormsMessageBox.Show("請輸入有效的起始編號 (大於 0)", "錯誤", MessageBoxButtons.OK, MessageBoxIcon.Error);
                    return null;
                }

                // 再次確認
                int totalNewTiles = previewResult.NeedRemapCount + previewResult.NeedImportCount;
                string confirmMessage = $"即將執行以下操作：\n\n" +
                                        $"• 重用現有圖塊: {previewResult.ReuseCount} 個\n" +
                                        $"• 匯入新圖塊: {totalNewTiles} 個\n" +
                                        $"  (從編號 {startId} 開始尋找未使用的 ID)\n\n" +
                                        $"確定要繼續嗎？";

                if (WinFormsMessageBox.Show(confirmMessage, "確認匯入", MessageBoxButtons.YesNo, MessageBoxIcon.Question) != DialogResult.Yes)
                    return null;

                // 檢查起始編號是否會超過上限
                int currentLimit = TileHashManager.GetTileLimit();
                if (currentLimit > 0)
                {
                    // 估算最大可能使用的 ID (起始ID + 需匯入數量)
                    int estimatedMaxId = startId + totalNewTiles;
                    if (estimatedMaxId > currentLimit)
                    {
                        string limitWarning = $"預計 Tile ID 將超過上限！\n\n" +
                                              $"目前上限: {currentLimit}\n" +
                                              $"預計最大 ID: ~{estimatedMaxId}\n\n" +
                                              $"超過上限的 Tile 將顯示為三角形圖案。\n" +
                                              $"是否先將上限擴充 +5000？\n" +
                                              $"(新上限: {currentLimit + 5000})";

                        var limitResult = WinFormsMessageBox.Show(limitWarning, "Tile 上限警告", MessageBoxButtons.YesNoCancel, MessageBoxIcon.Warning);
                        if (limitResult == DialogResult.Cancel)
                            return null;

                        if (limitResult == DialogResult.Yes)
                        {
                            int newLimit = currentLimit + 5000;
                            if (TileHashManager.UpdateTileLimit(newLimit))
                            {
                                toolStripStatusLabel1.Text = $"已將 Tile 上限擴充至 {newLimit}";
                            }
                            else
                            {
                                WinFormsMessageBox.Show("擴充 Tile 上限失敗，繼續匯入", "警告", MessageBoxButtons.OK, MessageBoxIcon.Warning);
                            }
                        }
                    }
                }

                // 執行實際匯入
                var importer = new TileImportManager { StartSearchId = startId };
                var result = importer.ProcessTilesBatch(material.Tiles);

                // 顯示匯入結果
                if (result.ImportedCount > 0 || result.RemappedCount > 0)
                {
                    toolStripStatusLabel1.Text = $"已匯入 {result.ImportedCount} 個新圖塊，重新編號 {result.RemappedCount} 個，重用 {result.ReuseCount} 個";
                }

                // 檢查是否有 Tile ID 超過上限
                CheckAndExpandTileLimit(result);

                return result;
            }
        }

        // 檢查並擴充 Tile 上限
        private void CheckAndExpandTileLimit(TileMappingResult result)
        {
            if (result == null)
                return;

            // 收集所有新的 Tile ID
            var newTileIds = new List<int>(result.IdMapping.Values);

            if (newTileIds.Count == 0)
                return;

            // 循環檢查，直到上限滿足或用戶取消
            while (true)
            {
                // 檢查是否超過上限
                var checkResult = TileHashManager.CheckTileIdsOverLimit(newTileIds);
                if (!checkResult.IsOver)
                    return; // 上限已滿足

                // 計算建議的擴充量（至少 +5000，或剛好滿足需求）
                int needed = checkResult.MaxTileId - checkResult.CurrentLimit;
                int expandAmount = Math.Max(5000, ((needed / 5000) + 1) * 5000);
                int suggestedLimit = checkResult.CurrentLimit + expandAmount;

                // 超過上限，詢問用戶是否擴充
                string message = $"Tile ID 已達上限！\n\n" +
                                 $"目前上限: {checkResult.CurrentLimit}\n" +
                                 $"最大 Tile ID: {checkResult.MaxTileId}\n" +
                                 $"超出: {needed} 個\n\n" +
                                 $"超過上限的 Tile 將顯示為三角形圖案。\n" +
                                 $"是否將上限擴充至 {suggestedLimit}？\n" +
                                 $"(+{expandAmount})";

                if (WinFormsMessageBox.Show(message, "Tile 上限警告", MessageBoxButtons.YesNo, MessageBoxIcon.Warning) != DialogResult.Yes)
                {
                    // 用戶取消，結束檢查
                    return;
                }

                if (TileHashManager.UpdateTileLimit(suggestedLimit))
                {
                    // 擴充成功，繼續循環檢查是否已滿足
                    // （下一輪 while 會再次檢查）
                }
                else
                {
                    WinFormsMessageBox.Show("擴充 Tile 上限失敗", "錯誤", MessageBoxButtons.OK, MessageBoxIcon.Error);
                    return;
                }
            }
        }

        // 預覽 Tile 匯入情況（不實際寫入）
        private (int ReuseCount, int NeedRemapCount, int NeedImportCount) PreviewTileImport(Dictionary<int, TilePackageData> tiles)
        {
            int reuseCount = 0;
            int needRemapCount = 0;
            int needImportCount = 0;

            foreach (var kvp in tiles)
            {
                int originalId = kvp.Key;
                byte[] packageMd5 = kvp.Value.Md5Hash;

                // 檢查現有 Tile
                byte[] existingTilData = L1PakReader.UnPack("Tile", $"{originalId}.til");

                if (existingTilData != null)
                {
                    byte[] existingMd5 = TileHashManager.CalculateMd5(existingTilData);
                    if (TileHashManager.CompareMd5(existingMd5, packageMd5))
                    {
                        reuseCount++; // MD5 一致，可重用
                    }
                    else
                    {
                        // ID 存在但 MD5 不同，搜尋是否有其他 tile 的 MD5 相符
                        int? existingIdByMd5 = TileHashManager.FindTileByMd5(packageMd5);
                        if (existingIdByMd5.HasValue)
                        {
                            reuseCount++; // 找到相同 MD5 的其他 tile，可重映射
                        }
                        else
                        {
                            needImportCount++; // 完全不存在，需新增
                        }
                    }
                }
                else
                {
                    // ID 不存在，檢查是否有相同 MD5 的其他 tile
                    int? existingIdByMd5 = TileHashManager.FindTileByMd5(packageMd5);
                    if (existingIdByMd5.HasValue)
                    {
                        reuseCount++; // 找到相同 MD5，可重用
                    }
                    else
                    {
                        needImportCount++; // 完全不存在，需新增
                    }
                }
            }

            return (reuseCount, needRemapCount, needImportCount);
        }

        // 建立 Tile Mapping（不實際匯入，用於所有 tile 都可重用的情況）
        private TileMappingResult BuildMappingWithoutImport(Dictionary<int, TilePackageData> tiles)
        {
            var result = new TileMappingResult();

            foreach (var kvp in tiles)
            {
                int originalId = kvp.Key;
                byte[] packageMd5 = kvp.Value.Md5Hash;

                byte[] existingTilData = L1PakReader.UnPack("Tile", $"{originalId}.til");

                if (existingTilData != null)
                {
                    byte[] existingMd5 = TileHashManager.CalculateMd5(existingTilData);
                    if (TileHashManager.CompareMd5(existingMd5, packageMd5))
                    {
                        // 原 ID 存在且 MD5 相符，直接使用
                        result.AddMapping(originalId, originalId, TileMatchType.Exact);
                    }
                    else
                    {
                        // ID 存在但 MD5 不同，搜尋其他匹配的 tile
                        int? existingIdByMd5 = TileHashManager.FindTileByMd5(packageMd5);
                        if (existingIdByMd5.HasValue)
                        {
                            result.AddMapping(originalId, existingIdByMd5.Value, TileMatchType.MergedByMd5);
                        }
                    }
                }
                else
                {
                    // 原 ID 不存在，搜尋 MD5 匹配的 tile
                    int? existingIdByMd5 = TileHashManager.FindTileByMd5(packageMd5);
                    if (existingIdByMd5.HasValue)
                    {
                        result.AddMapping(originalId, existingIdByMd5.Value, TileMatchType.MergedByMd5);
                    }
                }
            }

            return result;
        }

        // 將 Tile Mapping 套用到素材的各圖層
        private void ApplyTileMappingToMaterial(Fs3pData material, TileMappingResult mapping)
        {
            // 更新 Layer1
            foreach (var item in material.Layer1Items)
            {
                if (item.TileId > 0)
                {
                    item.TileId = (ushort)mapping.GetNewTileId(item.TileId);
                }
            }

            // 更新 Layer2
            foreach (var item in material.Layer2Items)
            {
                if (item.TileId > 0)
                {
                    item.TileId = (ushort)mapping.GetNewTileId(item.TileId);
                }
            }

            // 更新 Layer4
            foreach (var item in material.Layer4Items)
            {
                if (item.TileId > 0)
                {
                    item.TileId = (ushort)mapping.GetNewTileId(item.TileId);
                }
            }
        }

        // 取消素材貼上模式
        private void CancelMaterialPasteMode()
        {
            _pendingMaterial = null;
            _pendingMaterialPath = null;
            toolStripStatusLabel1.Text = "";

            // 清除高亮
            ClearMaterialHighlight();

            // 顯示預設提示
            UpdateDefaultHintVisibility();
        }

        // 高亮目前選中的素材
        private void HighlightPendingMaterial()
        {
            if (_pendingMaterialPath == null) return;

            foreach (IconTextListItem item in lvMaterials.Items)
            {
                if (item.Tag is string path && path == _pendingMaterialPath)
                {
                    item.BackgroundColor = Colors.LightBlue;
                    item.TextColor = Colors.Black;
                }
                else
                {
                    item.BackgroundColor = lvMaterials.BackColor;
                    item.TextColor = lvMaterials.ForeColor;
                }
            }
        }

        // 清除素材高亮
        private void ClearMaterialHighlight()
        {
            foreach (IconTextListItem item in lvMaterials.Items)
            {
                item.BackgroundColor = lvMaterials.BackColor;
                item.TextColor = lvMaterials.ForeColor;
            }
        }

        // 更新群組縮圖列表（顯示所有已載入 S32 的群組）
        private void UpdateGroupThumbnailsList()
        {
            UpdateGroupThumbnailsList(null);  // 不帶選取區域時顯示全部
        }

        // 群組縮圖產生取消 token
        private System.Threading.CancellationTokenSource _groupThumbnailCts = null;

        // 更新群組縮圖列表 - 支援三種模式：選取區域、區域-全部、全部
        private void UpdateGroupThumbnailsList(List<SelectedCell> selectedCells)
        {
            var setupSw = Stopwatch.StartNew();

            // 取消之前的縮圖產生任務
            if (_groupThumbnailCts != null)
            {
                _groupThumbnailCts.Cancel();
                _groupThumbnailCts.Dispose();
            }
            _groupThumbnailCts = new System.Threading.CancellationTokenSource();
            var cancellationToken = _groupThumbnailCts.Token;

            // 清空快取和搜尋框
            _cachedGroupItems.Clear();
            txtGroupSearch.Text = "";

            lvGroupThumbnails.Items.Clear();

            if (lvGroupThumbnails.LargeImageList != null)
            {
                lvGroupThumbnails.LargeImageList.Dispose();
            }

            if (_document.S32Files.Count == 0)
            {
                lblGroupThumbnails.Text = LocalizationManager.L("Label_GroupThumbnails");
                return;
            }

            bool hasSelection = selectedCells != null && selectedCells.Count > 0;
            var currentMode = _groupDisplayMode;

            // 選取區域模式但無選取，清空列表
            if (!hasSelection && currentMode != GroupDisplayMode.All)
            {
                lblGroupThumbnails.Text = LocalizationManager.L("Label_GroupThumbnails");
                return;
            }

            // 顯示載入中狀態
            string modeLabel = currentMode switch
            {
                GroupDisplayMode.SelectedArea => LocalizationManager.L("Label_SelectedAreaGroups"),
                GroupDisplayMode.SelectedAreaAll => LocalizationManager.L("Label_SelectedAreaAllGroups"),
                _ => LocalizationManager.L("Label_GroupThumbnails")
            };
            lblGroupThumbnails.Text = $"{modeLabel} ({LocalizationManager.L("Status_Collecting")}...)";

            // 複製需要的資料到背景執行緒
            var s32FilesSnapshot = _document.S32Files.ToDictionary(kvp => kvp.Key, kvp => kvp.Value);
            var selectedCellsSnapshot = selectedCells?.ToList();

            // 計算 S32 距離編碼
            HashSet<string> selectedS32Paths = null;
            (int x, int y)? viewportCenter = null;

            if (hasSelection)
            {
                selectedS32Paths = selectedCellsSnapshot.Select(c => c.S32Data.FilePath).ToHashSet();
            }
            else
            {
                viewportCenter = GetViewportCenterGameCoord();
            }

            var s32DistanceMap = CalculateS32DistanceMap(selectedS32Paths, viewportCenter);

            setupSw.Stop();
            long setupMs = setupSw.ElapsedMilliseconds;
            LogPerf($"[THUMBNAILS-START] setup={setupMs}ms, s32={s32FilesSnapshot.Count}, selected={selectedCellsSnapshot?.Count ?? 0}, mode={currentMode}");

            // 整個過程都在背景執行緒執行
            Task.Run(() =>
            {
                if (cancellationToken.IsCancellationRequested) return;

                var stopwatch = Stopwatch.StartNew();
                var phaseSw = Stopwatch.StartNew();

                // 收集群組 - 按 (S32Path, GroupId) 分組
                var groupsByS32 = new Dictionary<(string s32Path, int groupId), (S32Data s32, List<ObjectTile> objects)>();

                switch (currentMode)
                {
                    case GroupDisplayMode.SelectedArea:
                        // 只顯示選取格子內的群組物件
                        if (selectedCellsSnapshot != null && selectedCellsSnapshot.Count > 0)
                        {
                            var selectedLayer1Cells = new HashSet<(int x, int y)>();
                            foreach (var cell in selectedCellsSnapshot)
                            {
                                int layer1GlobalX = cell.S32Data.SegInfo.nLinBeginX * 2 + cell.LocalX;
                                int layer1GlobalY = cell.S32Data.SegInfo.nLinBeginY + cell.LocalY;
                                selectedLayer1Cells.Add((layer1GlobalX, layer1GlobalY));
                                selectedLayer1Cells.Add((layer1GlobalX + 1, layer1GlobalY));
                            }

                            // 收集選取區域內的 L5 ObjectIndex（作為額外的群組 ID）
                            var l5GroupIds = new HashSet<(string s32Path, int groupId)>();
                            foreach (var s32Data in s32FilesSnapshot.Values)
                            {
                                int segStartX = s32Data.SegInfo.nLinBeginX;
                                int segStartY = s32Data.SegInfo.nLinBeginY;

                                foreach (var item5 in s32Data.Layer5)
                                {
                                    int layer1GlobalX = segStartX * 2 + item5.X;
                                    int layer1GlobalY = segStartY + item5.Y;

                                    if (selectedLayer1Cells.Contains((layer1GlobalX, layer1GlobalY)))
                                    {
                                        l5GroupIds.Add((s32Data.FilePath, item5.ObjectIndex));
                                    }
                                }
                            }

                            foreach (var s32Data in s32FilesSnapshot.Values)
                            {
                                int segStartX = s32Data.SegInfo.nLinBeginX;
                                int segStartY = s32Data.SegInfo.nLinBeginY;

                                foreach (var obj in s32Data.Layer4)
                                {
                                    int layer1GlobalX = segStartX * 2 + obj.X;
                                    int layer1GlobalY = segStartY + obj.Y;

                                    // 檢查 L4 物件是否在選取區域內，或其 GroupId 在 L5 中被參照
                                    bool inSelectedArea = selectedLayer1Cells.Contains((layer1GlobalX, layer1GlobalY));
                                    bool referencedByL5 = l5GroupIds.Contains((s32Data.FilePath, obj.GroupId));

                                    if (inSelectedArea || referencedByL5)
                                    {
                                        var key = (s32Data.FilePath, obj.GroupId);
                                        if (!groupsByS32.ContainsKey(key))
                                        {
                                            groupsByS32[key] = (s32Data, new List<ObjectTile>());
                                        }
                                        groupsByS32[key].objects.Add(obj);
                                    }
                                }
                            }
                        }
                        break;

                    case GroupDisplayMode.SelectedAreaAll:
                        // 先找選取區域內的群組，再取得這些群組在 S32 的完整物件
                        if (selectedCellsSnapshot != null && selectedCellsSnapshot.Count > 0)
                        {
                            var selectedLayer1Cells = new HashSet<(int x, int y)>();
                            foreach (var cell in selectedCellsSnapshot)
                            {
                                int layer1GlobalX = cell.S32Data.SegInfo.nLinBeginX * 2 + cell.LocalX;
                                int layer1GlobalY = cell.S32Data.SegInfo.nLinBeginY + cell.LocalY;
                                selectedLayer1Cells.Add((layer1GlobalX, layer1GlobalY));
                                selectedLayer1Cells.Add((layer1GlobalX + 1, layer1GlobalY));
                            }

                            // 找出選取區域內有哪些 (S32Path, GroupId)
                            var matchedKeys = new HashSet<(string, int)>();
                            foreach (var s32Data in s32FilesSnapshot.Values)
                            {
                                int segStartX = s32Data.SegInfo.nLinBeginX;
                                int segStartY = s32Data.SegInfo.nLinBeginY;

                                // 從 L4 物件收集群組
                                foreach (var obj in s32Data.Layer4)
                                {
                                    int layer1GlobalX = segStartX * 2 + obj.X;
                                    int layer1GlobalY = segStartY + obj.Y;

                                    if (selectedLayer1Cells.Contains((layer1GlobalX, layer1GlobalY)))
                                    {
                                        matchedKeys.Add((s32Data.FilePath, obj.GroupId));
                                    }
                                }

                                // 從 L5 ObjectIndex 收集群組
                                foreach (var item5 in s32Data.Layer5)
                                {
                                    int layer1GlobalX = segStartX * 2 + item5.X;
                                    int layer1GlobalY = segStartY + item5.Y;

                                    if (selectedLayer1Cells.Contains((layer1GlobalX, layer1GlobalY)))
                                    {
                                        matchedKeys.Add((s32Data.FilePath, item5.ObjectIndex));
                                    }
                                }
                            }

                            // 取得這些群組在對應 S32 的完整物件
                            foreach (var s32Data in s32FilesSnapshot.Values)
                            {
                                var groupsInS32 = s32Data.Layer4.GroupBy(obj => obj.GroupId);
                                foreach (var group in groupsInS32)
                                {
                                    var key = (s32Data.FilePath, group.Key);
                                    if (matchedKeys.Contains(key))
                                    {
                                        groupsByS32[key] = (s32Data, group.ToList());
                                    }
                                }
                            }
                        }
                        break;

                    case GroupDisplayMode.All:
                        // 顯示所有 S32 的所有群組
                        foreach (var s32Data in s32FilesSnapshot.Values)
                        {
                            var groupsInS32 = s32Data.Layer4.GroupBy(obj => obj.GroupId);
                            foreach (var group in groupsInS32)
                            {
                                var key = (s32Data.FilePath, group.Key);
                                groupsByS32[key] = (s32Data, group.ToList());
                            }
                        }
                        break;
                }

                if (cancellationToken.IsCancellationRequested) return;

                phaseSw.Stop();
                long collectGroupsMs = phaseSw.ElapsedMilliseconds;
                phaseSw.Restart();

                if (groupsByS32.Count == 0)
                {
                    try
                    {
                        this.BeginInvoke((MethodInvoker)delegate
                        {
                            lblGroupThumbnails.Text = $"{modeLabel} (0)";
                        });
                    }
                    catch { }
                    return;
                }

                int totalGroups = groupsByS32.Count;

                // 收集所有 Layer5 的 GroupId -> Type 對應
                var groupLayer5Info = new Dictionary<int, byte>();
                foreach (var s32Data in s32FilesSnapshot.Values)
                {
                    foreach (var item in s32Data.Layer5)
                    {
                        if (!groupLayer5Info.ContainsKey(item.ObjectIndex))
                        {
                            groupLayer5Info[item.ObjectIndex] = item.Type;
                        }
                    }
                }

                if (cancellationToken.IsCancellationRequested) return;

                phaseSw.Stop();
                long collectLayer5Ms = phaseSw.ElapsedMilliseconds;
                phaseSw.Restart();

                // 更新 UI 顯示進度
                try
                {
                    this.BeginInvoke((MethodInvoker)delegate
                    {
                        lblGroupThumbnails.Text = $"{modeLabel} ({LocalizationManager.L("Status_Loading")} 0/{totalGroups})";
                    });
                }
                catch { }

                // 準備群組資料 - 按距離編碼和 GroupId 排序
                var groupList = groupsByS32
                    .Select(kvp => new {
                        Key = kvp.Key,
                        Value = kvp.Value,
                        DistanceCode = s32DistanceMap.TryGetValue(kvp.Key.s32Path, out int d) ? d : 99
                    })
                    .OrderBy(x => x.DistanceCode)
                    .ThenBy(x => x.Key.groupId)
                    .ToList();

                // 使用 Parallel.ForEach 並行產生縮圖
                var thumbnailResults = new System.Collections.Concurrent.ConcurrentDictionary<(string, int), (string s32Path, int groupId, int distCode, int objectCount, Bitmap thumbnail, S32Data s32, List<ObjectTile> objects, bool hasLayer5, byte layer5Type)>();

                int processedCount = 0;
                int lastReportedCount = 0;

                Parallel.ForEach(groupList, new ParallelOptions { MaxDegreeOfParallelism = Environment.ProcessorCount }, (item, state) =>
                {
                    if (cancellationToken.IsCancellationRequested)
                    {
                        state.Stop();
                        return;
                    }

                    var key = item.Key;
                    var s32Data = item.Value.s32;
                    var objects = item.Value.objects;
                    int distCode = item.DistanceCode;

                    // 檢查該群組是否有 Layer5 設定
                    bool hasLayer5 = groupLayer5Info.TryGetValue(key.groupId, out byte layer5Type);

                    // 生成群組縮圖
                    Bitmap thumbnail = GenerateGroupThumbnailForS32(s32Data, objects, 80, hasLayer5, layer5Type);

                    if (thumbnail != null && !cancellationToken.IsCancellationRequested)
                    {
                        thumbnailResults[key] = (key.s32Path, key.groupId, distCode, objects.Count, thumbnail, s32Data, objects, hasLayer5, layer5Type);
                    }

                    // 更新進度
                    int current = System.Threading.Interlocked.Increment(ref processedCount);
                    if (current - lastReportedCount >= 10 || current == totalGroups)
                    {
                        lastReportedCount = current;
                        try
                        {
                            this.BeginInvoke((MethodInvoker)delegate
                            {
                                if (!cancellationToken.IsCancellationRequested)
                                {
                                    lblGroupThumbnails.Text = $"{modeLabel} ({LocalizationManager.L("Status_Loading")} {current}/{totalGroups})";
                                }
                            });
                        }
                        catch { }
                    }
                });

                phaseSw.Stop();
                long generateThumbnailsMs = phaseSw.ElapsedMilliseconds;

                stopwatch.Stop();
                long elapsedMs = stopwatch.ElapsedMilliseconds;

                LogPerf($"[THUMBNAILS-DONE] total={elapsedMs}ms | collectGroups={collectGroupsMs}ms, collectLayer5={collectLayer5Ms}ms, generateThumbnails={generateThumbnailsMs}ms | groups={totalGroups}");

                // 如果被取消就不更新 UI
                if (cancellationToken.IsCancellationRequested)
                {
                    foreach (var result in thumbnailResults.Values)
                    {
                        result.thumbnail?.Dispose();
                    }
                    return;
                }

                // 在 UI 執行緒更新 ListView
                try
                {
                    this.BeginInvoke((MethodInvoker)delegate
                    {
                        var uiSw = Stopwatch.StartNew();

                        if (cancellationToken.IsCancellationRequested)
                        {
                            foreach (var result in thumbnailResults.Values)
                            {
                                result.thumbnail?.Dispose();
                            }
                            return;
                        }

                        // 建立 ImageList
                        ImageList imageList = new ImageList();
                        imageList.ImageSize = new Size(80, 80);
                        imageList.ColorDepth = ColorDepth.Depth32Bit;

                        lvGroupThumbnails.BeginUpdate();
                        try
                        {
                            lvGroupThumbnails.Items.Clear();
                            if (lvGroupThumbnails.LargeImageList != null)
                            {
                                lvGroupThumbnails.LargeImageList.Dispose();
                            }

                            // 批量準備項目 - 按距離編碼和 GroupId 排序
                            var items = new List<IconTextListItem>();
                            int thumbnailIndex = 0;
                            var sortedResults = thumbnailResults.Values
                                .OrderBy(r => r.distCode)
                                .ThenBy(r => r.groupId);

                            foreach (var result in sortedResults)
                            {
                                imageList.Images.Add(result.thumbnail);

                                // 顯示格式: "距離:G群組ID (物件數)"
                                var item = new IconTextListItem
                                {
                                    Text = $"{result.distCode}:G{result.groupId} ({result.objectCount})",
                                    ImageIndex = thumbnailIndex,
                                    Image = result.thumbnail,  // 直接設定圖片，不依賴 ImageList
                                    Tag = new GroupThumbnailInfo
                                    {
                                        GroupId = result.groupId,
                                        S32Data = result.s32,
                                        S32FileName = System.IO.Path.GetFileName(result.s32Path),
                                        DistanceCode = result.distCode,
                                        Objects = result.objects,
                                        HasLayer5Setting = result.hasLayer5,
                                        Layer5Type = result.layer5Type
                                    }
                                };
                                items.Add(item);

                                thumbnailIndex++;
                            }

                            // 快取項目和 ImageList
                            _cachedGroupItems = items;
                            _cachedGroupImageList = imageList;

                            // 先設定 ImageList，再添加 Items（順序很重要！）
                            lvGroupThumbnails.LargeImageList = imageList;
                            lvGroupThumbnails.Items.AddRange(items);
                        }
                        finally
                        {
                            lvGroupThumbnails.EndUpdate();
                        }

                        uiSw.Stop();

                        lblGroupThumbnails.Text = $"{modeLabel} ({totalGroups}) [{elapsedMs}ms]";

                        // 更新狀態列
                        if (this.toolStripStatusLabel1.Text.Contains("Thumbnails: background"))
                        {
                            this.toolStripStatusLabel1.Text = this.toolStripStatusLabel1.Text.Replace(
                                "Thumbnails: background",
                                $"Thumbnails: {elapsedMs}ms");
                        }

                        LogPerf($"[THUMBNAILS-UI] updateListView={uiSw.ElapsedMilliseconds}ms | groups={totalGroups}");
                    });
                }
                catch { }
            });
        }

        // 群組顯示模式
        private enum GroupDisplayMode
        {
            SelectedArea,       // 選取區域
            SelectedAreaAll,    // 選取區域-全部
            All                 // 全部
        }

        private GroupDisplayMode _groupDisplayMode = GroupDisplayMode.SelectedArea;

        // 群組縮圖資訊（按 S32 + GroupId 分組）
        private class GroupThumbnailInfo
        {
            public int GroupId { get; set; }
            public S32Data S32Data { get; set; }  // 所屬 S32
            public string S32FileName { get; set; }  // S32 檔名
            public int DistanceCode { get; set; }  // S32 距離編碼
            public List<ObjectTile> Objects { get; set; }  // 該 S32 內的物件
            public bool HasLayer5Setting { get; set; }  // 是否有 Layer5 設定
            public byte Layer5Type { get; set; }        // Layer5 Type (0=半透明, 1=其他)
        }

        // 群組縮圖快取（用於過濾）
        private List<IconTextListItem> _cachedGroupItems = new List<IconTextListItem>();
        private ImageList _cachedGroupImageList = null;

        // 群組搜尋過濾
        private void txtGroupSearch_TextChanged(object sender, EventArgs e)
        {
            FilterGroupThumbnails(txtGroupSearch.Text);
        }

        // 過濾群組縮圖列表
        private void FilterGroupThumbnails(string searchText)
        {
            if (_cachedGroupItems.Count == 0) return;

            lvGroupThumbnails.BeginUpdate();
            try
            {
                lvGroupThumbnails.Items.Clear();

                if (string.IsNullOrWhiteSpace(searchText))
                {
                    // 無搜尋條件，顯示全部
                    lvGroupThumbnails.Items.AddRange(_cachedGroupItems);
                }
                else
                {
                    // 過濾符合條件的項目
                    var filteredItems = _cachedGroupItems
                        .Where(item =>
                        {
                            var info = item.Tag as GroupThumbnailInfo;
                            if (info == null) return false;
                            // 搜尋 GroupId
                            return info.GroupId.ToString().Contains(searchText);
                        })
                        .ToList();
                    lvGroupThumbnails.Items.AddRange(filteredItems);
                }
            }
            finally
            {
                lvGroupThumbnails.EndUpdate();
            }
        }

        // 群組顯示模式切換事件
        private void cmbGroupMode_SelectedIndexChanged(object sender, EventArgs e)
        {
            _groupDisplayMode = (GroupDisplayMode)cmbGroupMode.SelectedIndex;
            txtGroupSearch.Text = "";  // 清空搜尋框

            // 根據當前選取狀態刷新
            if (_editState.SelectedCells != null && _editState.SelectedCells.Count > 0)
            {
                UpdateGroupThumbnailsList(_editState.SelectedCells);
            }
            else if (_groupDisplayMode == GroupDisplayMode.All)
            {
                UpdateGroupThumbnailsList(null);
            }
            else
            {
                // 選取區域模式但無選取，清空列表
                lvGroupThumbnails.Items.Clear();
                _cachedGroupItems.Clear();
                lblGroupThumbnails.Text = LocalizationManager.L("Label_GroupThumbnails");
            }
        }

        // 按 S32 + GroupId 收集群組
        private Dictionary<(string s32Path, int groupId), (S32Data s32, List<ObjectTile> objects)> GetGroupsByS32()
        {
            var result = new Dictionary<(string, int), (S32Data, List<ObjectTile>)>();
            foreach (var s32Data in _document.S32Files.Values)
            {
                var groupsInS32 = s32Data.Layer4.GroupBy(obj => obj.GroupId);
                foreach (var group in groupsInS32)
                {
                    var key = (s32Data.FilePath, group.Key);
                    result[key] = (s32Data, group.ToList());
                }
            }
            return result;
        }

        // 計算每個 S32 相對於參考點的距離編碼
        private Dictionary<string, int> CalculateS32DistanceMap(
            HashSet<string> currentS32Paths,   // 選取模式: 選取區域所在 S32; 全部模式: null
            (int x, int y)? viewportCenter)    // 全部模式: viewport 中心點 (遊戲座標)
        {
            var distanceMap = new Dictionary<string, int>();

            // 決定參考中心點
            List<(int x, int y)> referenceCenters;

            if (currentS32Paths != null && currentS32Paths.Count > 0)
            {
                // 選取模式：以選取區域所在 S32 的中心為基準
                referenceCenters = currentS32Paths
                    .Where(p => _document.S32Files.ContainsKey(p))
                    .Select(p => _document.S32Files[p])
                    .Select(s => (
                        x: s.SegInfo.nLinBeginX + 32,
                        y: s.SegInfo.nLinBeginY + 32
                    ))
                    .ToList();

                // 當前 S32 = 距離 0
                foreach (var path in currentS32Paths)
                {
                    distanceMap[path] = 0;
                }
            }
            else if (viewportCenter.HasValue)
            {
                // 全部模式：以 viewport 中心為基準
                referenceCenters = new List<(int, int)> { viewportCenter.Value };
            }
            else
            {
                // 無參考點，所有 S32 距離為 0
                foreach (var path in _document.S32Files.Keys)
                {
                    distanceMap[path] = 0;
                }
                return distanceMap;
            }

            if (referenceCenters.Count == 0)
            {
                // 沒有有效的參考點，所有 S32 距離為 0
                foreach (var path in _document.S32Files.Keys)
                {
                    distanceMap[path] = 0;
                }
                return distanceMap;
            }

            // 計算所有 S32 到參考點的距離
            var allS32s = _document.S32Files
                .Where(kvp => !distanceMap.ContainsKey(kvp.Key))  // 排除已設為 0 的
                .Select(kvp => {
                    var s = kvp.Value;
                    int centerX = s.SegInfo.nLinBeginX + 32;
                    int centerY = s.SegInfo.nLinBeginY + 32;
                    // 計算到最近參考點的距離 (Chebyshev distance)
                    int minDist = referenceCenters.Min(c =>
                        Math.Max(Math.Abs(c.x - centerX), Math.Abs(c.y - centerY)));
                    return (path: kvp.Key, distance: minDist);
                })
                .OrderBy(x => x.distance)
                .ToList();

            // 分配距離編號（相同距離的 S32 使用相同編號）
            int lastDist = -1;
            int distCode = currentS32Paths != null ? 0 : -1;  // 全部模式從 0 開始
            foreach (var (path, distance) in allS32s)
            {
                if (distance != lastDist)
                {
                    distCode++;
                    lastDist = distance;
                }
                distanceMap[path] = distCode;
            }

            return distanceMap;
        }

        // 取得 viewport 中心的遊戲座標
        private (int x, int y) GetViewportCenterGameCoord()
        {
            // 從 ViewState 取得 viewport 中心的世界座標
            var viewRect = _viewState.GetViewportWorldRect();
            int worldCenterX = viewRect.X + viewRect.Width / 2;
            int worldCenterY = viewRect.Y + viewRect.Height / 2;

            // 轉換為遊戲座標
            var result = CoordinateHelper.ScreenToGameCoords(worldCenterX, worldCenterY, _document.S32Files);
            return (result.gameX, result.gameY);
        }

        // 生成單一 S32 群組縮圖
        private Bitmap GenerateGroupThumbnailForS32(S32Data s32Data, List<ObjectTile> objects, int thumbnailSize, bool hasLayer5Setting = false, byte layer5Type = 0)
        {
            // 轉換為原有格式以重用現有邏輯
            var tupleList = objects.Select(obj => (s32Data, obj)).ToList();
            return GenerateGroupThumbnail(tupleList, thumbnailSize, hasLayer5Setting, layer5Type);
        }

        // 生成群組縮圖（將同 GroupId 的物件按相對位置組裝，使用與主畫布相同的繪製方式）
        private Bitmap GenerateGroupThumbnail(List<(S32Data s32, ObjectTile obj)> objects, int thumbnailSize, bool hasLayer5Setting = false, byte layer5Type = 0)
        {
            if (objects == null || objects.Count == 0)
                return null;

            try
            {
                // 計算所有物件的像素邊界
                // 使用與 RenderS32Block 完全相同的座標計算方式
                int pixelMinX = int.MaxValue, pixelMaxX = int.MinValue;
                int pixelMinY = int.MaxValue, pixelMaxY = int.MinValue;

                // 預先計算每個物件的像素座標，避免重複計算
                var objectPixels = new List<(ObjectTile obj, int px, int py)>(objects.Count);

                foreach (var item in objects)
                {
                    var obj = item.obj;
                    // 使用與 RenderS32Block 完全相同的座標計算
                    int halfX = obj.X / 2;
                    int baseX = -24 * halfX;
                    int baseY = 63 * 12 - 12 * halfX;
                    int px = baseX + obj.X * 24 + obj.Y * 24;
                    int py = baseY + obj.Y * 12;

                    objectPixels.Add((obj, px, py));

                    pixelMinX = Math.Min(pixelMinX, px);
                    pixelMaxX = Math.Max(pixelMaxX, px + 48);  // tile 寬度約 48
                    pixelMinY = Math.Min(pixelMinY, py);
                    pixelMaxY = Math.Max(pixelMaxY, py + 48);  // tile 高度預留空間
                }

                // 計算實際所需的圖片大小（加上邊距）
                int margin = 8;
                int actualWidth = pixelMaxX - pixelMinX + margin * 2;
                int actualHeight = pixelMaxY - pixelMinY + margin * 2;

                // 限制 tempBitmap 大小：縮圖只有 80px，不需要太大的暫存圖
                // 最大 512x512 足夠，超過的會被縮放
                int maxTempSize = 512;
                int tempWidth = Math.Min(Math.Max(actualWidth, 64), maxTempSize);
                int tempHeight = Math.Min(Math.Max(actualHeight, 64), maxTempSize);

                // 如果實際大小超過限制，計算縮放比例
                float preScale = 1.0f;
                if (actualWidth > maxTempSize || actualHeight > maxTempSize)
                {
                    preScale = Math.Min((float)maxTempSize / actualWidth, (float)maxTempSize / actualHeight);
                    tempWidth = (int)(actualWidth * preScale);
                    tempHeight = (int)(actualHeight * preScale);
                }

                // 使用 16bpp 格式與主畫布相同
                Bitmap tempBitmap = new Bitmap(tempWidth, tempHeight, PixelFormat.Format16bppRgb555);

                Rectangle rect = new Rectangle(0, 0, tempBitmap.Width, tempBitmap.Height);
                BitmapData bmpData = tempBitmap.LockBits(rect, ImageLockMode.ReadWrite, tempBitmap.PixelFormat);
                int rowpix = bmpData.Stride;

                unsafe
                {
                    byte* ptr = (byte*)bmpData.Scan0;

                    // 使用 Marshal.Copy 批次填充白色背景 (RGB555: 0x7FFF = 白色)
                    // 建立一行白色資料
                    byte[] whiteLine = new byte[rowpix];
                    for (int x = 0; x < tempWidth; x++)
                    {
                        whiteLine[x * 2] = 0xFF;
                        whiteLine[x * 2 + 1] = 0x7F;
                    }
                    // 批次複製到每一行
                    for (int y = 0; y < tempHeight; y++)
                    {
                        System.Runtime.InteropServices.Marshal.Copy(whiteLine, 0, (IntPtr)(ptr + y * rowpix), rowpix);
                    }

                    // 高速平行繪製（縮圖不需要精確 Layer 順序）
                    // 預先計算所有繪製參數
                    var drawItems = objectPixels.Select(item => {
                        int pixelX = (int)((item.px - pixelMinX + margin) * preScale);
                        int pixelY = (int)((item.py - pixelMinY + margin) * preScale);
                        return (item.obj, pixelX, pixelY);
                    }).ToArray();

                    // 平行繪製所有 tiles
                    Parallel.ForEach(drawItems, item =>
                    {
                        DrawTilToBufferDirect555(item.pixelX, item.pixelY, item.obj.TileId, item.obj.IndexId, rowpix, ptr, tempWidth, tempHeight);
                    });
                }

                tempBitmap.UnlockBits(bmpData);

                // 縮放到目標大小（白底）
                Bitmap result = new Bitmap(thumbnailSize, thumbnailSize, PixelFormat.Format32bppArgb);
                using (Graphics g = GraphicsHelper.FromImage(result))
                {
                    // 白色底
                    g.Clear(Colors.White);
                    // 使用較快的插值模式（縮圖不需要高品質）
                    g.SetInterpolationMode(InterpolationMode.NearestNeighbor);
                    g.PixelOffsetMode = PixelOffsetMode.HighSpeed;
                    g.SetCompositingQuality(CompositingQuality.HighSpeed);

                    // 保持比例縮放
                    float scaleX = (float)(thumbnailSize - 4) / tempWidth;
                    float scaleY = (float)(thumbnailSize - 4) / tempHeight;
                    float scale = Math.Min(scaleX, scaleY);
                    int scaledWidth = (int)(tempWidth * scale);
                    int scaledHeight = (int)(tempHeight * scale);
                    int drawX = (thumbnailSize - scaledWidth) / 2;
                    int drawY = (thumbnailSize - scaledHeight) / 2;

                    g.DrawImage(tempBitmap, drawX, drawY, scaledWidth, scaledHeight);

                    // 加邊框（根據 Layer5 設定使用不同顏色）
                    // 注意：不使用靜態 Pen 物件，因為會在背景執行緒呼叫，會有跨執行緒存取問題
                    if (hasLayer5Setting)
                    {
                        using (var borderPen = new Pen(layer5Type == 0 ? Color.FromArgb(180, 0, 255) : Color.FromArgb(255, 80, 80), 3))
                        {
                            g.DrawRectangle(borderPen, 1, 1, thumbnailSize - 3, thumbnailSize - 3);
                        }
                    }
                    else
                    {
                        using (var borderPen = new Pen(Colors.LightGrey, 1))
                        {
                            g.DrawRectangle(borderPen, 0, 0, thumbnailSize - 1, thumbnailSize - 1);
                        }
                    }
                }

                tempBitmap.Dispose();
                return result;
            }
            catch (Exception ex)
            {
                // 記錄錯誤
                _logger.Error(ex, $"GenerateGroupThumbnail failed for GroupId {objects[0].obj.GroupId}");

                // 如果生成失敗，返回一個帶錯誤訊息的預設圖片
                Bitmap fallback = new Bitmap(thumbnailSize, thumbnailSize);
                using (Graphics g = GraphicsHelper.FromImage(fallback))
                {
                    g.Clear(Colors.White);
                    using (Font font = new Font("Arial", 10))
                    {
                        string text = $"G{objects[0].obj.GroupId}";
                        SizeF textSize = g.MeasureString(text, font);
                        g.DrawString(text, font, Brushes.Gray,
                            (thumbnailSize - textSize.Width) / 2,
                            (thumbnailSize - textSize.Height) / 2);
                    }
                    // 顯示錯誤提示
                    using (Font smallFont = new Font("Arial", 8))
                    {
                        string errText = $"Error: {ex.Message}";
                        if (errText.Length > 50) errText = errText.Substring(0, 47) + "...";
                        SizeF errSize = g.MeasureString(errText, smallFont);
                        g.DrawString(errText, smallFont, Brushes.Red,
                            (thumbnailSize - errSize.Width) / 2,
                            thumbnailSize - errSize.Height - 10);
                    }
                }
                return fallback;
            }
        }

        // 群組縮圖單擊事件 - 左鍵複製群組（支援多選）
        private void lvGroupThumbnails_MouseClick(object sender, MouseEventArgs e)
        {
            // 只處理左鍵點擊（右鍵由 MouseUp 處理顯示 context menu）
            if (e.Buttons != Eto.Forms.MouseButtons.Primary)
                return;

            if (lvGroupThumbnails.SelectedItems.Count == 0)
                return;

            // 收集所有選中群組的資訊
            var selectedInfos = new List<GroupThumbnailInfo>();
            foreach (IconTextListItem item in lvGroupThumbnails.SelectedItems)
            {
                if (item.Tag is GroupThumbnailInfo info && info.Objects.Count > 0)
                {
                    selectedInfos.Add(info);
                }
            }

            if (selectedInfos.Count > 0)
            {
                CopyMultipleGroupsToClipboard(selectedInfos);
            }
        }

        // 群組選擇變更事件 - 更新過濾狀態
        private void lvGroupThumbnails_SelectedIndexChanged(object sender, EventArgs e)
        {
            // 更新選取的群組 ID 列表
            _editState.SelectedLayer4Groups.Clear();
            foreach (IconTextListItem item in lvGroupThumbnails.SelectedItems)
            {
                if (item.Tag is GroupThumbnailInfo info)
                {
                    _editState.SelectedLayer4Groups.Add(info.GroupId);
                }
            }

            // 更新狀態列
            if (_editState.SelectedLayer4Groups.Count > 0)
            {
                string groupIds = string.Join(", ", _editState.SelectedLayer4Groups);
                this.toolStripStatusLabel1.Text = $"已選取 {_editState.SelectedLayer4Groups.Count} 個群組: {groupIds}";
            }
        }

        // 複製多個群組到剪貼簿
        private void CopyMultipleGroupsToClipboard(List<GroupThumbnailInfo> infos)
        {
            _editState.CellClipboard.Clear();

            // 收集所有要複製的物件（使用 S32Data 和 Objects 組合）
            var allObjects = new List<(S32Data s32, ObjectTile obj)>();
            foreach (var info in infos)
            {
                if (info.S32Data != null)
                {
                    foreach (var obj in info.Objects)
                    {
                        allObjects.Add((info.S32Data, obj));
                    }
                }
            }

            if (allObjects.Count == 0)
            {
                this.toolStripStatusLabel1.Text = "選取的群組內沒有任何物件";
                return;
            }

            // 計算要複製物件的座標範圍（使用 Layer1 座標系統）
            int minX = int.MaxValue, minY = int.MaxValue;
            foreach (var (s32, obj) in allObjects)
            {
                int globalLayer1X = s32.SegInfo.nLinBeginX * 2 + obj.X;
                int globalLayer1Y = s32.SegInfo.nLinBeginY + obj.Y;
                if (globalLayer1X < minX) minX = globalLayer1X;
                if (globalLayer1Y < minY) minY = globalLayer1Y;
            }

            // 確保 minX 是偶數，以保持相對座標的奇偶性
            if (minX % 2 != 0)
            {
                minX -= 1;
            }

            // 複製物件（使用 Layer1 座標系統）
            foreach (var (s32, obj) in allObjects)
            {
                int globalLayer1X = s32.SegInfo.nLinBeginX * 2 + obj.X;
                int globalLayer1Y = s32.SegInfo.nLinBeginY + obj.Y;

                var cellData = new CopiedCellData
                {
                    RelativeX = globalLayer1X - minX,
                    RelativeY = globalLayer1Y - minY
                };

                cellData.Layer4Objects.Add(new CopiedObjectTile
                {
                    RelativeX = globalLayer1X - minX,
                    RelativeY = globalLayer1Y - minY,
                    GroupId = obj.GroupId,
                    Layer = obj.Layer,
                    IndexId = obj.IndexId,
                    TileId = obj.TileId,
                    OriginalIndex = s32.Layer4.IndexOf(obj),
                    OriginalLocalLayer1X = obj.X,
                    OriginalLocalY = obj.Y
                });

                _editState.CellClipboard.Add(cellData);
            }

            // 設定剪貼簿狀態
            hasLayer4Clipboard = true;
            _editState.SourceMapId = _document.MapId;

            // 顯示訊息
            string groupIds = string.Join(", ", infos.Select(i => i.GroupId));
            this.toolStripStatusLabel1.Text = $"已複製 {infos.Count} 個群組 ({groupIds})，共 {allObjects.Count} 個物件 (選取位置後按 Ctrl+V 貼上)";
        }

        // 複製單一群組到剪貼簿（保留供相容）
        private void CopyGroupToClipboard(GroupThumbnailInfo info)
        {
            CopyMultipleGroupsToClipboard(new List<GroupThumbnailInfo> { info });
        }

        // 收集渲染除錯資訊
        private string CollectRenderingDebugInfo(GroupThumbnailInfo info, int imageSize, Bitmap previewImage)
        {
            var sb = new System.Text.StringBuilder();

            // 基本資訊
            sb.AppendLine($"=== 基本資訊 ===");
            sb.AppendLine($"GroupId: {info.GroupId}");
            sb.AppendLine($"S32 檔案: {info.S32FileName}");
            sb.AppendLine($"距離編碼: {info.DistanceCode}");
            sb.AppendLine();

            // 圖片資訊
            sb.AppendLine($"=== 圖片資訊 ===");
            sb.AppendLine($"預覽圖請求大小: {imageSize} x {imageSize} px");
            sb.AppendLine($"Bitmap 實際大小: {previewImage?.Width} x {previewImage?.Height} px");
            sb.AppendLine($"Bitmap 格式: {previewImage?.PixelFormat}");

            // 計算縮圖實際渲染範圍
            if (info.Objects.Count > 0)
            {
                int pixelMinX = int.MaxValue, pixelMaxX = int.MinValue;
                int pixelMinY = int.MaxValue, pixelMaxY = int.MinValue;
                foreach (var obj in info.Objects)
                {
                    int halfX = obj.X / 2;
                    int baseX = -24 * halfX;
                    int baseY = 63 * 12 - 12 * halfX;
                    int px = baseX + obj.X * 24 + obj.Y * 24;
                    int py = baseY + obj.Y * 12;
                    pixelMinX = Math.Min(pixelMinX, px);
                    pixelMaxX = Math.Max(pixelMaxX, px + 48);
                    pixelMinY = Math.Min(pixelMinY, py);
                    pixelMaxY = Math.Max(pixelMaxY, py + 48);
                }
                int actualW = pixelMaxX - pixelMinX + 16;
                int actualH = pixelMaxY - pixelMinY + 16;
                sb.AppendLine($"實際內容範圍: {actualW} x {actualH} px");
            }
            sb.AppendLine();

            // L4 物件統計
            sb.AppendLine($"=== L4 物件統計 ===");
            sb.AppendLine($"L4 物件數量: {info.Objects.Count}");

            // TileId 統計與渲染狀態
            var tileIdGroups = info.Objects.GroupBy(o => o.TileId).OrderBy(g => g.Key).ToList();
            sb.AppendLine($"不同 TileId 數量: {tileIdGroups.Count}");

            int okCount = 0, failCount = 0;
            var failedTiles = new List<string>();
            foreach (var group in tileIdGroups)
            {
                var firstObj = group.First();
                var tilArray = TileProvider.Instance.GetTilArray(firstObj.TileId);
                if (tilArray != null && tilArray.Count > 0 && firstObj.IndexId < tilArray.Count)
                    okCount++;
                else
                {
                    failCount++;
                    failedTiles.Add($"TileId:{firstObj.TileId}");
                }
            }
            sb.AppendLine($"可渲染: {okCount}, 無法渲染: {failCount}");
            if (failedTiles.Count > 0)
                sb.AppendLine($"失敗列表: {string.Join(", ", failedTiles)}");
            sb.AppendLine();

            // TileId 詳細列表
            sb.AppendLine($"=== TileId 詳細 ===");
            foreach (var group in tileIdGroups)
            {
                var firstObj = group.First();
                string tileStatus = CheckTileStatus(firstObj.TileId, firstObj.IndexId);
                sb.AppendLine($"TileId: {group.Key}, 數量: {group.Count()}, IndexId: {firstObj.IndexId} {tileStatus}");
            }
            sb.AppendLine();

            // Layer5 設定
            sb.AppendLine($"=== Layer5 設定 ===");
            sb.AppendLine($"有 Layer5 設定: {(info.HasLayer5Setting ? "是" : "否")}");
            if (info.HasLayer5Setting)
            {
                sb.AppendLine($"Layer5 Type: {info.Layer5Type} ({(info.Layer5Type == 0 ? "半透明" : "其他")})");
            }
            sb.AppendLine();

            // 座標範圍
            if (info.Objects.Count > 0)
            {
                int minX = info.Objects.Min(o => o.X);
                int maxX = info.Objects.Max(o => o.X);
                int minY = info.Objects.Min(o => o.Y);
                int maxY = info.Objects.Max(o => o.Y);
                sb.AppendLine($"=== 座標範圍 (Layer1) ===");
                sb.AppendLine($"X 範圍: {minX} ~ {maxX} (跨度: {maxX - minX + 1})");
                sb.AppendLine($"Y 範圍: {minY} ~ {maxY} (跨度: {maxY - minY + 1})");
            }

            return sb.ToString();
        }

        // 檢查 Tile 狀態
        private string CheckTileStatus(int tileId, int indexId)
        {
            try
            {
                var tilArray = TileProvider.Instance.GetTilArray(tileId);
                if (tilArray == null)
                    return "[TIL 不存在]";

                if (tilArray.Count == 0)
                    return "[TIL 空白]";

                if (indexId >= tilArray.Count)
                    return $"[IndexId 越界: {indexId} >= {tilArray.Count}]";

                return $"[OK, {tilArray.Count} 幀]";
            }
            catch (Exception ex)
            {
                return $"[錯誤: {ex.Message}]";
            }
        }

        // 顯示群組預覽對話框（可縮放）
        private void ShowGroupPreviewDialog(GroupThumbnailInfo info)
        {
            // 生成高解析度預覽圖（800x800）
            int baseSize = 800;
            Bitmap previewImage = GenerateGroupThumbnailForS32(info.S32Data, info.Objects, baseSize);

            if (previewImage == null)
                return;

            // 收集渲染除錯資訊
            var debugInfo = CollectRenderingDebugInfo(info, baseSize, previewImage);

            // 縮放狀態
            float currentZoom = 1.0f;
            float minZoom = 0.25f;
            float maxZoom = 4.0f;
            Point dragStart = Point.Empty;
            Point scrollOffset = Point.Empty;
            bool isDragging = false;

            // 建立預覽對話框（增加高度以容納除錯資訊）
            Form previewForm = new Form
            {
                Text = $"群組 {info.DistanceCode}:G{info.GroupId} - {info.Objects.Count} 個物件 (滾輪縮放, 拖曳平移)",
                Size = new Size(520, 720),
                StartPosition = FormStartPosition.CenterParent,
                FormBorderStyle = FormBorderStyle.Sizable,
                MaximizeBox = true,
                MinimizeBox = false
            };

            // 使用 Panel 作為容器，支援滾動
            Panel container = new Panel
            {
                Location = new Point(10, 10),
                Size = new Size(480, 400),
                Anchor = AnchorStyles.Top | AnchorStyles.Bottom | AnchorStyles.Left | AnchorStyles.Right,
                BorderStyle = BorderStyle.FixedSingle,
                BackColor = Colors.White,
                AutoScroll = true
            };

            PictureBox pb = new PictureBox
            {
                Image = previewImage,
                Size = previewImage.Size,
                Location = new Point(0, 0),
                SizeMode = PictureBoxSizeMode.Zoom,
                BackColor = Colors.White
            };

            // 更新 PictureBox 大小的函數
            Action updateZoom = () =>
            {
                int newWidth = (int)(baseSize * currentZoom);
                int newHeight = (int)(baseSize * currentZoom);
                pb.Size = new Size(newWidth, newHeight);
                previewForm.Text = $"群組 {info.GroupId} - {info.Objects.Count} 個物件 ({(int)(currentZoom * 100)}%)";
            };

            // 滾輪縮放
            pb.MouseWheel += (s, ev) =>
            {
                float oldZoom = currentZoom;
                if (ev.Delta.Height > 0)
                    currentZoom = Math.Min(currentZoom * 1.2f, maxZoom);
                else
                    currentZoom = Math.Max(currentZoom / 1.2f, minZoom);

                if (Math.Abs(oldZoom - currentZoom) > 0.001f)
                    updateZoom();
            };

            container.MouseWheel += (s, ev) =>
            {
                float oldZoom = currentZoom;
                if (ev.Delta.Height > 0)
                    currentZoom = Math.Min(currentZoom * 1.2f, maxZoom);
                else
                    currentZoom = Math.Max(currentZoom / 1.2f, minZoom);

                if (Math.Abs(oldZoom - currentZoom) > 0.001f)
                    updateZoom();
            };

            // 拖曳平移
            pb.MouseDown += (s, ev) =>
            {
                if (ev.GetButton() == MouseButtons.Left)
                {
                    isDragging = true;
                    dragStart = ev.Location.ToPoint();
                    pb.Cursor = Cursors.Hand;
                }
            };

            pb.MouseMove += (s, ev) =>
            {
                if (isDragging)
                {
                    int dx = (int)ev.Location.X - dragStart.X;
                    int dy = (int)ev.Location.Y - dragStart.Y;
                    container.AutoScrollPosition = new Point(
                        -container.AutoScrollPosition.X - dx,
                        -container.AutoScrollPosition.Y - dy);
                }
            };

            pb.MouseUp += (s, ev) =>
            {
                isDragging = false;
                pb.Cursor = Cursors.Default;
            };

            container.GetControls().Add(pb);

            // 縮放按鈕（位於預覽區下方）
            int buttonY = 420;
            Button btnZoomIn = new Button
            {
                Text = "+",
                Size = new Size(40, 30),
                Location = new Point(10, buttonY),
                Anchor = AnchorStyles.Bottom | AnchorStyles.Left
            };
            btnZoomIn.Click += (s, ev) =>
            {
                currentZoom = Math.Min(currentZoom * 1.5f, maxZoom);
                updateZoom();
            };

            Button btnZoomOut = new Button
            {
                Text = "-",
                Size = new Size(40, 30),
                Location = new Point(55, buttonY),
                Anchor = AnchorStyles.Bottom | AnchorStyles.Left
            };
            btnZoomOut.Click += (s, ev) =>
            {
                currentZoom = Math.Max(currentZoom / 1.5f, minZoom);
                updateZoom();
            };

            Button btnZoomReset = new Button
            {
                Text = "1:1",
                Size = new Size(40, 30),
                Location = new Point(100, buttonY),
                Anchor = AnchorStyles.Bottom | AnchorStyles.Left
            };
            btnZoomReset.Click += (s, ev) =>
            {
                currentZoom = 1.0f;
                updateZoom();
                container.AutoScrollPosition = Point.Empty;
            };

            Button btnGoto = new Button
            {
                Text = "跳轉到位置",
                Size = new Size(100, 30),
                Location = new Point(160, buttonY),
                Anchor = AnchorStyles.Bottom | AnchorStyles.Left
            };
            btnGoto.Click += (s, ev) =>
            {
                previewForm.Close();
                JumpToGroupLocation(info);
            };

            Button btnClose = new Button
            {
                Text = "關閉",
                Size = new Size(80, 30),
                Location = new Point(420, buttonY),
                Anchor = AnchorStyles.Bottom | AnchorStyles.Right
            };
            btnClose.Click += (s, ev) => previewForm.Close();

            // 顯示物件資訊
            Label lblInfo = new Label
            {
                Text = $"GroupId: {info.GroupId} | 物件數: {info.Objects.Count}",
                Location = new Point(270, buttonY + 5),
                Size = new Size(140, 20),
                ForeColor = Colors.Gray,
                Anchor = AnchorStyles.Bottom | AnchorStyles.Left
            };

            // 渲染除錯資訊區域
            GroupBox debugGroupBox = new GroupBox
            {
                Text = "Rendering Debug",
                Location = new Point(10, buttonY + 40),
                Size = new Size(480, 200),
                Anchor = AnchorStyles.Bottom | AnchorStyles.Left | AnchorStyles.Right
            };

            TextBox txtDebugInfo = new TextBox
            {
                Multiline = true,
                ReadOnly = true,
                ScrollBars = ScrollBars.Vertical,
                Font = new Font("Consolas", 9),
                Location = new Point(10, 20),
                Size = new Size(460, 170),
                Anchor = AnchorStyles.Top | AnchorStyles.Bottom | AnchorStyles.Left | AnchorStyles.Right,
                Text = debugInfo
            };
            debugGroupBox.GetControls().Add(txtDebugInfo);

            previewForm.GetControls().Add(container);
            previewForm.GetControls().Add(btnZoomIn);
            previewForm.GetControls().Add(btnZoomOut);
            previewForm.GetControls().Add(btnZoomReset);
            previewForm.GetControls().Add(btnGoto);
            previewForm.GetControls().Add(btnClose);
            previewForm.GetControls().Add(lblInfo);
            previewForm.GetControls().Add(debugGroupBox);

            previewForm.FormClosed += (s, ev) =>
            {
                previewImage.Dispose();
            };

            // 設定焦點讓滾輪可用
            previewForm.Shown += (s, ev) => container.Focus();

            previewForm.ShowDialog(this);
        }

        // 跳轉到群組位置
        private void JumpToGroupLocation(GroupThumbnailInfo info)
        {
            if (info.Objects.Count == 0 || info.S32Data == null)
                return;

            var obj = info.Objects[0];
            var s32Data = info.S32Data;

            // 計算螢幕座標
            int[] loc = s32Data.SegInfo.GetLoc(1.0);
            int mx = loc[0];
            int my = loc[1];

            int localBaseX = 0;
            int localBaseY = 63 * 12;
            localBaseX -= 24 * (obj.X / 2);
            localBaseY -= 12 * (obj.X / 2);

            // 計算世界座標
            int worldX = mx + localBaseX + obj.X * 24 + obj.Y * 24;
            int worldY = my + localBaseY + obj.Y * 12;

            // 捲動到該位置（世界座標）
            int viewportWidthWorld = (int)(s32MapPanel.Width / _viewState.ZoomLevel);
            int viewportHeightWorld = (int)(s32MapPanel.Height / _viewState.ZoomLevel);
            int scrollX = worldX - viewportWidthWorld / 2;
            int scrollY = worldY - viewportHeightWorld / 2;

            // 限制在有效範圍內（使用 ViewState 的限制，含緩衝區）
            scrollX = Math.Max(_viewState.MinScrollX, Math.Min(scrollX, _viewState.MaxScrollX));
            scrollY = Math.Max(_viewState.MinScrollY, Math.Min(scrollY, _viewState.MaxScrollY));

            _viewState.SetScrollSilent(scrollX, scrollY);

            // 高亮顯示該格子
            _editState.HighlightedS32Data = s32Data;
            _editState.HighlightedCellX = obj.X;
            _editState.HighlightedCellY = obj.Y;

            _mapViewerControl.Refresh();
            UpdateMiniMapViewportRect();

            this.toolStripStatusLabel1.Text = $"跳轉到群組 {info.DistanceCode}:G{info.GroupId}，位置 ({obj.X}, {obj.Y})，共 {info.Objects.Count} 個物件";
        }

        // 顯示 Layer4 群組所在的所有格子（綠色高亮）
        private void ShowLayer4GroupCells(GroupThumbnailInfo info)
        {
            if (info.Objects.Count == 0 || info.S32Data == null)
                return;

            var highlightCells = new List<(int globalX, int globalY)>();
            var s32Data = info.S32Data;

            // 計算 S32 的全域座標起點
            int s32StartX = s32Data.SegInfo.nLinBeginX * 2;
            int s32StartY = s32Data.SegInfo.nLinBeginY;

            // 收集該群組所有物件所在的唯一格子
            foreach (var obj in info.Objects)
            {
                // obj.X 是 Layer1 座標 (0-127)，obj.Y 是 0-63
                // 正規化為偶數（同一格的左半）
                int normalizedX = (obj.X / 2) * 2;
                int globalX = s32StartX + normalizedX;
                int globalY = s32StartY + obj.Y;

                var cellCoord = (globalX, globalY);
                if (!highlightCells.Contains(cellCoord))
                {
                    highlightCells.Add(cellCoord);
                }
            }

            if (highlightCells.Count == 0)
            {
                this.toolStripStatusLabel1.Text = $"找不到群組 {info.GroupId} 的位置";
                return;
            }

            // 設定高亮狀態
            _editState.GroupHighlightCells = highlightCells;

            // 跳轉到第一個位置
            JumpToGroupLocation(info);

            // 重新渲染
            RenderS32Map();

            this.toolStripStatusLabel1.Text = $"顯示群組 {info.DistanceCode}:G{info.GroupId} 的 {highlightCells.Count} 個格子（點擊其他地方清除）";
        }

        // 群組縮圖雙擊事件 - 顯示放大預覽
        private void lvGroupThumbnails_DoubleClick(object sender, EventArgs e)
        {
            if (lvGroupThumbnails.SelectedItems.Count == 0)
                return;

            var item = lvGroupThumbnails.SelectedItems[0];
            if (item.Tag is GroupThumbnailInfo info && info.Objects.Count > 0)
            {
                ShowGroupPreviewDialog(info);
            }
        }

        // 群組縮圖右鍵選單（支援多選）
        private void lvGroupThumbnails_MouseUp(object sender, MouseEventArgs e)
        {
            if (e.Buttons != Eto.Forms.MouseButtons.Alternate)
                return;

            if (lvGroupThumbnails.SelectedItems.Count == 0)
                return;

            // 收集所有選中群組的資訊
            var selectedInfos = new List<GroupThumbnailInfo>();
            int totalObjects = 0;
            foreach (IconTextListItem item in lvGroupThumbnails.SelectedItems)
            {
                if (item.Tag is GroupThumbnailInfo info && info.Objects.Count > 0)
                {
                    selectedInfos.Add(info);
                    totalObjects += info.Objects.Count;
                }
            }

            if (selectedInfos.Count == 0)
                return;

            // 建立右鍵選單
            ContextMenuStrip menu = new ContextMenuStrip();

            if (selectedInfos.Count == 1)
            {
                // 單選模式 - 顯示原有選項
                var info = selectedInfos[0];

                ToolStripMenuItem copyItem = new ToolStripMenuItem($"複製群組 {info.GroupId}");
                copyItem.Click += (s, ev) => CopyGroupToClipboard(info);

                ToolStripMenuItem gotoItem = new ToolStripMenuItem("跳轉到位置");
                gotoItem.Click += (s, ev) => JumpToGroupLocation(info);

                ToolStripMenuItem showCellsItem = new ToolStripMenuItem("顯示群組所在格子");
                showCellsItem.Click += (s, ev) => ShowLayer4GroupCells(info);

                ToolStripMenuItem detailItem = new ToolStripMenuItem($"列出 L4 明細 ({info.Objects.Count} 個物件)");
                detailItem.Click += (s, ev) => ShowLayer4Details(info);

                ToolStripMenuItem deleteItem = new ToolStripMenuItem($"刪除群組 {info.GroupId} ({info.Objects.Count} 個物件)");
                deleteItem.Click += (s, ev) => DeleteGroupFromMap(info);

                menu.Items.Add(copyItem);
                menu.Items.Add(gotoItem);
                menu.Items.Add(showCellsItem);
                menu.Items.Add(detailItem);
                menu.Items.Add(new ToolStripSeparator());

                ToolStripMenuItem saveMaterialItem = new ToolStripMenuItem($"儲存群組 {info.GroupId} 為素材...");
                saveMaterialItem.Click += (s, ev) => SaveGroupsAsMaterial(new List<GroupThumbnailInfo> { info });
                menu.Items.Add(saveMaterialItem);

                menu.Items.Add(new ToolStripSeparator());
                menu.Items.Add(deleteItem);

                // 變更群組 ID 選項
                menu.Items.Add(new ToolStripSeparator());

                ToolStripMenuItem changeIdItem = new ToolStripMenuItem($"變更群組 {info.GroupId} 的 ID...");
                changeIdItem.Click += (s, ev) => ChangeGroupId(selectedInfos, false);

                ToolStripMenuItem autoNewIdItem = new ToolStripMenuItem($"自動指定新群組 ID");
                autoNewIdItem.Click += (s, ev) => ChangeGroupId(selectedInfos, true);

                menu.Items.Add(changeIdItem);
                menu.Items.Add(autoNewIdItem);

                // Layer5 設定選項（僅在透明編輯模式或有選取格子時顯示）
                if (_editState.IsLayer5EditMode && _editState.SelectedCells.Count > 0)
                {
                    menu.Items.Add(new ToolStripSeparator());

                    ToolStripMenuItem setTransparentItem = new ToolStripMenuItem($"設定群組 {info.GroupId} 為透明 (Type=0)");
                    setTransparentItem.Click += (s, ev) => SetGroupLayer5Setting(new List<GroupThumbnailInfo> { info }, 0);

                    ToolStripMenuItem setDisappearItem = new ToolStripMenuItem($"設定群組 {info.GroupId} 為消失 (Type=1)");
                    setDisappearItem.Click += (s, ev) => SetGroupLayer5Setting(new List<GroupThumbnailInfo> { info }, 1);

                    ToolStripMenuItem removeLayer5Item = new ToolStripMenuItem($"移除群組 {info.GroupId} 的 Layer5 設定");
                    removeLayer5Item.Click += (s, ev) => RemoveGroupLayer5Setting(new List<GroupThumbnailInfo> { info });

                    menu.Items.Add(setTransparentItem);
                    menu.Items.Add(setDisappearItem);
                    menu.Items.Add(removeLayer5Item);
                }
            }
            else
            {
                // 多選模式 - 顯示批次操作選項
                string groupIds = string.Join(", ", selectedInfos.Select(i => i.GroupId));

                ToolStripMenuItem copyItem = new ToolStripMenuItem($"複製 {selectedInfos.Count} 個群組 ({totalObjects} 個物件)");
                copyItem.Click += (s, ev) => CopyMultipleGroupsToClipboard(selectedInfos);

                ToolStripMenuItem deleteItem = new ToolStripMenuItem($"刪除 {selectedInfos.Count} 個群組 ({totalObjects} 個物件)");
                deleteItem.Click += (s, ev) => DeleteMultipleGroupsFromMap(selectedInfos);

                menu.Items.Add(copyItem);
                menu.Items.Add(new ToolStripSeparator());

                ToolStripMenuItem saveMaterialItem = new ToolStripMenuItem($"儲存 {selectedInfos.Count} 個群組為素材...");
                saveMaterialItem.Click += (s, ev) => SaveGroupsAsMaterial(selectedInfos);
                menu.Items.Add(saveMaterialItem);

                menu.Items.Add(new ToolStripSeparator());
                menu.Items.Add(deleteItem);

                // 變更群組 ID 選項
                menu.Items.Add(new ToolStripSeparator());

                ToolStripMenuItem changeIdItem = new ToolStripMenuItem($"變更 {selectedInfos.Count} 個群組的 ID...");
                changeIdItem.Click += (s, ev) => ChangeGroupId(selectedInfos, false);

                ToolStripMenuItem autoNewIdItem = new ToolStripMenuItem($"自動指定新群組 ID（各自獨立）");
                autoNewIdItem.Click += (s, ev) => ChangeGroupId(selectedInfos, true);

                menu.Items.Add(changeIdItem);
                menu.Items.Add(autoNewIdItem);

                // Layer5 設定選項（僅在透明編輯模式或有選取格子時顯示）
                if (_editState.IsLayer5EditMode && _editState.SelectedCells.Count > 0)
                {
                    menu.Items.Add(new ToolStripSeparator());

                    ToolStripMenuItem setTransparentItem = new ToolStripMenuItem($"設定 {selectedInfos.Count} 個群組為透明 (Type=0)");
                    setTransparentItem.Click += (s, ev) => SetGroupLayer5Setting(selectedInfos, 0);

                    ToolStripMenuItem setDisappearItem = new ToolStripMenuItem($"設定 {selectedInfos.Count} 個群組為消失 (Type=1)");
                    setDisappearItem.Click += (s, ev) => SetGroupLayer5Setting(selectedInfos, 1);

                    ToolStripMenuItem removeLayer5Item = new ToolStripMenuItem($"移除 {selectedInfos.Count} 個群組的 Layer5 設定");
                    removeLayer5Item.Click += (s, ev) => RemoveGroupLayer5Setting(selectedInfos);

                    menu.Items.Add(setTransparentItem);
                    menu.Items.Add(setDisappearItem);
                    menu.Items.Add(removeLayer5Item);
                }
            }

            menu.Show(lvGroupThumbnails, e.Location);
        }

        // 從地圖刪除多個群組
        private void DeleteMultipleGroupsFromMap(List<GroupThumbnailInfo> infos)
        {
            // 收集所有要刪除的物件（使用 S32Data 和 Objects 組合）
            var allObjects = new List<(S32Data s32, ObjectTile obj)>();
            foreach (var info in infos)
            {
                if (info.S32Data != null)
                {
                    foreach (var obj in info.Objects)
                    {
                        allObjects.Add((info.S32Data, obj));
                    }
                }
            }

            if (allObjects.Count == 0)
            {
                WinFormsMessageBox.Show("選取的群組內沒有物件。", "提示", MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            string groupIds = string.Join(", ", infos.Select(i => $"{i.DistanceCode}:G{i.GroupId}"));

            // 確認刪除
            DialogResult result = WinFormsMessageBox.Show(
                $"確定要刪除 {infos.Count} 個群組嗎？\n" +
                $"群組: {groupIds}\n" +
                $"這將移除選取區域內的 {allObjects.Count} 個 Layer4 物件。",
                "確認刪除多個群組",
                MessageBoxButtons.YesNo,
                MessageBoxIcon.Warning);

            if (result != DialogResult.Yes)
                return;

            // 建立 Undo 記錄
            var undoAction = new UndoAction
            {
                Description = $"刪除 {infos.Count} 個群組 ({allObjects.Count} 個物件)"
            };

            // 刪除物件
            int deletedCount = 0;
            foreach (var (s32Data, obj) in allObjects)
            {
                // 記錄到 Undo
                undoAction.RemovedObjects.Add(new UndoObjectInfo
                {
                    S32FilePath = s32Data.FilePath,
                    GameX = s32Data.SegInfo.nLinBeginX + obj.X / 2,
                    GameY = s32Data.SegInfo.nLinBeginY + obj.Y,
                    LocalX = obj.X,
                    LocalY = obj.Y,
                    GroupId = obj.GroupId,
                    Layer = obj.Layer,
                    IndexId = obj.IndexId,
                    TileId = obj.TileId
                });

                s32Data.Layer4.Remove(obj);
                Layer4Index_Remove(s32Data, obj);
                s32Data.IsModified = true;
                deletedCount++;
            }

            // 記錄 Undo
            PushUndoAction(undoAction);

            // 清除已刪除群組的選取狀態
            foreach (var info in infos)
            {
                _editState.SelectedLayer4Groups.Remove(info.GroupId);
            }

            // 清除快取並重新渲染
            ClearS32BlockCache();
            RenderS32Map();

            // 更新 Layer5 異常檢查按鈕
            UpdateMapValidateButton();

            // 更新群組縮圖列表
            if (_editState.SelectedCells.Count > 0)
            {
                UpdateGroupThumbnailsList(_editState.SelectedCells);
            }
            else
            {
                UpdateGroupThumbnailsList();
            }

            this.toolStripStatusLabel1.Text = $"已刪除 {infos.Count} 個群組，共 {deletedCount} 個物件";
        }

        // 從地圖刪除群組（只刪除 info.Objects 中的物件，即選取區域內的物件）
        private void DeleteGroupFromMap(GroupThumbnailInfo info)
        {
            int groupId = info.GroupId;

            // 使用 info.Objects（已經是選取區域的交集）
            if (info.Objects == null || info.Objects.Count == 0 || info.S32Data == null)
            {
                WinFormsMessageBox.Show($"群組 {groupId} 在選取區域內沒有物件。", "提示", MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            var s32Data = info.S32Data;
            int totalCount = info.Objects.Count;

            // 確認刪除
            DialogResult result = WinFormsMessageBox.Show(
                $"確定要刪除群組 {info.DistanceCode}:G{groupId} 嗎？\n" +
                $"這將移除選取區域內的 {totalCount} 個 Layer4 物件。",
                "確認刪除群組",
                MessageBoxButtons.YesNo,
                MessageBoxIcon.Warning);

            if (result != DialogResult.Yes)
                return;

            // 建立 Undo 記錄
            var undoAction = new UndoAction
            {
                Description = $"刪除群組 {info.DistanceCode}:G{groupId} ({totalCount} 個物件)"
            };

            // 只刪除 info.Objects 中的物件（選取區域內的物件）
            int deletedCount = 0;
            foreach (var obj in info.Objects)
            {
                // 記錄到 Undo
                undoAction.RemovedObjects.Add(new UndoObjectInfo
                {
                    S32FilePath = s32Data.FilePath,
                    GameX = s32Data.SegInfo.nLinBeginX + obj.X / 2,
                    GameY = s32Data.SegInfo.nLinBeginY + obj.Y,
                    LocalX = obj.X,
                    LocalY = obj.Y,
                    GroupId = obj.GroupId,
                    Layer = obj.Layer,
                    IndexId = obj.IndexId,
                    TileId = obj.TileId
                });

                // 刪除物件
                if (s32Data.Layer4.Remove(obj))
                {
                    Layer4Index_Remove(s32Data, obj);
                    deletedCount++;
                    s32Data.IsModified = true;
                }
            }

            // 儲存 Undo 記錄
            if (undoAction.RemovedObjects.Count > 0)
            {
                PushUndoAction(undoAction);
            }

            // 清除已刪除群組的選取狀態
            _editState.SelectedLayer4Groups.Remove(groupId);

            // 清除快取並重新渲染（RenderS32Map 內部會在完成後自動 Invalidate）
            ClearS32BlockCache();
            RenderS32Map();

            // 更新 Layer5 異常檢查按鈕
            UpdateMapValidateButton();

            // 更新群組縮圖列表（保持選取區域的交集）
            if (_editState.SelectedCells != null && _editState.SelectedCells.Count > 0)
            {
                UpdateGroupThumbnailsList(_editState.SelectedCells);
            }
            else
            {
                UpdateGroupThumbnailsList();
            }

            this.toolStripStatusLabel1.Text = $"已刪除群組 {groupId}，共 {deletedCount} 個物件";
        }

        // 儲存群組為素材
        private void SaveGroupsAsMaterial(List<GroupThumbnailInfo> infos)
        {
            if (infos == null || infos.Count == 0)
                return;

            // 收集所有物件（使用 S32Data 和 Objects 組合）
            var allObjects = new List<(S32Data s32, ObjectTile obj)>();
            foreach (var info in infos)
            {
                if (info.S32Data != null)
                {
                    foreach (var obj in info.Objects)
                    {
                        allObjects.Add((info.S32Data, obj));
                    }
                }
            }

            if (allObjects.Count == 0)
            {
                WinFormsMessageBox.Show("選取的群組內沒有物件。", "提示", MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            // 預設素材名稱
            string defaultName = infos.Count == 1
                ? $"群組_{infos[0].GroupId}"
                : $"群組_{string.Join("_", infos.Take(3).Select(i => i.GroupId))}";

            using (var dialog = new L1MapViewer.Forms.ExportOptionsDialog(isFs3p: true, hasSelection: true))
            {
                if (dialog.ShowDialog(this) != DialogResult.Ok)
                    return;

                try
                {
                    // 計算物件的世界座標範圍
                    int minWorldX = int.MaxValue, minWorldY = int.MaxValue;
                    int maxWorldX = int.MinValue, maxWorldY = int.MinValue;

                    foreach (var (s32, obj) in allObjects)
                    {
                        int worldX = s32.SegInfo.nLinBeginX * 2 + obj.X;
                        int worldY = s32.SegInfo.nLinBeginY + obj.Y;
                        if (worldX < minWorldX) minWorldX = worldX;
                        if (worldY < minWorldY) minWorldY = worldY;
                        if (worldX > maxWorldX) maxWorldX = worldX;
                        if (worldY > maxWorldY) maxWorldY = worldY;
                    }

                    // 確保 minWorldX 是偶數，以保持相對座標的奇偶性
                    // 這樣原本在偶數位置的物件，相對座標也會是偶數
                    if (minWorldX % 2 != 0)
                    {
                        minWorldX -= 1;
                    }

                    // 建立 fs3p 資料 - OriginOffset 設為 0,0（RelativeX/Y 已經是相對座標）
                    var fs3p = new Fs3pData
                    {
                        Name = dialog.MaterialName,
                        LayerFlags = (ushort)(dialog.LayerFlags & 0x08), // 只保留 Layer4 flag
                        OriginOffsetX = 0,
                        OriginOffsetY = 0,
                        Width = maxWorldX - minWorldX + 1,
                        Height = maxWorldY - minWorldY + 1
                    };
                    fs3p.SetCreatedNow();

                    // 收集使用的 TileIds 和 GroupId 重新編號
                    HashSet<int> usedTileIds = new HashSet<int>();
                    Dictionary<int, int> groupIdMapping = new Dictionary<int, int>();
                    int nextGroupId = 0;

                    foreach (var (s32, obj) in allObjects)
                    {
                        int relX = s32.SegInfo.nLinBeginX * 2 + obj.X - minWorldX;
                        int relY = s32.SegInfo.nLinBeginY + obj.Y - minWorldY;

                        // 重新編號 GroupId
                        if (!groupIdMapping.TryGetValue(obj.GroupId, out int newGroupId))
                        {
                            newGroupId = nextGroupId++;
                            groupIdMapping[obj.GroupId] = newGroupId;
                        }

                        fs3p.Layer4Items.Add(new Fs3pLayer4Item
                        {
                            RelativeX = relX,
                            RelativeY = relY,
                            GroupId = newGroupId,
                            Layer = (byte)obj.Layer,
                            IndexId = (byte)obj.IndexId,
                            TileId = (ushort)obj.TileId
                        });

                        if (obj.TileId > 0)
                            usedTileIds.Add(obj.TileId);
                    }

                    // 打包 Tiles
                    if (dialog.IncludeTiles)
                    {
                        foreach (int tileId in usedTileIds)
                        {
                            byte[] tilData = L1PakReader.UnPack("Tile", $"{tileId}.til");
                            if (tilData != null)
                            {
                                fs3p.Tiles[tileId] = new TilePackageData
                                {
                                    OriginalTileId = tileId,
                                    Md5Hash = TileHashManager.CalculateMd5(tilData),
                                    TilData = tilData
                                };
                            }
                        }

                        // 檢查並處理 R版 tiles
                        if (fs3p.Tiles.Count > 0)
                        {
                            int remasterCount = fs3p.Tiles.Values.Count(t => L1MapViewer.Converter.L1Til.IsRemaster(t.TilData));
                            if (remasterCount > 0)
                            {
                                var result = WinFormsMessageBox.Show(
                                    $"素材中有 {remasterCount} 個 R版 (48x48) 圖塊。\n\n" +
                                    "是否要轉換為天1格式 (24x24)？\n\n" +
                                    "• 是 - 轉換為天1格式 (檔案較小，相容舊版)\n" +
                                    "• 否 - 保留 R版格式",
                                    "R版圖塊偵測",
                                    MessageBoxButtons.YesNo,
                                    MessageBoxIcon.Question,
                                    MessageBoxDefaultButton.Button1);  // 預設選「是」

                                if (result == DialogResult.Yes)
                                {
                                    // 轉換所有 R版 tiles 為 天1 格式
                                    foreach (var tileId in fs3p.Tiles.Keys.ToList())
                                    {
                                        var tile = fs3p.Tiles[tileId];
                                        if (L1MapViewer.Converter.L1Til.IsRemaster(tile.TilData))
                                        {
                                            tile.TilData = L1MapViewer.Converter.L1Til.DownscaleTil(tile.TilData);
                                            tile.Md5Hash = TileHashManager.CalculateMd5(tile.TilData);
                                        }
                                    }
                                }
                            }
                        }
                    }

                    // 產生縮圖
                    Bitmap thumbnail = GenerateGroupsThumbnail(infos, 128);
                    if (thumbnail != null)
                    {
                        using (var ms = new MemoryStream())
                        {
                            thumbnail.Save(ms, ImageFormat.Png);
                            fs3p.ThumbnailPng = ms.ToArray();
                        }
                        thumbnail.Dispose();
                    }

                    // 儲存到素材庫
                    var library = new MaterialLibrary();
                    string savedPath = library.SaveMaterial(fs3p);

                    toolStripStatusLabel1.Text = $"已儲存素材: {dialog.MaterialName} ({fs3p.Layer4Items.Count} 個物件, {fs3p.Tiles.Count} 圖塊)";

                    // 更新素材面板
                    RefreshMaterialsList();
                }
                catch (Exception ex)
                {
                    WinFormsMessageBox.Show($"儲存素材失敗: {ex.Message}", "錯誤", MessageBoxButtons.OK, MessageBoxIcon.Error);
                }
            }
        }

        // 產生多個群組的合併縮圖
        private Bitmap GenerateGroupsThumbnail(List<GroupThumbnailInfo> infos, int maxSize)
        {
            if (infos == null || infos.Count == 0)
                return null;

            try
            {
                // 收集所有物件
                var allObjects = new List<(S32Data s32, ObjectTile obj)>();
                foreach (var info in infos)
                {
                    if (info.S32Data != null)
                    {
                        foreach (var obj in info.Objects)
                        {
                            allObjects.Add((info.S32Data, obj));
                        }
                    }
                }

                if (allObjects.Count == 0)
                    return null;

                // 使用現有的群組縮圖生成方法
                return GenerateGroupThumbnail(allObjects, maxSize);
            }
            catch
            {
                return null;
            }
        }

        // 設定群組的 Layer5 設定（透明或消失）
        // 智慧選擇 S32：優先寫入群組所屬的 S32，座標無效時才寫入選取格子的 S32
        private void SetGroupLayer5Setting(List<GroupThumbnailInfo> infos, byte type)
        {
            if (_editState.SelectedCells.Count == 0)
            {
                WinFormsMessageBox.Show("請先選取格子", "提示", MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            int addedCount = 0;
            int updatedCount = 0;

            foreach (var cell in _editState.SelectedCells)
            {
                // 計算選取格子的全域遊戲座標
                int globalGameX = cell.S32Data.SegInfo.nLinBeginX + cell.LocalX / 2;
                int globalGameY = cell.S32Data.SegInfo.nLinBeginY + cell.LocalY;

                foreach (var info in infos)
                {
                    int groupId = info.GroupId;
                    S32Data groupS32 = info.S32Data;  // 群組所屬的 S32

                    // 計算在群組 S32 中的本地座標
                    int targetLocalX = (globalGameX - groupS32.SegInfo.nLinBeginX) * 2;
                    int targetLocalY = globalGameY - groupS32.SegInfo.nLinBeginY;

                    // 決定寫入哪個 S32
                    S32Data writeToS32;
                    int writeX, writeY;

                    if (targetLocalX >= 0 && targetLocalX <= 255 &&
                        targetLocalY >= 0 && targetLocalY <= 255)
                    {
                        // 座標有效，寫入群組所屬的 S32
                        writeToS32 = groupS32;
                        writeX = targetLocalX;
                        writeY = targetLocalY;
                    }
                    else
                    {
                        // 座標無效，寫入選取格子的 S32
                        writeToS32 = cell.S32Data;
                        writeX = cell.LocalX;
                        writeY = cell.LocalY;
                    }

                    // 檢查兩個 X 座標（偶數和奇數，同一個遊戲格子）
                    for (int layer5X = writeX; layer5X <= writeX + 1 && layer5X < 256; layer5X++)
                    {
                        var existingItem = writeToS32.Layer5.FirstOrDefault(l =>
                            l.X == layer5X && l.Y == writeY && l.ObjectIndex == groupId);

                        if (existingItem != null)
                        {
                            // 更新現有項目
                            if (existingItem.Type != type)
                            {
                                existingItem.Type = type;
                                updatedCount++;
                                writeToS32.IsModified = true;
                            }
                        }
                        else
                        {
                            // 新增 Layer5 項目
                            writeToS32.Layer5.Add(new Layer5Item
                            {
                                X = (byte)layer5X,
                                Y = (byte)writeY,
                                ObjectIndex = (ushort)groupId,
                                Type = type
                            });
                            addedCount++;
                            writeToS32.IsModified = true;
                        }
                    }
                }
            }

            // 重新渲染
            ClearS32BlockCache();
            RenderS32Map();

            // 更新 Layer5 異常檢查按鈕
            UpdateMapValidateButton();

            // 更新群組縮圖列表（使用第一個選取格子的資訊）
            if (_editState.SelectedCells.Count > 0)
            {
                var firstCell = _editState.SelectedCells[0];
                UpdateNearbyGroupThumbnails(firstCell.S32Data, firstCell.LocalX, firstCell.LocalY, 10);
            }

            string typeStr = type == 0 ? "透明" : "消失";
            string message = $"已設定 {infos.Count} 個群組為{typeStr}";
            if (addedCount > 0) message += $"，新增 {addedCount} 筆";
            if (updatedCount > 0) message += $"，更新 {updatedCount} 筆";
            this.toolStripStatusLabel1.Text = message;
        }

        // 移除群組的 Layer5 設定
        private void RemoveGroupLayer5Setting(List<GroupThumbnailInfo> infos)
        {
            if (_editState.SelectedCells.Count == 0)
            {
                WinFormsMessageBox.Show("請先選取格子", "提示", MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            int removedCount = 0;
            var groupIds = infos.Select(i => i.GroupId).ToHashSet();

            foreach (var cell in _editState.SelectedCells)
            {
                var s32Data = cell.S32Data;
                // Layer5 的 X 是 0-127 (Layer1 座標)，Y 是 0-63
                // 一個遊戲格子對應兩個 Layer1 X 座標（LocalX 和 LocalX+1）
                int layer5X1 = cell.LocalX;
                int layer5X2 = cell.LocalX + 1;
                int layer5Y = cell.LocalY;

                // 找出並移除符合條件的 Layer5 項目（兩個 X 座標都要檢查）
                var itemsToRemove = s32Data.Layer5
                    .Where(l => (l.X == layer5X1 || l.X == layer5X2) && l.Y == layer5Y && groupIds.Contains(l.ObjectIndex))
                    .ToList();

                foreach (var item in itemsToRemove)
                {
                    s32Data.Layer5.Remove(item);
                    removedCount++;
                    s32Data.IsModified = true;
                }
            }

            // 重新渲染
            ClearS32BlockCache();
            RenderS32Map();

            // 更新 Layer5 異常檢查按鈕
            UpdateMapValidateButton();

            // 更新群組縮圖列表（使用第一個選取格子的資訊）
            if (_editState.SelectedCells.Count > 0)
            {
                var firstCell = _editState.SelectedCells[0];
                UpdateNearbyGroupThumbnails(firstCell.S32Data, firstCell.LocalX, firstCell.LocalY, 10);
            }

            this.toolStripStatusLabel1.Text = $"已移除 {removedCount} 筆 Layer5 設定";
        }

        // 變更群組 ID
        private void ChangeGroupId(List<GroupThumbnailInfo> infos, bool autoAssign)
        {
            if (infos.Count == 0)
                return;

            // 收集所有涉及的 S32 檔案
            var affectedS32Files = new HashSet<S32Data>();
            foreach (var info in infos)
            {
                if (info.S32Data != null)
                {
                    affectedS32Files.Add(info.S32Data);
                }
            }

            if (affectedS32Files.Count == 0)
            {
                WinFormsMessageBox.Show("選取的群組內沒有物件。", "提示", MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            // 找出所有 S32 中的最大群組 ID
            int maxGroupId = 0;
            foreach (var s32 in affectedS32Files)
            {
                foreach (var obj in s32.Layer4)
                {
                    if (obj.GroupId > maxGroupId)
                        maxGroupId = obj.GroupId;
                }
            }

            int newGroupId;
            if (autoAssign)
            {
                // 自動指定：最大 ID + 1
                newGroupId = maxGroupId + 1;
            }
            else
            {
                // 讓使用者輸入 ID
                string oldIds = string.Join(", ", infos.Select(i => i.GroupId).Distinct());
                string prompt = infos.Count == 1
                    ? $"將群組 {infos[0].GroupId} 變更為新的 ID："
                    : $"將 {infos.Count} 個群組 ({oldIds}) 變更為同一個新 ID：";

                using (var inputForm = new Form())
                {
                    inputForm.Text = "變更群組 ID";
                    inputForm.Size = new Size(350, 180);
                    inputForm.SetFormBorderStyle(FormBorderStyle.FixedDialog);
                    inputForm.SetMaximizeBox(false);
                    inputForm.SetMinimizeBox(false);
                    inputForm.SetStartPosition(FormStartPosition.CenterParent);

                    Label lblPrompt = new Label
                    {
                        Text = prompt,
                        Size = new Size(310, 40)
                    };
                    lblPrompt.SetLocation(new Point(15, 15));

                    Label lblCurrentMax = new Label
                    {
                        Text = $"（目前最大群組 ID: {maxGroupId}）",
                        Size = new Size(200, 20),
                        ForeColor = Colors.Gray
                    };
                    lblCurrentMax.SetLocation(new Point(15, 55));

                    TextBox txtNewId = new TextBox
                    {
                        Size = new Size(150, 24),
                        Text = (maxGroupId + 1).ToString()
                    };
                    txtNewId.SetLocation(new Point(15, 80));

                    Button btnOk = new Button
                    {
                        Text = "確定",
                        Size = new Size(75, 28),
                        DialogResult = DialogResult.Ok
                    };
                    btnOk.SetLocation(new Point(170, 100));

                    Button btnCancel = new Button
                    {
                        Text = "取消",
                        Size = new Size(75, 28),
                        DialogResult = DialogResult.Cancel
                    };
                    btnCancel.SetLocation(new Point(255, 100));

                    inputForm.AcceptButton = btnOk;
                    inputForm.CancelButton = btnCancel;
                    inputForm.GetControls().Add(lblPrompt);
                    inputForm.GetControls().Add(lblCurrentMax);
                    inputForm.GetControls().Add(txtNewId);
                    inputForm.GetControls().Add(btnOk);
                    inputForm.GetControls().Add(btnCancel);

                    if (inputForm.ShowDialog(this) != DialogResult.Ok)
                        return;

                    if (!int.TryParse(txtNewId.Text, out newGroupId) || newGroupId < 0)
                    {
                        WinFormsMessageBox.Show("請輸入有效的群組 ID（非負整數）", "錯誤", MessageBoxButtons.OK, MessageBoxIcon.Error);
                        return;
                    }
                }
            }

            // 建立 Undo 動作
            var undoAction = new UndoAction
            {
                Description = $"變更 {infos.Count} 個群組的 ID"
            };

            int changedCount = 0;
            var oldGroupIds = infos.Select(i => i.GroupId).ToHashSet();

            // 如果是多選且自動指定，每個群組分配不同的新 ID
            if (autoAssign && infos.Count > 1)
            {
                int nextId = newGroupId;
                foreach (var info in infos)
                {
                    if (info.S32Data == null) continue;
                    var s32 = info.S32Data;
                    int oldId = info.GroupId;
                    int assignedId = nextId++;

                    foreach (var obj in info.Objects)
                    {
                        // 記錄 Undo 資訊
                        undoAction.RemovedObjects.Add(new UndoObjectInfo
                        {
                            S32FilePath = s32.FilePath,
                            GroupId = oldId,
                            LocalX = obj.X,
                            LocalY = obj.Y,
                            Layer = obj.Layer,
                            IndexId = obj.IndexId,
                            TileId = obj.TileId
                        });

                        // 變更 GroupId
                        obj.GroupId = assignedId;
                        s32.IsModified = true;
                        changedCount++;

                        // 記錄新狀態
                        undoAction.AddedObjects.Add(new UndoObjectInfo
                        {
                            S32FilePath = s32.FilePath,
                            GroupId = assignedId,
                            LocalX = obj.X,
                            LocalY = obj.Y,
                            Layer = obj.Layer,
                            IndexId = obj.IndexId,
                            TileId = obj.TileId
                        });
                    }

                    // 同時更新 Layer5 中的 ObjectIndex
                    foreach (var affectedS32 in affectedS32Files)
                    {
                        foreach (var l5Item in affectedS32.Layer5)
                        {
                            if (l5Item.ObjectIndex == oldId)
                            {
                                l5Item.ObjectIndex = (ushort)assignedId;
                            }
                        }
                    }
                }

                _editState.PushUndoAction(undoAction);

                // 重新渲染
                ClearS32BlockCache();
                RenderS32Map();

                // 更新群組列表
                if (_editState.SelectedCells.Count > 0)
                {
                    var firstCell = _editState.SelectedCells[0];
                    UpdateNearbyGroupThumbnails(firstCell.S32Data, firstCell.LocalX, firstCell.LocalY, 10);
                }

                this.toolStripStatusLabel1.Text = $"已將 {infos.Count} 個群組變更為新 ID（{newGroupId} ~ {nextId - 1}），共 {changedCount} 個物件";
            }
            else
            {
                // 單選或多選合併為同一 ID
                foreach (var info in infos)
                {
                    if (info.S32Data == null) continue;
                    var s32 = info.S32Data;
                    int oldId = info.GroupId;

                    foreach (var obj in info.Objects)
                    {
                        // 記錄 Undo 資訊
                        undoAction.RemovedObjects.Add(new UndoObjectInfo
                        {
                            S32FilePath = s32.FilePath,
                            GroupId = oldId,
                            LocalX = obj.X,
                            LocalY = obj.Y,
                            Layer = obj.Layer,
                            IndexId = obj.IndexId,
                            TileId = obj.TileId
                        });

                        // 變更 GroupId
                        obj.GroupId = newGroupId;
                        s32.IsModified = true;
                        changedCount++;

                        // 記錄新狀態
                        undoAction.AddedObjects.Add(new UndoObjectInfo
                        {
                            S32FilePath = s32.FilePath,
                            GroupId = newGroupId,
                            LocalX = obj.X,
                            LocalY = obj.Y,
                            Layer = obj.Layer,
                            IndexId = obj.IndexId,
                            TileId = obj.TileId
                        });
                    }

                    // 同時更新 Layer5 中的 ObjectIndex
                    foreach (var affectedS32 in affectedS32Files)
                    {
                        foreach (var l5Item in affectedS32.Layer5)
                        {
                            if (l5Item.ObjectIndex == oldId)
                            {
                                l5Item.ObjectIndex = (ushort)newGroupId;
                            }
                        }
                    }
                }

                _editState.PushUndoAction(undoAction);

                // 重新渲染
                ClearS32BlockCache();
                RenderS32Map();

                // 更新群組列表
                if (_editState.SelectedCells.Count > 0)
                {
                    var firstCell = _editState.SelectedCells[0];
                    UpdateNearbyGroupThumbnails(firstCell.S32Data, firstCell.LocalX, firstCell.LocalY, 10);
                }

                string oldIdsStr = string.Join(", ", oldGroupIds);
                this.toolStripStatusLabel1.Text = $"已將群組 {oldIdsStr} 變更為 {newGroupId}，共 {changedCount} 個物件";
            }
        }

        // 顯示 Layer4 群組明細對話框
        private void ShowLayer4Details(GroupThumbnailInfo info)
        {
            if (info == null || info.Objects.Count == 0 || info.S32Data == null)
                return;

            var s32 = info.S32Data;

            using (var form = new Form())
            {
                form.Text = $"群組 {info.DistanceCode}:G{info.GroupId} - L4 明細 ({info.Objects.Count} 個物件)";
                form.Size = new Size(700, 500);
                form.SetStartPosition(FormStartPosition.CenterParent);
                form.SetMinimizeBox(false);

                // ListView 顯示物件列表
                var listView = new ListView
                {
                    View = View.Details,
                    FullRowSelect = true,
                    GridLines = true,
                    CheckBoxes = true
                };

                listView.Columns.Add("", 30);  // 勾選欄
                listView.Columns.Add("S32 檔案", 120);
                listView.Columns.Add("X (L1)", 60);
                listView.Columns.Add("Y (L1)", 60);
                listView.Columns.Add("Layer", 50);
                listView.Columns.Add("IndexId", 70);
                listView.Columns.Add("TileId", 70);
                listView.Columns.Add("遊戲座標", 120);

                string fileName = System.IO.Path.GetFileName(s32.FilePath ?? "Unknown");

                // 填充資料
                foreach (var obj in info.Objects)
                {
                    // 計算遊戲座標
                    string gameCoord = "";
                    if (!string.IsNullOrEmpty(s32.FilePath))
                    {
                        string fileNameWithoutExt = System.IO.Path.GetFileNameWithoutExtension(s32.FilePath);
                        if (fileNameWithoutExt.Length >= 8)
                        {
                            try
                            {
                                int blockX = Convert.ToInt32(fileNameWithoutExt.Substring(0, 4), 16);
                                int blockY = Convert.ToInt32(fileNameWithoutExt.Substring(4, 4), 16);
                                int nLinBeginX = (blockX - 0x7FFF) * 64 + 0x7FFF - 64 + 1;
                                int nLinBeginY = (blockY - 0x7FFF) * 64 + 0x7FFF - 64 + 1;
                                int gameX = nLinBeginX + obj.X / 2;
                                int gameY = nLinBeginY + obj.Y;
                                gameCoord = $"{gameX}, {gameY}";
                            }
                            catch { }
                        }
                    }

                    var item = new ListViewItem("");
                    item.SubItems.Add(fileName);
                    item.SubItems.Add(obj.X.ToString());
                    item.SubItems.Add(obj.Y.ToString());
                    item.SubItems.Add(obj.Layer.ToString());
                    item.SubItems.Add(obj.IndexId.ToString());
                    item.SubItems.Add(obj.TileId.ToString());
                    item.SubItems.Add(gameCoord);
                    item.Tag = (s32, obj);
                    listView.Items.Add(item);
                }

                // 雙擊編輯項目
                listView.DoubleClick += (s, ev) =>
                {
                    if (listView.SelectedItems.Count == 0)
                        return;

                    var selectedItem = listView.SelectedItems[0];
                    if (!(selectedItem.Tag is (S32Data s32, ObjectTile obj)))
                        return;

                    // 建立編輯對話框
                    using (var editForm = new Form())
                    {
                        editForm.Text = $"編輯物件 - 群組 {info.GroupId}";
                        editForm.Size = new Size(300, 290);
                        editForm.SetFormBorderStyle(FormBorderStyle.FixedDialog);
                        editForm.SetMaximizeBox(false);
                        editForm.SetMinimizeBox(false);
                        editForm.SetStartPosition(FormStartPosition.CenterParent);

                        var lblX = new Label { Text = "X (L1):", Size = new Size(60, 20) };
                        lblX.SetLocation(new Point(20, 25));
                        var txtX = new TextBox { Text = obj.X.ToString(), Size = new Size(160, 22) };
                        txtX.SetLocation(new Point(90, 22));

                        var lblY = new Label { Text = "Y (L1):", Size = new Size(60, 20) };
                        lblY.SetLocation(new Point(20, 60));
                        var txtY = new TextBox { Text = obj.Y.ToString(), Size = new Size(160, 22) };
                        txtY.SetLocation(new Point(90, 57));

                        var lblLayer = new Label { Text = "Layer:", Size = new Size(60, 20) };
                        lblLayer.SetLocation(new Point(20, 95));
                        var txtLayer = new TextBox { Text = obj.Layer.ToString(), Size = new Size(160, 22) };
                        txtLayer.SetLocation(new Point(90, 92));

                        var lblIndexId = new Label { Text = "IndexId:", Size = new Size(60, 20) };
                        lblIndexId.SetLocation(new Point(20, 130));
                        var txtIndexId = new TextBox { Text = obj.IndexId.ToString(), Size = new Size(160, 22) };
                        txtIndexId.SetLocation(new Point(90, 127));

                        var lblTileId = new Label { Text = "TileId:", Size = new Size(60, 20) };
                        lblTileId.SetLocation(new Point(20, 165));
                        var txtTileId = new TextBox { Text = obj.TileId.ToString(), Size = new Size(160, 22) };
                        txtTileId.SetLocation(new Point(90, 162));

                        var btnOK = new Button { Text = "確定", Size = new Size(75, 28), DialogResult = DialogResult.Ok };
                        btnOK.SetLocation(new Point(90, 205));
                        var btnCancel = new Button { Text = "取消", Size = new Size(75, 28), DialogResult = DialogResult.Cancel };
                        btnCancel.SetLocation(new Point(175, 205));

                        editForm.GetControls().Add(lblX);
                        editForm.GetControls().Add(txtX);
                        editForm.GetControls().Add(lblY);
                        editForm.GetControls().Add(txtY);
                        editForm.GetControls().Add(lblLayer);
                        editForm.GetControls().Add(txtLayer);
                        editForm.GetControls().Add(lblIndexId);
                        editForm.GetControls().Add(txtIndexId);
                        editForm.GetControls().Add(lblTileId);
                        editForm.GetControls().Add(txtTileId);
                        editForm.GetControls().Add(btnOK);
                        editForm.GetControls().Add(btnCancel);
                        editForm.AcceptButton = btnOK;
                        editForm.CancelButton = btnCancel;

                        if (editForm.ShowDialog(form) == DialogResult.Ok)
                        {
                            if (!int.TryParse(txtX.Text, out int newX) ||
                                !int.TryParse(txtY.Text, out int newY) ||
                                !int.TryParse(txtLayer.Text, out int newLayer) ||
                                !int.TryParse(txtIndexId.Text, out int newIndexId) ||
                                !int.TryParse(txtTileId.Text, out int newTileId))
                            {
                                WinFormsMessageBox.Show("請輸入有效的數字", "錯誤", MessageBoxButtons.OK, MessageBoxIcon.Error);
                                return;
                            }

                            // 驗證範圍
                            if (newX < 0 || newX > 255 || newY < 0 || newY > 255)
                            {
                                WinFormsMessageBox.Show("X 和 Y 必須在 0-255 之間", "錯誤", MessageBoxButtons.OK, MessageBoxIcon.Error);
                                return;
                            }

                            // 記錄 Undo
                            var undoAction = new UndoAction { Description = $"編輯群組 {info.GroupId} 物件" };
                            undoAction.RemovedObjects.Add(new UndoObjectInfo
                            {
                                S32FilePath = s32.FilePath,
                                GroupId = obj.GroupId,
                                LocalX = obj.X,
                                LocalY = obj.Y,
                                Layer = obj.Layer,
                                IndexId = obj.IndexId,
                                TileId = obj.TileId
                            });

                            // 更新物件
                            obj.X = newX;
                            obj.Y = newY;
                            obj.Layer = newLayer;
                            obj.IndexId = newIndexId;
                            obj.TileId = newTileId;
                            s32.IsModified = true;

                            undoAction.AddedObjects.Add(new UndoObjectInfo
                            {
                                S32FilePath = s32.FilePath,
                                GroupId = obj.GroupId,
                                LocalX = newX,
                                LocalY = newY,
                                Layer = newLayer,
                                IndexId = newIndexId,
                                TileId = newTileId
                            });

                            _editState.PushUndoAction(undoAction);

                            // 更新 ListView
                            selectedItem.SubItems[2].Text = newX.ToString();
                            selectedItem.SubItems[3].Text = newY.ToString();
                            selectedItem.SubItems[4].Text = newLayer.ToString();
                            selectedItem.SubItems[5].Text = newIndexId.ToString();
                            selectedItem.SubItems[6].Text = newTileId.ToString();

                            // 重新計算遊戲座標
                            string gameCoord = "";
                            if (!string.IsNullOrEmpty(s32.FilePath))
                            {
                                string fileNameWithoutExt = System.IO.Path.GetFileNameWithoutExtension(s32.FilePath);
                                if (fileNameWithoutExt.Length >= 8)
                                {
                                    try
                                    {
                                        int blockX = Convert.ToInt32(fileNameWithoutExt.Substring(0, 4), 16);
                                        int blockY = Convert.ToInt32(fileNameWithoutExt.Substring(4, 4), 16);
                                        int nLinBeginX = (blockX - 0x7FFF) * 64 + 0x7FFF - 64 + 1;
                                        int nLinBeginY = (blockY - 0x7FFF) * 64 + 0x7FFF - 64 + 1;
                                        int gameX = nLinBeginX + newX / 2;
                                        int gameY = nLinBeginY + newY;
                                        gameCoord = $"{gameX}, {gameY}";
                                    }
                                    catch { }
                                }
                            }
                            selectedItem.SubItems[7].Text = gameCoord;

                            // 重新渲染
                            ClearS32BlockCache();
                            RenderS32Map();

                            this.toolStripStatusLabel1.Text = $"已更新物件: X={newX}, Y={newY}, Layer={newLayer}, IndexId={newIndexId}, TileId={newTileId}";
                        }
                    }
                };

                // 底部面板
                var bottomPanel = new Panel
                {
                    Size = new Size(680, 50)
                };

                var btnSelectAll = new Button
                {
                    Text = "全選",
                    Size = new Size(75, 26)
                };
                btnSelectAll.SetLocation(new Point(10, 12));
                btnSelectAll.Click += (s, ev) =>
                {
                    foreach (ListViewItem item in listView.Items)
                        item.Checked = true;
                };

                var btnSelectNone = new Button
                {
                    Text = "取消全選",
                    Size = new Size(75, 26)
                };
                btnSelectNone.SetLocation(new Point(95, 12));
                btnSelectNone.Click += (s, ev) =>
                {
                    foreach (ListViewItem item in listView.Items)
                        item.Checked = false;
                };

                var btnDeleteSelected = new Button
                {
                    Text = "刪除勾選項目",
                    Size = new Size(100, 26),
                    BackColor = Color.FromArgb(255, 200, 200)
                };
                btnDeleteSelected.SetLocation(new Point(200, 12));
                btnDeleteSelected.Click += (s, ev) =>
                {
                    var checkedItems = listView.CheckedItems.Cast<ListViewItem>().ToList();
                    if (checkedItems.Count == 0)
                    {
                        WinFormsMessageBox.Show("請先勾選要刪除的項目", "提示", MessageBoxButtons.OK, MessageBoxIcon.Information);
                        return;
                    }

                    if (WinFormsMessageBox.Show($"確定要刪除勾選的 {checkedItems.Count} 個物件嗎？\n此操作支援 Undo。",
                        "確認刪除", MessageBoxButtons.YesNo, MessageBoxIcon.Question) != DialogResult.Yes)
                        return;

                    // 收集要刪除的物件
                    var objectsToDelete = new List<(S32Data s32, ObjectTile obj)>();
                    foreach (ListViewItem item in checkedItems)
                    {
                        if (item.Tag is (S32Data s32, ObjectTile obj))
                        {
                            objectsToDelete.Add((s32, obj));
                        }
                    }

                    if (objectsToDelete.Count == 0)
                        return;

                    // 建立 Undo 動作
                    var undoAction = new UndoAction { Description = $"刪除群組 {info.GroupId} 中的 {checkedItems.Count} 個物件" };

                    // 執行刪除
                    int deletedCount = 0;
                    foreach (var (s32, obj) in objectsToDelete)
                    {
                        // 記錄 Undo 資訊
                        undoAction.RemovedObjects.Add(new UndoObjectInfo
                        {
                            S32FilePath = s32.FilePath,
                            GroupId = obj.GroupId,
                            LocalX = obj.X,
                            LocalY = obj.Y,
                            Layer = obj.Layer,
                            IndexId = obj.IndexId,
                            TileId = obj.TileId
                        });

                        // 從 Layer4 移除
                        s32.Layer4.Remove(obj);
                        Layer4Index_Remove(s32, obj);
                        s32.IsModified = true;
                        deletedCount++;
                    }

                    _editState.PushUndoAction(undoAction);

                    // 從 ListView 移除已刪除的項目
                    foreach (ListViewItem item in checkedItems)
                    {
                        listView.Items.Remove(item);
                    }

                    // 更新標題
                    form.Text = $"群組 {info.GroupId} - L4 明細 ({listView.Items.Count} 個物件)";

                    // 重新渲染
                    ClearS32BlockCache();
                    RenderS32Map();

                    // 更新群組列表
                    if (_editState.SelectedCells.Count > 0)
                    {
                        var firstCell = _editState.SelectedCells[0];
                        UpdateNearbyGroupThumbnails(firstCell.S32Data, firstCell.LocalX, firstCell.LocalY, 10);
                    }

                    this.toolStripStatusLabel1.Text = $"已刪除 {deletedCount} 個物件";

                    // 如果全部刪除完畢，關閉對話框
                    if (listView.Items.Count == 0)
                    {
                        WinFormsMessageBox.Show("群組內所有物件已刪除", "提示", MessageBoxButtons.OK, MessageBoxIcon.Information);
                        form.Close();
                    }
                };

                var btnExportCsv = new Button
                {
                    Text = "匯出 CSV",
                    Size = new Size(85, 26)
                };
                btnExportCsv.SetLocation(new Point(320, 12));
                btnExportCsv.Click += (s, ev) =>
                {
                    using (var saveDialog = new SaveFileDialog())
                    {
                        saveDialog.Filter = "CSV 檔案|*.csv";
                        saveDialog.FileName = $"Group_{info.GroupId}_L4.csv";
                        saveDialog.Title = "匯出 Layer4 明細";

                        if (saveDialog.ShowDialog(this) == DialogResult.Ok)
                        {
                            try
                            {
                                using (var writer = new System.IO.StreamWriter(saveDialog.FileName, false, System.Text.Encoding.UTF8))
                                {
                                    // 寫入標題列
                                    writer.WriteLine("GroupId,S32檔案,X(L1),Y(L1),Layer,IndexId,TileId,遊戲座標X,遊戲座標Y");

                                    // 寫入資料
                                    foreach (ListViewItem item in listView.Items)
                                    {
                                        string s32File = item.SubItems[1].Text;
                                        string x = item.SubItems[2].Text;
                                        string y = item.SubItems[3].Text;
                                        string layer = item.SubItems[4].Text;
                                        string indexId = item.SubItems[5].Text;
                                        string tileId = item.SubItems[6].Text;
                                        string gameCoord = item.SubItems[7].Text;
                                        string gameX = "", gameY = "";
                                        if (!string.IsNullOrEmpty(gameCoord) && gameCoord.Contains(","))
                                        {
                                            var parts = gameCoord.Split(',');
                                            gameX = parts[0].Trim();
                                            gameY = parts.Length > 1 ? parts[1].Trim() : "";
                                        }

                                        writer.WriteLine($"{info.GroupId},{s32File},{x},{y},{layer},{indexId},{tileId},{gameX},{gameY}");
                                    }
                                }

                                WinFormsMessageBox.Show($"已匯出 {listView.Items.Count} 筆資料到\n{saveDialog.FileName}", "匯出成功", MessageBoxButtons.OK, MessageBoxIcon.Information);
                            }
                            catch (Exception ex)
                            {
                                Console.WriteLine($"[Export] Error: {ex}");
                        WinFormsMessageBox.Show($"匯出失敗: {ex.Message}\n\n{ex.StackTrace}", "錯誤", MessageBoxButtons.OK, MessageBoxIcon.Error);
                            }
                        }
                    }
                };

                var btnClose = new Button
                {
                    Text = "關閉",
                    Size = new Size(75, 26)
                };
                btnClose.SetLocation(new Point(580, 12));
                btnClose.Click += (s, ev) => form.Close();

                bottomPanel.GetControls().Add(btnSelectAll);
                bottomPanel.GetControls().Add(btnSelectNone);
                bottomPanel.GetControls().Add(btnDeleteSelected);
                bottomPanel.GetControls().Add(btnExportCsv);
                bottomPanel.GetControls().Add(btnClose);

                // 使用 TableLayout 來正確安排佈局
                var layout = new Eto.Forms.TableLayout
                {
                    Rows =
                    {
                        new Eto.Forms.TableRow(listView) { ScaleHeight = true },
                        new Eto.Forms.TableRow(bottomPanel)
                    }
                };
                form.Content = layout;

                form.ShowDialog(this);
            }
        }

        // ===== 工具列按鈕事件處理 =====

        private void btnToolCopy_Click(object sender, EventArgs e)
        {
            CopySelectedCells();
        }

        private void btnToolPaste_Click(object sender, EventArgs e)
        {
            PasteSelectedCells();
        }

        private void btnToolDelete_Click(object sender, EventArgs e)
        {
            DeleteSelectedLayer4Objects();
        }

        private void btnToolUndo_Click(object sender, EventArgs e)
        {
            UndoLastAction();
        }

        private void btnToolRedo_Click(object sender, EventArgs e)
        {
            RedoLastAction();
        }

        private void btnToolSave_Click(object sender, EventArgs e)
        {
            btnSaveS32_Click(sender, e);
        }

        private void btnToolCellInfo_Click(object sender, EventArgs e)
        {
            // 如果有選取區域，顯示第一個選取格子的詳細資訊
            if (_editState.SelectedCells.Count > 0)
            {
                var firstCell = _editState.SelectedCells[0];
                ShowCellLayersDialog(firstCell.LocalX, firstCell.LocalY);
            }
            else
            {
                this.toolStripStatusLabel1.Text = "請先使用左鍵選取格子";
            }
        }

        private void btnToolReplaceTile_Click(object sender, EventArgs e)
        {
            // 檢查是否已載入地圖
            if (_document.S32Files.Count == 0)
            {
                WinFormsMessageBox.Show("請先載入地圖", "提示", MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            // 創建替換對話框
            Form replaceForm = new Form();
            replaceForm.Text = "批次替換 TileId";
            replaceForm.Size = new Size(420, 350);
            replaceForm.SetFormBorderStyle(FormBorderStyle.FixedDialog);
            replaceForm.SetStartPosition(FormStartPosition.CenterParent);
            replaceForm.SetMaximizeBox(false);
            replaceForm.SetMinimizeBox(false);

            // 圖層選擇
            GroupBox gbLayer = new GroupBox();
            gbLayer.Text = "選擇圖層";
            gbLayer.SetLocation(new Point(15, 10));
            gbLayer.Size = new Size(375, 50);
            replaceForm.GetControls().Add(gbLayer);

            RadioButton rbLayer1 = new RadioButton { Text = "Layer1 (地板)", Size = new Size(110, 20), Checked = true };
            rbLayer1.SetLocation(new Point(15, 20));
            RadioButton rbLayer2 = new RadioButton { Text = "Layer2 (索引)", Size = new Size(110, 20) };
            rbLayer2.SetLocation(new Point(135, 20));
            RadioButton rbLayer4 = new RadioButton { Text = "Layer4 (物件)", Size = new Size(110, 20) };
            rbLayer4.SetLocation(new Point(255, 20));
            gbLayer.GetControls().Add(rbLayer1);
            gbLayer.GetControls().Add(rbLayer2);
            gbLayer.GetControls().Add(rbLayer4);

            // 來源設定
            GroupBox gbSource = new GroupBox();
            gbSource.Text = "來源";
            gbSource.SetLocation(new Point(15, 65));
            gbSource.Size = new Size(375, 80);
            replaceForm.GetControls().Add(gbSource);

            Label lblSrcTileId = new Label { Text = "TileId:", Size = new Size(55, 20) };
            lblSrcTileId.SetLocation(new Point(15, 25));
            TextBox txtSrcTileId = new TextBox { Size = new Size(100, 22) };
            txtSrcTileId.SetLocation(new Point(75, 22));
            Label lblSrcIndexId = new Label { Text = "IndexId:", Size = new Size(55, 20) };
            lblSrcIndexId.SetLocation(new Point(190, 25));
            TextBox txtSrcIndexId = new TextBox { Size = new Size(100, 22) };
            txtSrcIndexId.SetLocation(new Point(250, 22));
            CheckBox chkMatchIndexId = new CheckBox { Text = "比對 IndexId", Size = new Size(120, 20), Checked = true };
            chkMatchIndexId.SetLocation(new Point(15, 50));
            gbSource.GetControls().Add(lblSrcTileId);
            gbSource.GetControls().Add(txtSrcTileId);
            gbSource.GetControls().Add(lblSrcIndexId);
            gbSource.GetControls().Add(txtSrcIndexId);
            gbSource.GetControls().Add(chkMatchIndexId);

            // 目標設定
            GroupBox gbTarget = new GroupBox();
            gbTarget.Text = "替換為";
            gbTarget.SetLocation(new Point(15, 150));
            gbTarget.Size = new Size(375, 80);
            replaceForm.GetControls().Add(gbTarget);

            Label lblDstTileId = new Label { Text = "TileId:", Size = new Size(55, 20) };
            lblDstTileId.SetLocation(new Point(15, 25));
            TextBox txtDstTileId = new TextBox { Size = new Size(100, 22) };
            txtDstTileId.SetLocation(new Point(75, 22));
            Label lblDstIndexId = new Label { Text = "IndexId:", Size = new Size(55, 20) };
            lblDstIndexId.SetLocation(new Point(190, 25));
            TextBox txtDstIndexId = new TextBox { Size = new Size(100, 22) };
            txtDstIndexId.SetLocation(new Point(250, 22));
            CheckBox chkReplaceIndexId = new CheckBox { Text = "替換 IndexId", Size = new Size(120, 20), Checked = true };
            chkReplaceIndexId.SetLocation(new Point(15, 50));
            gbTarget.GetControls().Add(lblDstTileId);
            gbTarget.GetControls().Add(txtDstTileId);
            gbTarget.GetControls().Add(lblDstIndexId);
            gbTarget.GetControls().Add(txtDstIndexId);
            gbTarget.GetControls().Add(chkReplaceIndexId);

            // 按鈕
            Button btnPreview = new Button { Text = "預覽", Size = new Size(80, 30) };
            btnPreview.SetLocation(new Point(70, 245));
            Button btnExecute = new Button { Text = "執行替換", Size = new Size(80, 30) };
            btnExecute.SetLocation(new Point(160, 245));
            Button btnCancel = new Button { Text = "取消", Size = new Size(80, 30) };
            btnCancel.SetLocation(new Point(250, 245));
            btnCancel.Click += (s, args) => replaceForm.Close();
            replaceForm.GetControls().Add(btnPreview);
            replaceForm.GetControls().Add(btnExecute);
            replaceForm.GetControls().Add(btnCancel);

            // 結果標籤
            Label lblResult = new Label { Text = "", Size = new Size(375, 20), ForeColor = Colors.Blue };
            lblResult.SetLocation(new Point(15, 285));
            replaceForm.GetControls().Add(lblResult);

            // 預覽功能
            btnPreview.Click += (s, args) =>
            {
                if (!int.TryParse(txtSrcTileId.Text, out int srcTileId))
                {
                    WinFormsMessageBox.Show("請輸入有效的來源 TileId", "錯誤", MessageBoxButtons.OK, MessageBoxIcon.Error);
                    return;
                }

                int srcIndexId = 0;
                bool matchIndex = chkMatchIndexId.Checked == true;
                if (matchIndex && !int.TryParse(txtSrcIndexId.Text, out srcIndexId))
                {
                    WinFormsMessageBox.Show("請輸入有效的來源 IndexId", "錯誤", MessageBoxButtons.OK, MessageBoxIcon.Error);
                    return;
                }

                int matchCount = 0;
                int s32Count = 0;

                foreach (var kvp in _document.S32Files)
                {
                    S32Data s32Data = kvp.Value;
                    bool hasMatch = false;

                    if (rbLayer1.Checked == true)
                    {
                        for (int y = 0; y < 64; y++)
                        {
                            for (int x = 0; x < 128; x++)
                            {
                                var cell = s32Data.Layer1[y, x];
                                if (cell.TileId == srcTileId && (!matchIndex || cell.IndexId == srcIndexId))
                                {
                                    matchCount++;
                                    hasMatch = true;
                                }
                            }
                        }
                    }
                    else if (rbLayer2.Checked == true)
                    {
                        foreach (var item in s32Data.Layer2)
                        {
                            if (item.TileId == srcTileId && (!matchIndex || item.IndexId == srcIndexId))
                            {
                                matchCount++;
                                hasMatch = true;
                            }
                        }
                    }
                    else if (rbLayer4.Checked == true)
                    {
                        foreach (var obj in s32Data.Layer4)
                        {
                            if (obj.TileId == srcTileId && (!matchIndex || obj.IndexId == srcIndexId))
                            {
                                matchCount++;
                                hasMatch = true;
                            }
                        }
                    }

                    if (hasMatch) s32Count++;
                }

                string layerName = rbLayer1.Checked ? "Layer1" : (rbLayer2.Checked ? "Layer2" : "Layer4");
                lblResult.Text = $"[{layerName}] 找到 {matchCount} 個匹配項目，分布在 {s32Count} 個 S32 檔案";
            };

            // 執行替換功能
            btnExecute.Click += (s, args) =>
            {
                if (!int.TryParse(txtSrcTileId.Text, out int srcTileId) ||
                    !int.TryParse(txtDstTileId.Text, out int dstTileId))
                {
                    WinFormsMessageBox.Show("請輸入有效的來源和目標 TileId", "錯誤", MessageBoxButtons.OK, MessageBoxIcon.Error);
                    return;
                }

                int srcIndexId = 0, dstIndexId = 0;
                bool matchIndex = chkMatchIndexId.Checked == true;
                bool replaceIndex = chkReplaceIndexId.Checked == true;

                if (matchIndex && !int.TryParse(txtSrcIndexId.Text, out srcIndexId))
                {
                    WinFormsMessageBox.Show("請輸入有效的來源 IndexId", "錯誤", MessageBoxButtons.OK, MessageBoxIcon.Error);
                    return;
                }
                if (replaceIndex && !int.TryParse(txtDstIndexId.Text, out dstIndexId))
                {
                    WinFormsMessageBox.Show("請輸入有效的目標 IndexId", "錯誤", MessageBoxButtons.OK, MessageBoxIcon.Error);
                    return;
                }

                string layerName = rbLayer1.Checked == true ? "Layer1" : (rbLayer2.Checked == true ? "Layer2" : "Layer4");
                string matchInfo = matchIndex ? $"TileId={srcTileId}, IndexId={srcIndexId}" : $"TileId={srcTileId}";
                string replaceInfo = replaceIndex ? $"TileId={dstTileId}, IndexId={dstIndexId}" : $"TileId={dstTileId}";

                var confirmResult = WinFormsMessageBox.Show(
                    $"確定要在 [{layerName}] 將所有 {matchInfo}\n替換為 {replaceInfo} 嗎？\n\n此操作會影響所有已載入的 S32 檔案。",
                    "確認替換",
                    MessageBoxButtons.YesNo,
                    MessageBoxIcon.Warning);

                if (confirmResult != DialogResult.Yes) return;

                int replacedCount = 0;
                HashSet<string> modifiedS32Files = new HashSet<string>();

                foreach (var kvp in _document.S32Files)
                {
                    S32Data s32Data = kvp.Value;
                    bool hasModified = false;

                    if (rbLayer1.Checked == true)
                    {
                        for (int y = 0; y < 64; y++)
                        {
                            for (int x = 0; x < 128; x++)
                            {
                                var cell = s32Data.Layer1[y, x];
                                if (cell.TileId == srcTileId && (!matchIndex || cell.IndexId == srcIndexId))
                                {
                                    cell.TileId = dstTileId;
                                    if (replaceIndex) cell.IndexId = dstIndexId;
                                    cell.IsModified = true;
                                    replacedCount++;
                                    hasModified = true;
                                }
                            }
                        }
                    }
                    else if (rbLayer2.Checked == true)
                    {
                        foreach (var item in s32Data.Layer2)
                        {
                            if (item.TileId == srcTileId && (!matchIndex || item.IndexId == srcIndexId))
                            {
                                item.TileId = (ushort)dstTileId;
                                if (replaceIndex) item.IndexId = (byte)dstIndexId;
                                replacedCount++;
                                hasModified = true;
                            }
                        }
                    }
                    else if (rbLayer4.Checked == true)
                    {
                        foreach (var obj in s32Data.Layer4)
                        {
                            if (obj.TileId == srcTileId && (!matchIndex || obj.IndexId == srcIndexId))
                            {
                                obj.TileId = dstTileId;
                                if (replaceIndex) obj.IndexId = dstIndexId;
                                replacedCount++;
                                hasModified = true;
                            }
                        }
                    }

                    if (hasModified)
                    {
                        if (!s32Data.Layer6.Contains(dstTileId))
                        {
                            s32Data.Layer6.Add(dstTileId);
                        }
                        s32Data.IsModified = true;
                        modifiedS32Files.Add(kvp.Key);
                    }
                }

                ClearS32BlockCache();
                RenderS32Map();
                UpdateTileList();

                WinFormsMessageBox.Show($"替換完成！\n共替換 {replacedCount} 個項目\n影響 {modifiedS32Files.Count} 個 S32 檔案\n\n請記得儲存修改。",
                    "完成", MessageBoxButtons.OK, MessageBoxIcon.Information);

                this.toolStripStatusLabel1.Text = $"[{layerName}] 已替換 {replacedCount} 個項目，影響 {modifiedS32Files.Count} 個 S32 檔案";
                replaceForm.Close();
            };

            replaceForm.ShowDialog(this);
        }

        // 清除所有第七層（傳送點）資料
        private void btnToolClearLayer7_Click(object sender, EventArgs e)
        {
            if (_document.S32Files.Count == 0)
            {
                WinFormsMessageBox.Show("請先載入地圖", "提示", MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            // 計算總共有多少個第七層資料
            int totalLayer7Count = 0;
            int affectedS32Count = 0;
            foreach (var s32Data in _document.S32Files.Values)
            {
                if (s32Data.Layer7 != null && s32Data.Layer7.Count > 0)
                {
                    totalLayer7Count += s32Data.Layer7.Count;
                    affectedS32Count++;
                }
            }

            if (totalLayer7Count == 0)
            {
                WinFormsMessageBox.Show("沒有第七層（傳送點）資料需要清除", "提示", MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            // 確認刪除
            var confirmResult = WinFormsMessageBox.Show(
                $"確定要清除所有第七層（傳送點）資料嗎？\n\n" +
                $"共 {totalLayer7Count} 筆傳送點資料\n" +
                $"分布在 {affectedS32Count} 個 S32 檔案中\n\n" +
                $"此操作可以使用 Undo 還原。",
                "確認清除",
                MessageBoxButtons.YesNo,
                MessageBoxIcon.Warning);

            if (confirmResult != DialogResult.Yes) return;

            // 建立 Undo 記錄
            var undoAction = new UndoAction
            {
                Description = $"清除所有第七層資料 ({totalLayer7Count} 筆)"
            };

            // 備份並清除所有第七層資料
            int clearedCount = 0;
            foreach (var kvp in _document.S32Files)
            {
                S32Data s32Data = kvp.Value;
                if (s32Data.Layer7 != null && s32Data.Layer7.Count > 0)
                {
                    // 備份到 Undo（儲存為 Layer7Backup）
                    foreach (var item in s32Data.Layer7)
                    {
                        undoAction.RemovedLayer7Items.Add(new UndoLayer7Info
                        {
                            S32FilePath = kvp.Key,
                            Name = item.Name,
                            X = item.X,
                            Y = item.Y,
                            TargetMapId = item.TargetMapId,
                            PortalId = item.PortalId
                        });
                    }

                    clearedCount += s32Data.Layer7.Count;
                    s32Data.Layer7.Clear();
                    s32Data.IsModified = true;
                }
            }

            // 加入 Undo 堆疊
            PushUndoAction(undoAction);

            // 重新渲染
            RenderS32Map();

            this.toolStripStatusLabel1.Text = $"已清除 {clearedCount} 筆第七層（傳送點）資料，請記得儲存";
        }

        // 清除指定格子的各層資料
        private void btnToolClearCell_Click(object sender, EventArgs e)
        {
            if (_document.S32Files.Count == 0)
            {
                WinFormsMessageBox.Show("請先載入地圖", "提示", MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            // 如果有選取區域，直接批量清除
            if (_editState.SelectedCells.Count > 0)
            {
                ClearSelectedCellsWithDialog();
                return;
            }

            // 沒有選取區域，顯示單格清除對話框
            ShowSingleCellClearDialog();
        }

        // 批量清除選取區域的對話框
        private void ClearSelectedCellsWithDialog()
        {
            Form clearForm = new Form();
            clearForm.Text = $"批量清除格子資料 - 已選取 {_editState.SelectedCells.Count} 格";
            clearForm.Size = new Size(320, 320);
            clearForm.SetFormBorderStyle(FormBorderStyle.FixedDialog);
            clearForm.SetStartPosition(FormStartPosition.CenterParent);
            clearForm.SetMaximizeBox(false);
            clearForm.SetMinimizeBox(false);

            // 選擇要清除的層
            Label lblLayers = new Label();
            lblLayers.Text = $"選擇要清除的層 (共 {_editState.SelectedCells.Count} 格):";
            lblLayers.SetLocation(new Point(20, 20));
            lblLayers.Size = new Size(250, 20);
            clearForm.GetControls().Add(lblLayers);

            CheckBox chkL1 = new CheckBox();
            chkL1.Text = "第1層 (地板)";
            chkL1.SetLocation(new Point(30, 50));
            chkL1.Size = new Size(150, 20);
            chkL1.Checked = true;
            clearForm.GetControls().Add(chkL1);

            CheckBox chkL3 = new CheckBox();
            chkL3.Text = "第3層 (屬性) - 設為可通行";
            chkL3.SetLocation(new Point(30, 75));
            chkL3.Size = new Size(200, 20);
            chkL3.Checked = true;
            clearForm.GetControls().Add(chkL3);

            CheckBox chkL4 = new CheckBox();
            chkL4.Text = "第4層 (物件)";
            chkL4.SetLocation(new Point(30, 100));
            chkL4.Size = new Size(150, 20);
            chkL4.Checked = true;
            clearForm.GetControls().Add(chkL4);

            CheckBox chkL5 = new CheckBox();
            chkL5.Text = "第5層 (透明圖塊)";
            chkL5.SetLocation(new Point(30, 125));
            chkL5.Size = new Size(150, 20);
            clearForm.GetControls().Add(chkL5);

            CheckBox chkL7 = new CheckBox();
            chkL7.Text = "第7層 (傳送點)";
            chkL7.SetLocation(new Point(30, 150));
            chkL7.Size = new Size(150, 20);
            clearForm.GetControls().Add(chkL7);

            CheckBox chkL8 = new CheckBox();
            chkL8.Text = "第8層 (特效)";
            chkL8.SetLocation(new Point(30, 175));
            chkL8.Size = new Size(150, 20);
            clearForm.GetControls().Add(chkL8);

            // 執行按鈕
            Button btnExecute = new Button();
            btnExecute.Text = "清除";
            btnExecute.SetLocation(new Point(60, 220));
            btnExecute.Size = new Size(80, 30);
            clearForm.GetControls().Add(btnExecute);

            Button btnCancel = new Button();
            btnCancel.Text = "取消";
            btnCancel.SetLocation(new Point(160, 220));
            btnCancel.Size = new Size(80, 30);
            btnCancel.Click += (s, args) => clearForm.Close();
            clearForm.GetControls().Add(btnCancel);

            btnExecute.Click += (s, args) =>
            {
                int totalL1 = 0, totalL3 = 0, totalL4 = 0, totalL5 = 0, totalL7 = 0, totalL8 = 0;
                HashSet<S32Data> modifiedS32s = new HashSet<S32Data>();

                // 建立選取格子的全域座標集合 (用於 Layer4 跨區塊物件)
                var selectedGlobalCells = new HashSet<(int x, int y)>();
                foreach (var cell in _editState.SelectedCells)
                {
                    int globalX = cell.S32Data.SegInfo.nLinBeginX + cell.LocalX / 2;
                    int globalY = cell.S32Data.SegInfo.nLinBeginY + cell.LocalY;
                    selectedGlobalCells.Add((globalX, globalY));
                }

                foreach (var cell in _editState.SelectedCells)
                {
                    S32Data s32Data = cell.S32Data;
                    int layer1X = cell.LocalX;
                    int localY = cell.LocalY;
                    int layer3X = layer1X / 2;

                    // 清除第1層
                    if (chkL1.Checked == true && layer1X >= 0 && layer1X < 128 && localY >= 0 && localY < 64)
                    {
                        s32Data.Layer1[localY, layer1X] = new TileCell { X = layer1X, Y = localY, TileId = 0, IndexId = 0 };
                        totalL1++;
                        modifiedS32s.Add(s32Data);
                    }

                    // 清除第3層（設為可通行）- 只在偶數 X 時處理，避免重複
                    if (chkL3.Checked == true && layer1X % 2 == 0 && layer3X >= 0 && layer3X < 64 && localY >= 0 && localY < 64)
                    {
                        s32Data.Layer3[localY, layer3X] = new MapAttribute { Attribute1 = 0, Attribute2 = 0 };
                        totalL3++;
                        modifiedS32s.Add(s32Data);
                    }

                    // 清除第5層 - Layer5.X 是 0-127 (Layer1 座標)
                    // 一個遊戲格子對應兩個 Layer1 X 座標，只在偶數 X 時處理避免重複
                    if (chkL5.Checked == true && layer1X % 2 == 0)
                    {
                        totalL5 += s32Data.Layer5.RemoveAll(item => (item.X == layer1X || item.X == layer1X + 1) && item.Y == localY);
                        modifiedS32s.Add(s32Data);
                    }

                    // 清除第7層 - 只在偶數 X 時處理
                    if (chkL7.Checked == true && layer1X % 2 == 0)
                    {
                        totalL7 += s32Data.Layer7.RemoveAll(item => item.X == layer3X && item.Y == localY);
                        modifiedS32s.Add(s32Data);
                    }

                    // 清除第8層 - 只在偶數 X 時處理
                    // 注意：Layer8 的 X, Y 是全域遊戲座標
                    if (chkL8.Checked == true && layer1X % 2 == 0)
                    {
                        int globalL3X = s32Data.SegInfo.nLinBeginX + layer3X;
                        int globalY = s32Data.SegInfo.nLinBeginY + localY;
                        totalL8 += s32Data.Layer8.RemoveAll(item => item.X == globalL3X && item.Y == globalY);
                        modifiedS32s.Add(s32Data);
                    }
                }

                // 清除第4層 - 需要遍歷所有 S32 找跨區塊物件
                if (chkL4.Checked == true)
                {
                    foreach (var s32Data in _document.S32Files.Values)
                    {
                        int segStartX = s32Data.SegInfo.nLinBeginX;
                        int segStartY = s32Data.SegInfo.nLinBeginY;

                        // 先收集要刪除的物件以更新空間索引
                        var toRemove = s32Data.Layer4.Where(obj =>
                        {
                            int objGlobalX = segStartX + obj.X / 2;
                            int objGlobalY = segStartY + obj.Y;
                            return selectedGlobalCells.Contains((objGlobalX, objGlobalY));
                        }).ToList();

                        if (toRemove.Count > 0)
                        {
                            s32Data.Layer4.RemoveAll(obj =>
                            {
                                int objGlobalX = segStartX + obj.X / 2;
                                int objGlobalY = segStartY + obj.Y;
                                return selectedGlobalCells.Contains((objGlobalX, objGlobalY));
                            });
                            Layer4Index_RemoveRange(s32Data, toRemove);
                            totalL4 += toRemove.Count;
                            modifiedS32s.Add(s32Data);
                        }
                    }
                }

                // 標記修改
                foreach (var s32 in modifiedS32s)
                {
                    s32.IsModified = true;
                }

                // 組合結果訊息
                List<string> results = new List<string>();
                if (totalL1 > 0) results.Add($"L1:{totalL1}");
                if (totalL3 > 0) results.Add($"L3:{totalL3}");
                if (totalL4 > 0) results.Add($"L4:{totalL4}");
                if (totalL5 > 0) results.Add($"L5:{totalL5}");
                if (totalL7 > 0) results.Add($"L7:{totalL7}");
                if (totalL8 > 0) results.Add($"L8:{totalL8}");

                // 保存數量後清除選取
                int clearedCellCount = _editState.SelectedCells.Count;
                _editState.SelectedCells.Clear();
                selectedRegion = new Rectangle();

                RenderS32Map();

                if (results.Count > 0)
                {
                    this.toolStripStatusLabel1.Text = $"已清除 {clearedCellCount} 格的 {string.Join(", ", results)} 資料";
                }
                else
                {
                    this.toolStripStatusLabel1.Text = "選取區域沒有資料需要清除";
                }

                clearForm.Close();
            };

            clearForm.ShowDialog(this);
        }

        // 單格清除對話框
        private void ShowSingleCellClearDialog()
        {
            Form clearForm = new Form();
            clearForm.Text = "清除格子資料";
            clearForm.Size = new Size(350, 380);
            clearForm.SetFormBorderStyle(FormBorderStyle.FixedDialog);
            clearForm.SetStartPosition(FormStartPosition.CenterParent);
            clearForm.SetMaximizeBox(false);
            clearForm.SetMinimizeBox(false);

            // 座標輸入
            Label lblCoord = new Label();
            lblCoord.Text = "輸入遊戲座標:";
            lblCoord.SetLocation(new Point(20, 20));
            lblCoord.Size = new Size(100, 20);
            clearForm.GetControls().Add(lblCoord);

            Label lblX = new Label();
            lblX.Text = "X:";
            lblX.SetLocation(new Point(20, 50));
            lblX.Size = new Size(30, 20);
            clearForm.GetControls().Add(lblX);

            TextBox txtX = new TextBox();
            txtX.SetLocation(new Point(50, 48));
            txtX.Size = new Size(80, 20);
            if (_editState.SelectedGameX >= 0) txtX.Text = _editState.SelectedGameX.ToString();
            clearForm.GetControls().Add(txtX);

            Label lblY = new Label();
            lblY.Text = "Y:";
            lblY.SetLocation(new Point(150, 50));
            lblY.Size = new Size(30, 20);
            clearForm.GetControls().Add(lblY);

            TextBox txtY = new TextBox();
            txtY.SetLocation(new Point(180, 48));
            txtY.Size = new Size(80, 20);
            if (_editState.SelectedGameY >= 0) txtY.Text = _editState.SelectedGameY.ToString();
            clearForm.GetControls().Add(txtY);

            // 選擇要清除的層
            Label lblLayers = new Label();
            lblLayers.Text = "選擇要清除的層:";
            lblLayers.SetLocation(new Point(20, 90));
            lblLayers.Size = new Size(150, 20);
            clearForm.GetControls().Add(lblLayers);

            CheckBox chkL1 = new CheckBox();
            chkL1.Text = "第1層 (地板)";
            chkL1.SetLocation(new Point(30, 115));
            chkL1.Size = new Size(150, 20);
            chkL1.Checked = true;
            clearForm.GetControls().Add(chkL1);

            CheckBox chkL3 = new CheckBox();
            chkL3.Text = "第3層 (屬性) - 設為可通行";
            chkL3.SetLocation(new Point(30, 140));
            chkL3.Size = new Size(200, 20);
            chkL3.Checked = true;
            clearForm.GetControls().Add(chkL3);

            CheckBox chkL4 = new CheckBox();
            chkL4.Text = "第4層 (物件)";
            chkL4.SetLocation(new Point(30, 165));
            chkL4.Size = new Size(150, 20);
            chkL4.Checked = true;
            clearForm.GetControls().Add(chkL4);

            CheckBox chkL5 = new CheckBox();
            chkL5.Text = "第5層 (透明圖塊)";
            chkL5.SetLocation(new Point(30, 190));
            chkL5.Size = new Size(150, 20);
            clearForm.GetControls().Add(chkL5);

            CheckBox chkL7 = new CheckBox();
            chkL7.Text = "第7層 (傳送點)";
            chkL7.SetLocation(new Point(30, 215));
            chkL7.Size = new Size(150, 20);
            clearForm.GetControls().Add(chkL7);

            CheckBox chkL8 = new CheckBox();
            chkL8.Text = "第8層 (特效)";
            chkL8.SetLocation(new Point(30, 240));
            chkL8.Size = new Size(150, 20);
            clearForm.GetControls().Add(chkL8);

            // 執行按鈕
            Button btnExecute = new Button();
            btnExecute.Text = "清除";
            btnExecute.SetLocation(new Point(80, 290));
            btnExecute.Size = new Size(80, 30);
            clearForm.GetControls().Add(btnExecute);

            Button btnCancel = new Button();
            btnCancel.Text = "取消";
            btnCancel.SetLocation(new Point(180, 290));
            btnCancel.Size = new Size(80, 30);
            btnCancel.Click += (s, args) => clearForm.Close();
            clearForm.GetControls().Add(btnCancel);

            btnExecute.Click += (s, args) =>
            {
                if (!int.TryParse(txtX.Text, out int gameX) || !int.TryParse(txtY.Text, out int gameY))
                {
                    WinFormsMessageBox.Show("請輸入有效的座標", "錯誤", MessageBoxButtons.OK, MessageBoxIcon.Error);
                    return;
                }

                // 找到對應的 S32
                S32Data targetS32 = null;
                foreach (var s32Data in _document.S32Files.Values)
                {
                    if (gameX >= s32Data.SegInfo.nLinBeginX && gameX <= s32Data.SegInfo.nLinEndX &&
                        gameY >= s32Data.SegInfo.nLinBeginY && gameY <= s32Data.SegInfo.nLinEndY)
                    {
                        targetS32 = s32Data;
                        break;
                    }
                }

                if (targetS32 == null)
                {
                    WinFormsMessageBox.Show($"找不到座標 ({gameX}, {gameY}) 對應的 S32 區塊", "錯誤", MessageBoxButtons.OK, MessageBoxIcon.Error);
                    return;
                }

                // 計算局部座標
                int layer3X = gameX - targetS32.SegInfo.nLinBeginX;
                int localY = gameY - targetS32.SegInfo.nLinBeginY;
                int layer1X = layer3X * 2;  // Layer1 是 128 寬

                List<string> clearedLayers = new List<string>();

                // 清除第1層
                if (chkL1.Checked == true && layer1X >= 0 && layer1X < 128 && localY >= 0 && localY < 64)
                {
                    // 清除兩個 Layer1 格子（因為 Layer1 是 128 寬，Layer3 是 64 寬）
                    targetS32.Layer1[localY, layer1X] = new TileCell { X = layer1X, Y = localY, TileId = 0, IndexId = 0 };
                    if (layer1X + 1 < 128)
                        targetS32.Layer1[localY, layer1X + 1] = new TileCell { X = layer1X + 1, Y = localY, TileId = 0, IndexId = 0 };
                    clearedLayers.Add("L1");
                }

                // 清除第3層（設為可通行）
                if (chkL3.Checked == true && layer3X >= 0 && layer3X < 64 && localY >= 0 && localY < 64)
                {
                    targetS32.Layer3[localY, layer3X] = new MapAttribute { Attribute1 = 0, Attribute2 = 0 };
                    clearedLayers.Add("L3");
                }

                // 清除第4層
                if (chkL4.Checked == true)
                {
                    var toRemove = targetS32.Layer4.Where(obj =>
                        obj.X / 2 == layer3X && obj.Y == localY).ToList();
                    if (toRemove.Count > 0)
                    {
                        targetS32.Layer4.RemoveAll(obj =>
                            obj.X / 2 == layer3X && obj.Y == localY);
                        Layer4Index_RemoveRange(targetS32, toRemove);
                        clearedLayers.Add($"L4({toRemove.Count})");
                    }
                }

                // 清除第5層
                if (chkL5.Checked == true)
                {
                    int removedCount = targetS32.Layer5.RemoveAll(item =>
                        item.X == layer3X && item.Y == localY);
                    if (removedCount > 0) clearedLayers.Add($"L5({removedCount})");
                }

                // 清除第7層
                if (chkL7.Checked == true)
                {
                    int removedCount = targetS32.Layer7.RemoveAll(item =>
                        item.X == layer3X && item.Y == localY);
                    if (removedCount > 0) clearedLayers.Add($"L7({removedCount})");
                }

                // 清除第8層
                // 注意：Layer8 的 X, Y 是全域遊戲座標
                if (chkL8.Checked == true)
                {
                    int removedCount = targetS32.Layer8.RemoveAll(item =>
                        item.X == gameX && item.Y == gameY);
                    if (removedCount > 0) clearedLayers.Add($"L8({removedCount})");
                }

                if (clearedLayers.Count > 0)
                {
                    targetS32.IsModified = true;
                    RenderS32Map();
                    this.toolStripStatusLabel1.Text = $"已清除格子 ({gameX}, {gameY}) 的 {string.Join(", ", clearedLayers)} 資料";
                }
                else
                {
                    this.toolStripStatusLabel1.Text = $"格子 ({gameX}, {gameY}) 沒有資料需要清除";
                }

                clearForm.Close();
            };

            clearForm.ShowDialog(this);
        }

        // 查看與管理第六層（使用的TileId）資料
        private void btnToolCheckL6_Click(object sender, EventArgs e)
        {
            if (_document.S32Files.Count == 0)
            {
                WinFormsMessageBox.Show("請先載入地圖", "提示", MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            // 收集有 Layer6 資料的 S32
            List<(string filePath, string fileName, List<int> items)> s32WithL6 =
                new List<(string, string, List<int>)>();

            foreach (var kvp in _document.S32Files)
            {
                string filePath = kvp.Key;
                string fileName = Path.GetFileName(kvp.Key);
                S32Data s32Data = kvp.Value;

                if (s32Data.Layer6.Count > 0)
                {
                    s32WithL6.Add((filePath, fileName, s32Data.Layer6.ToList()));
                }
            }

            // 顯示結果
            Form resultForm = new Form();
            resultForm.Text = $"L6 查看與管理 - {s32WithL6.Count} 個 S32 有資料";
            resultForm.Size = new Size(750, 600);
            resultForm.SetFormBorderStyle(FormBorderStyle.Sizable);
            resultForm.SetStartPosition(FormStartPosition.CenterParent);

            int totalItems = s32WithL6.Sum(x => x.items.Count);
            Label lblSummary = new Label();
            lblSummary.Text = $"共 {s32WithL6.Count} 個 S32 檔案有 Layer6（使用的TileId）資料，總計 {totalItems} 項：";
            lblSummary.SetLocation(new Point(10, 10));
            lblSummary.Size = new Size(710, 20);
            resultForm.GetControls().Add(lblSummary);

            CheckedListBox clbItems = new CheckedListBox();
            clbItems.SetLocation(new Point(10, 35));
            clbItems.Size = new Size(710, 380);
            clbItems.Font = new Font("Consolas", 9);
            clbItems.CheckOnClick = true;

            List<(string filePath, int tileId)> itemInfoList = new List<(string, int)>();

            if (s32WithL6.Count == 0)
            {
                clbItems.Items.Add("沒有任何 S32 檔案有 Layer6 資料");
                clbItems.Enabled = false;
            }
            else
            {
                foreach (var (filePath, fileName, items) in s32WithL6)
                {
                    foreach (var tileId in items.OrderBy(x => x))
                    {
                        string displayText = $"[{fileName}] TileId={tileId}";
                        clbItems.Items.Add(displayText);
                        itemInfoList.Add((filePath, tileId));
                    }
                }
            }
            resultForm.GetControls().Add(clbItems);

            Button btnSelectAll = new Button();
            btnSelectAll.Text = "全選";
            btnSelectAll.SetLocation(new Point(10, 465));
            btnSelectAll.Size = new Size(80, 35);
            btnSelectAll.Click += (s, args) =>
            {
                for (int i = 0; i < clbItems.Items.Count; i++)
                    clbItems.SetItemChecked(i, true);
            };
            resultForm.GetControls().Add(btnSelectAll);

            Button btnDeselectAll = new Button();
            btnDeselectAll.Text = "取消全選";
            btnDeselectAll.SetLocation(new Point(100, 465));
            btnDeselectAll.Size = new Size(80, 35);
            btnDeselectAll.Click += (s, args) =>
            {
                for (int i = 0; i < clbItems.Items.Count; i++)
                    clbItems.SetItemChecked(i, false);
            };
            resultForm.GetControls().Add(btnDeselectAll);

            // 檢查與自動修復缺失的 TileId
            Button btnCheckMissing = new Button();
            btnCheckMissing.Text = "檢查缺失並自動修復";
            btnCheckMissing.SetLocation(new Point(200, 465));
            btnCheckMissing.Size = new Size(150, 35);
            btnCheckMissing.Click += (s, args) =>
            {
                int totalFixed = 0;
                foreach (var kvp in _document.S32Files)
                {
                    S32Data s32Data = kvp.Value;
                    HashSet<int> layer6Set = new HashSet<int>(s32Data.Layer6);
                    bool modified = false;

                    // 加入 Layer1 缺少的 TileId
                    for (int y = 0; y < 64; y++)
                    {
                        for (int x = 0; x < 128; x++)
                        {
                            var cell = s32Data.Layer1[y, x];
                            if (cell != null && cell.TileId > 0 && !layer6Set.Contains(cell.TileId))
                            {
                                s32Data.Layer6.Add(cell.TileId);
                                layer6Set.Add(cell.TileId);
                                modified = true;
                                totalFixed++;
                            }
                        }
                    }

                    // 加入 Layer4 缺少的 TileId
                    foreach (var obj in s32Data.Layer4)
                    {
                        if (obj.TileId > 0 && !layer6Set.Contains(obj.TileId))
                        {
                            s32Data.Layer6.Add(obj.TileId);
                            layer6Set.Add(obj.TileId);
                            modified = true;
                            totalFixed++;
                        }
                    }

                    if (modified)
                    {
                        s32Data.IsModified = true;
                    }
                }

                if (totalFixed > 0)
                {
                    WinFormsMessageBox.Show($"已將 {totalFixed} 個缺少的 TileId 加入到 Layer6。\n請記得儲存修改。",
                        "修復完成", MessageBoxButtons.OK, MessageBoxIcon.Information);
                    resultForm.Close();
                }
                else
                {
                    WinFormsMessageBox.Show("所有 S32 的 Layer6 都已完整，無需修復。", "檢查完成",
                        MessageBoxButtons.OK, MessageBoxIcon.Information);
                }
            };
            resultForm.GetControls().Add(btnCheckMissing);

            // 註：L6 刪除/清除功能已移除，因為遊戲邏輯不需要此功能

            Button btnClose = new Button();
            btnClose.Text = "關閉";
            btnClose.SetLocation(new Point(630, 465));
            btnClose.Size = new Size(90, 35);
            btnClose.Click += (s, args) => resultForm.Close();
            resultForm.GetControls().Add(btnClose);

            resultForm.Resize += (s, args) =>
            {
                int clientWidth = Math.Max(100, resultForm.ClientSize.Width);
                int clientHeight = Math.Max(200, resultForm.ClientSize.Height);
                clbItems.Size = new Size(Math.Max(10, clientWidth - 20), Math.Max(10, clientHeight - 90));
                btnSelectAll.SetLocation(new Point(10, Math.Max(10, clientHeight - 45)));
                btnDeselectAll.SetLocation(new Point(100, Math.Max(10, clientHeight - 45)));
                btnCheckMissing.SetLocation(new Point(200, Math.Max(10, clientHeight - 45)));
                btnClose.SetLocation(new Point(Math.Max(10, clientWidth - 100), Math.Max(10, clientHeight - 45)));
            };

            resultForm.ShowDialog(this);
        }

        // 查看與編輯第八層（特效）資料
        private void btnToolCheckL8_Click(object sender, EventArgs e)
        {
            if (_document.S32Files.Count == 0)
            {
                WinFormsMessageBox.Show(LocalizationManager.L("Message_PleaseLoadMap"), LocalizationManager.L("Title_Info"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            // 取得地圖選取區域涉及的 S32 檔案路徑
            HashSet<string> selectedS32Paths = new HashSet<string>();
            if (_editState.SelectedCells != null && _editState.SelectedCells.Count > 0)
            {
                foreach (var cell in _editState.SelectedCells)
                {
                    // 從選取的格子直接取得 S32 檔案路徑
                    if (cell.S32Data != null)
                    {
                        // 找到對應的檔案路徑
                        foreach (var kvp in _document.S32Files)
                        {
                            if (kvp.Value == cell.S32Data)
                            {
                                selectedS32Paths.Add(kvp.Key);
                                break;
                            }
                        }
                    }
                }
            }

            // 收集有 Layer8 資料的 S32（全部）
            List<(string filePath, string fileName, int count, List<Layer8Item> items)> s32WithL8All =
                new List<(string, string, int, List<Layer8Item>)>();
            // 收集有 Layer8 資料的 S32（選取區域涉及的）
            List<(string filePath, string fileName, int count, List<Layer8Item> items)> s32WithL8Selected =
                new List<(string, string, int, List<Layer8Item>)>();

            foreach (var kvp in _document.S32Files)
            {
                string filePath = kvp.Key;
                string fileName = Path.GetFileName(kvp.Key);
                S32Data s32Data = kvp.Value;

                if (s32Data.Layer8.Count > 0)
                {
                    var entry = (filePath, fileName, s32Data.Layer8.Count, s32Data.Layer8.ToList());
                    s32WithL8All.Add(entry);
                    if (selectedS32Paths.Contains(filePath))
                    {
                        s32WithL8Selected.Add(entry);
                    }
                }
            }

            // 顯示結果
            Form resultForm = new Form();
            resultForm.Text = LocalizationManager.L("L8_Title");
            resultForm.Size = new Size(850, 680);
            resultForm.SetFormBorderStyle(FormBorderStyle.Sizable);
            resultForm.SetStartPosition(FormStartPosition.CenterParent);

            int totalItemsAll = s32WithL8All.Sum(x => x.count);
            int totalItemsSelected = s32WithL8Selected.Sum(x => x.count);
            int extendedCount = _document.S32Files.Values.Count(s => s.Layer8HasExtendedData);
            Label lblSummary = new Label();
            lblSummary.Text = string.Format(LocalizationManager.L("L8_Summary"), s32WithL8Selected.Count, totalItemsSelected, s32WithL8All.Count, totalItemsAll, extendedCount);
            lblSummary.SetLocation(new Point(10, 10));
            lblSummary.Size = new Size(810, 20);
            resultForm.GetControls().Add(lblSummary);

            // 建立 TabControl
            TabControl tabControl = new TabControl();
            tabControl.SetLocation(new Point(10, 125));
            tabControl.Size = new Size(810, 320);

            TabPage tabAll = new TabPage(string.Format(LocalizationManager.L("L8_TabAll"), s32WithL8All.Count));
            TabPage tabSelected = new TabPage(string.Format(LocalizationManager.L("L8_TabSelected"), s32WithL8Selected.Count));
            tabControl.GetTabPages().Add(tabAll);
            tabControl.GetTabPages().Add(tabSelected);

            // ListView 排序狀態
            Dictionary<ListView, (int column, bool ascending)> sortStates = new Dictionary<ListView, (int, bool)>();

            // SPR 圖片快取
            Dictionary<int, Image> sprImageCache = new Dictionary<int, Image>();
            Dictionary<int, Image> sprFullImageCache = new Dictionary<int, Image>(); // 大圖快取
            HashSet<int> sprLoadFailed = new HashSet<int>(); // 追蹤載入失敗的 SPR
            ImageList sprImageList = new ImageList();
            sprImageList.ImageSize = new Size(48, 48);
            sprImageList.ColorDepth = ColorDepth.Depth32Bit;

            // 動畫快取：儲存所有帧
            Dictionary<int, List<Image>> sprAnimationCache = new Dictionary<int, List<Image>>();

            // 將 RGBA 像素轉換為 BGRA 並建立 Bitmap
            Bitmap CreateBitmapFromRgba(byte[] rgbaPixels, int width, int height)
            {
                byte[] bgraPixels = new byte[rgbaPixels.Length];
                for (int i = 0; i < rgbaPixels.Length; i += 4)
                {
                    bgraPixels[i + 0] = rgbaPixels[i + 2]; // B <- R
                    bgraPixels[i + 1] = rgbaPixels[i + 1]; // G <- G
                    bgraPixels[i + 2] = rgbaPixels[i + 0]; // R <- B
                    bgraPixels[i + 3] = rgbaPixels[i + 3]; // A <- A
                }
                Bitmap bmp = new Bitmap(width, height, PixelFormat.Format32bppArgb);
                var bmpData = bmp.LockBits(new Rectangle(0, 0, width, height), ImageLockMode.WriteOnly, PixelFormat.Format32bppArgb);
                System.Runtime.InteropServices.Marshal.Copy(bgraPixels, 0, bmpData.Scan0, bgraPixels.Length);
                bmp.UnlockBits(bmpData);
                return bmp;
            }

            // 載入 SPR 圖片的輔助方法 (返回縮圖, 成功時也快取大圖和動畫帧)
            Image LoadSprImage(int sprId)
            {
                if (sprImageCache.TryGetValue(sprId, out Image cached))
                    return cached;

                try
                {
                    string sprKey = $"{sprId}-0.spr";
                    byte[] sprData = L1PakReader.UnPack("Sprite", sprKey);
                    if (sprData != null && sprData.Length > 0)
                    {
                        var frames = SprReader.LoadRaw(sprData);
                        if (frames != null && frames.Length > 0)
                        {
                            // 載入所有帧到動畫快取
                            List<Image> animFrames = new List<Image>();
                            foreach (var f in frames)
                            {
                                if (f.Width > 0 && f.Height > 0 && f.Pixels != null)
                                {
                                    animFrames.Add(CreateBitmapFromRgba(f.Pixels, f.Width, f.Height));
                                }
                            }
                            if (animFrames.Count > 0)
                            {
                                sprAnimationCache[sprId] = animFrames;
                                sprFullImageCache[sprId] = animFrames[0]; // 第一帧作為靜態預覽
                            }

                            var frame = frames[0];
                            if (frame.Width > 0 && frame.Height > 0 && frame.Pixels != null)
                            {
                                Bitmap fullBmp = (Bitmap)animFrames[0];

                                // 建立 48x48 的縮圖
                                Bitmap bmp = new Bitmap(48, 48, PixelFormat.Format32bppArgb);
                                using (Graphics g = GraphicsHelper.FromImage(bmp))
                                {
                                    g.Clear(Color.FromArgb(40, 40, 40));
                                    // 縮放到 48x48 並置中
                                    float scale = Math.Min(44f / frame.Width, 44f / frame.Height);
                                    int newW = (int)(frame.Width * scale);
                                    int newH = (int)(frame.Height * scale);
                                    int x = (48 - newW) / 2;
                                    int y = (48 - newH) / 2;
                                    g.SetInterpolationMode(InterpolationMode.HighQualityBilinear);
                                    g.DrawImage(fullBmp, x, y, newW, newH);
                                }
                                sprImageCache[sprId] = bmp;
                                return bmp;
                            }
                        }
                    }
                }
                catch { }

                // 載入失敗
                sprLoadFailed.Add(sprId);

                // 建立佔位圖
                Bitmap placeholder = new Bitmap(48, 48, PixelFormat.Format32bppArgb);
                using (Graphics g = GraphicsHelper.FromImage(placeholder))
                {
                    g.Clear(Color.FromArgb(60, 60, 60));
                    using (Font font = new Font("Consolas", 7))
                    {
                        string text = sprId.ToString();
                        var size = g.MeasureString(text, font);
                        g.DrawString(text, font, Brushes.Gray, (48 - size.Width) / 2, (48 - size.Height) / 2);
                    }
                }
                sprImageCache[sprId] = placeholder;
                return placeholder;
            }

            // 建立兩個 ListView 的輔助方法
            // 欄位順序: S32檔案(0), 擴展(1), SprId(2), 預覽(3), X(4), Y(5), ExtData(6)
            ListView CreateL8ListView()
            {
                ListView lv = new ListView();
                lv.SetDock(DockStyle.Fill);
                lv.Font = new Font("Consolas", 9);
                lv.View = View.Details;
                lv.FullRowSelect = true;
                lv.CheckBoxes = true;
                lv.SmallImageList = sprImageList;
                lv.Columns.Add(LocalizationManager.L("L8_Column_File"), 100);
                lv.Columns.Add(LocalizationManager.L("L8_Column_Extended"), 45);
                lv.Columns.Add(LocalizationManager.L("L8_Column_SprId"), 60);
                lv.Columns.Add(LocalizationManager.L("L8_Column_Preview"), 55);
                lv.Columns.Add(LocalizationManager.L("L8_Column_X"), 50);
                lv.Columns.Add(LocalizationManager.L("L8_Column_Y"), 50);
                lv.Columns.Add(LocalizationManager.L("L8_Column_ExtData"), 70);

                // 初始化排序狀態
                sortStates[lv] = (-1, true);

                // 點擊標題排序
                lv.ColumnClick += (sender, e) =>
                {
                    ListView listView = sender as ListView;
                    if (listView == null) return;

                    var (lastColumn, ascending) = sortStates[listView];
                    bool newAscending = (lastColumn == e.Column) ? !ascending : true;
                    sortStates[listView] = (e.Column, newAscending);

                    listView.ListViewItemSorter = new ListViewColumnSorter(e.Column, newAscending);
                    listView.Sort();
                };

                return lv;
            }

            ListView lvSelected = CreateL8ListView();
            ListView lvAll = CreateL8ListView();
            tabSelected.GetControls().Add(lvSelected);
            tabAll.GetControls().Add(lvAll);

            // 預覽區域 (右側)
            GroupBox gbPreview = new GroupBox();
            gbPreview.Text = LocalizationManager.L("L8_Preview");
            gbPreview.SetLocation(new Point(640, 125));
            gbPreview.Size = new Size(180, 320);
            resultForm.GetControls().Add(gbPreview);

            PictureBox pbPreview = new PictureBox();
            pbPreview.SetLocation(new Point(10, 20));
            pbPreview.Size = new Size(160, 160);
            pbPreview.BackgroundColor = Color.FromArgb(40, 40, 40);
            pbPreview.SetSizeMode(PictureBoxSizeMode.Zoom);
            pbPreview.BorderStyle = BorderStyle.FixedSingle;
            gbPreview.GetControls().Add(pbPreview);

            Label lblPreviewInfo = new Label();
            lblPreviewInfo.SetLocation(new Point(10, 185));
            lblPreviewInfo.Size = new Size(160, 45);
            lblPreviewInfo.Text = LocalizationManager.L("L8_SelectToPreview");
            lblPreviewInfo.TextColor = Colors.Gray;
            gbPreview.GetControls().Add(lblPreviewInfo);

            // 跳轉按鈕
            Button btnJumpToLocation = new Button();
            btnJumpToLocation.Text = LocalizationManager.L("L8_JumpToLocation");
            btnJumpToLocation.SetLocation(new Point(10, 232));
            btnJumpToLocation.Size = new Size(160, 25);
            btnJumpToLocation.Enabled = false;
            gbPreview.GetControls().Add(btnJumpToLocation);

            // 篩選無圖項目
            CheckBox chkFilterNoImage = new CheckBox();
            chkFilterNoImage.Text = LocalizationManager.L("L8_FilterNoImage");
            chkFilterNoImage.SetLocation(new Point(10, 260));
            chkFilterNoImage.Size = new Size(160, 24);
            chkFilterNoImage.TextColor = Colors.OrangeRed;
            gbPreview.GetControls().Add(chkFilterNoImage);

            Label lblNoImageCount = new Label();
            lblNoImageCount.SetLocation(new Point(10, 285));
            lblNoImageCount.Size = new Size(160, 20);
            lblNoImageCount.TextColor = Colors.Gray;
            gbPreview.GetControls().Add(lblNoImageCount);

            // 動畫播放控制
            Timer animTimer = new Timer();
            animTimer.Interval = 100; // 100ms per frame
            int currentAnimFrame = 0;
            List<Image> currentAnimFrames = null;
            int currentAnimSprId = -1;

            animTimer.Tick += (s, args) =>
            {
                if (currentAnimFrames != null && currentAnimFrames.Count > 1)
                {
                    currentAnimFrame = (currentAnimFrame + 1) % currentAnimFrames.Count;
                    pbPreview.Image = currentAnimFrames[currentAnimFrame];
                }
            };

            // 表單關閉時停止動畫
            resultForm.FormClosed += (s, args) =>
            {
                animTimer.Stop();
                animTimer.Dispose();
            };

            // 調整 TabControl 大小以容納預覽區
            tabControl.Size = new Size(620, 320);
            resultForm.GetControls().Add(tabControl);

            // 目前作用中的 ListView（用於編輯操作）
            // 預設 tab 是 index 0 (tabAll)，所以初始值應該是 lvAll
            ListView lvItems = lvAll;
            tabControl.SelectedIndexChanged += (s, args) =>
            {
                lvItems = tabControl.SelectedIndex == 0 ? lvAll : lvSelected;
            };

            // 為了向後相容，保留 s32WithL8 變數指向全部資料
            var s32WithL8 = s32WithL8All;
            int totalItems = totalItemsAll;

            // 擴展格式設定區
            GroupBox gbExtended = new GroupBox();
            gbExtended.Text = LocalizationManager.L("L8_ExtendedSettings");
            gbExtended.SetLocation(new Point(10, 35));
            gbExtended.Size = new Size(810, 85);

            Label lblExtendedInfo = new Label();
            lblExtendedInfo.Text = LocalizationManager.L("L8_ExtendedInfo");
            lblExtendedInfo.SetLocation(new Point(10, 18));
            lblExtendedInfo.Size = new Size(550, 20);
            gbExtended.GetControls().Add(lblExtendedInfo);

            ComboBox cmbS32Extended = new ComboBox();
            cmbS32Extended.SetLocation(new Point(10, 42));
            cmbS32Extended.Size = new Size(200, 23);
            cmbS32Extended.DropDownStyle = ComboBoxStyle.DropDownList;
            foreach (var kvp in _document.S32Files)
            {
                string fileName = Path.GetFileName(kvp.Key);
                string extMark = kvp.Value.Layer8HasExtendedData ? $" [{LocalizationManager.L("L8_ExtendedFormat")}]" : "";
                cmbS32Extended.Items.Add(new { FilePath = kvp.Key, Display = $"{fileName}{extMark}" });
            }
            cmbS32Extended.DisplayMember = "Display";
            if (cmbS32Extended.Items.Count > 0) cmbS32Extended.SelectedIndex = 0;
            gbExtended.GetControls().Add(cmbS32Extended);

            Label lblCurrentStatus = new Label();
            lblCurrentStatus.SetLocation(new Point(220, 45));
            lblCurrentStatus.Size = new Size(150, 20);
            lblCurrentStatus.Text = string.Format(LocalizationManager.L("L8_CurrentStatus"), LocalizationManager.L("L8_NotSelected"));
            gbExtended.GetControls().Add(lblCurrentStatus);

            Button btnSetExtended = new Button();
            btnSetExtended.Text = LocalizationManager.L("L8_SetExtended");
            btnSetExtended.SetLocation(new Point(380, 40));
            btnSetExtended.Size = new Size(90, 28);
            btnSetExtended.Click += (s, args) =>
            {
                if (cmbS32Extended.SelectedItem == null) return;
                dynamic selected = cmbS32Extended.SelectedItem;
                string filePath = selected.FilePath;
                if (_document.S32Files.TryGetValue(filePath, out S32Data s32Data))
                {
                    s32Data.Layer8HasExtendedData = true;
                    s32Data.IsModified = true;
                    lblCurrentStatus.Text = string.Format(LocalizationManager.L("L8_CurrentStatus"), LocalizationManager.L("L8_ExtendedFormat"));
                    // 更新 ComboBox 顯示
                    int idx = cmbS32Extended.SelectedIndex;
                    cmbS32Extended.Items[idx] = new { FilePath = filePath, Display = $"{Path.GetFileName(filePath)} [{LocalizationManager.L("L8_ExtendedFormat")}]" };
                    cmbS32Extended.SelectedIndex = idx;
                    // 更新 ListView 中該 S32 的項目
                    foreach (ListViewItem lvi in lvItems.Items)
                    {
                        if (lvi.Tag == null) continue;
                        var (lvFilePath, lvItem) = ((string, Layer8Item))lvi.Tag;
                        if (lvFilePath == filePath)
                        {
                            lvi.SubItems[1].Text = LocalizationManager.L("L8_Yes");  // 擴展欄位 (索引 1)
                        }
                    }
                    // 更新摘要
                    int newExtCount = _document.S32Files.Values.Count(x => x.Layer8HasExtendedData);
                    lblSummary.Text = string.Format(LocalizationManager.L("L8_Summary"), s32WithL8Selected.Count, totalItemsSelected, s32WithL8All.Count, totalItemsAll, newExtCount);
                    WinFormsMessageBox.Show(string.Format(LocalizationManager.L("L8_SetExtendedDone"), Path.GetFileName(filePath)), LocalizationManager.L("Title_Success"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                }
            };
            gbExtended.GetControls().Add(btnSetExtended);

            Button btnSetNormal = new Button();
            btnSetNormal.Text = LocalizationManager.L("L8_SetNormal");
            btnSetNormal.SetLocation(new Point(480, 40));
            btnSetNormal.Size = new Size(90, 28);
            btnSetNormal.Click += (s, args) =>
            {
                if (cmbS32Extended.SelectedItem == null) return;
                dynamic selected = cmbS32Extended.SelectedItem;
                string filePath = selected.FilePath;
                if (_document.S32Files.TryGetValue(filePath, out S32Data s32Data))
                {
                    s32Data.Layer8HasExtendedData = false;
                    // 清除所有 Layer8 項目的 ExtendedData
                    foreach (var item in s32Data.Layer8)
                    {
                        item.ExtendedData = 0;
                    }
                    s32Data.IsModified = true;
                    lblCurrentStatus.Text = string.Format(LocalizationManager.L("L8_CurrentStatus"), LocalizationManager.L("L8_NormalFormat"));
                    // 更新 ComboBox 顯示
                    int idx = cmbS32Extended.SelectedIndex;
                    cmbS32Extended.Items[idx] = new { FilePath = filePath, Display = Path.GetFileName(filePath) };
                    cmbS32Extended.SelectedIndex = idx;
                    // 更新 ListView 中該 S32 的項目
                    foreach (ListViewItem lvi in lvItems.Items)
                    {
                        if (lvi.Tag == null) continue;
                        var (lvFilePath, lvItem) = ((string, Layer8Item))lvi.Tag;
                        if (lvFilePath == filePath)
                        {
                            lvi.SubItems[1].Text = "";  // 擴展欄位 (索引 1)
                            lvi.SubItems[6].Text = "0"; // ExtData 欄位 (索引 6)
                        }
                    }
                    // 更新摘要
                    int newExtCount = _document.S32Files.Values.Count(x => x.Layer8HasExtendedData);
                    lblSummary.Text = string.Format(LocalizationManager.L("L8_Summary"), s32WithL8Selected.Count, totalItemsSelected, s32WithL8All.Count, totalItemsAll, newExtCount);
                    WinFormsMessageBox.Show(string.Format(LocalizationManager.L("L8_SetNormalDone"), Path.GetFileName(filePath), s32Data.Layer8.Count), LocalizationManager.L("Title_Success"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                }
            };
            gbExtended.GetControls().Add(btnSetNormal);

            Button btnResetAllExtended = new Button();
            btnResetAllExtended.Text = LocalizationManager.L("L8_ResetAll");
            btnResetAllExtended.SetLocation(new Point(580, 40));
            btnResetAllExtended.Size = new Size(120, 28);
            btnResetAllExtended.BackgroundColor = Colors.LightYellow;
            btnResetAllExtended.Click += (s, args) =>
            {
                int currentExtCount = _document.S32Files.Values.Count(x => x.Layer8HasExtendedData);
                if (currentExtCount == 0)
                {
                    WinFormsMessageBox.Show(LocalizationManager.L("L8_NoExtendedFiles"), LocalizationManager.L("Title_Info"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                    return;
                }
                var confirmResult = WinFormsMessageBox.Show(
                    string.Format(LocalizationManager.L("L8_ConfirmResetAll"), currentExtCount),
                    LocalizationManager.L("L8_ConfirmResetTitle"),
                    MessageBoxButtons.YesNo,
                    MessageBoxIcon.Warning);
                if (confirmResult != DialogResult.Yes) return;

                int clearedItemCount = 0;
                foreach (var s32Data in _document.S32Files.Values)
                {
                    if (s32Data.Layer8HasExtendedData)
                    {
                        s32Data.Layer8HasExtendedData = false;
                        // 清除所有 Layer8 項目的 ExtendedData
                        foreach (var item in s32Data.Layer8)
                        {
                            item.ExtendedData = 0;
                            clearedItemCount++;
                        }
                        s32Data.IsModified = true;
                    }
                }
                // 重新填入 ComboBox
                cmbS32Extended.Items.Clear();
                foreach (var kvp in _document.S32Files)
                {
                    cmbS32Extended.Items.Add(new { FilePath = kvp.Key, Display = Path.GetFileName(kvp.Key) });
                }
                if (cmbS32Extended.Items.Count > 0) cmbS32Extended.SelectedIndex = 0;
                lblCurrentStatus.Text = string.Format(LocalizationManager.L("L8_CurrentStatus"), LocalizationManager.L("L8_NormalFormat"));
                // 更新 ListView 中所有項目的擴展欄位 (索引: 0=檔案, 1=擴展, 2=SprId, 3=預覽, 4=X, 5=Y, 6=ExtData)
                foreach (ListViewItem lvi in lvItems.Items)
                {
                    lvi.SubItems[1].Text = "";  // 擴展欄位 (索引 1)
                    lvi.SubItems[6].Text = "0"; // ExtData 欄位 (索引 6)
                }
                lblSummary.Text = string.Format(LocalizationManager.L("L8_Summary"), s32WithL8Selected.Count, totalItemsSelected, s32WithL8All.Count, totalItemsAll, 0);
                WinFormsMessageBox.Show(string.Format(LocalizationManager.L("L8_ResetAllDone"), currentExtCount, clearedItemCount), LocalizationManager.L("Title_Success"), MessageBoxButtons.OK, MessageBoxIcon.Information);
            };
            gbExtended.GetControls().Add(btnResetAllExtended);

            cmbS32Extended.SelectedIndexChanged += (s, args) =>
            {
                if (cmbS32Extended.SelectedItem == null) return;
                dynamic selected = cmbS32Extended.SelectedItem;
                string filePath = selected.FilePath;
                if (_document.S32Files.TryGetValue(filePath, out S32Data s32Data))
                {
                    lblCurrentStatus.Text = string.Format(LocalizationManager.L("L8_CurrentStatus"), s32Data.Layer8HasExtendedData ? LocalizationManager.L("L8_ExtendedFormat") : LocalizationManager.L("L8_NormalFormat"));
                }
            };
            // 初始顯示
            if (cmbS32Extended.Items.Count > 0)
            {
                dynamic firstItem = cmbS32Extended.Items[0];
                if (_document.S32Files.TryGetValue(firstItem.FilePath, out S32Data firstS32))
                {
                    lblCurrentStatus.Text = string.Format(LocalizationManager.L("L8_CurrentStatus"), firstS32.Layer8HasExtendedData ? LocalizationManager.L("L8_ExtendedFormat") : LocalizationManager.L("L8_NormalFormat"));
                }
            }
            resultForm.GetControls().Add(gbExtended);

            // 填入 ListView 資料的輔助方法
            // 欄位順序: S32檔案(0), 擴展(1), SprId(2), 預覽(3), X(4), Y(5), ExtData(6)
            void FillListView(ListView lv, List<(string filePath, string fileName, int count, List<Layer8Item> items)> dataList, bool filterNoImage = false)
            {
                lv.Items.Clear();
                if (dataList.Count == 0)
                {
                    lv.Items.Add(new ListViewItem(LocalizationManager.L("L8_NoExtendedFiles")));
                    lv.Enabled = false;
                }
                else
                {
                    foreach (var (filePath, fileName, count, items) in dataList)
                    {
                        bool hasExtended = _document.S32Files.TryGetValue(filePath, out S32Data s32) && s32.Layer8HasExtendedData;
                        foreach (var item in items)
                        {
                            // 篩選無圖項目
                            if (filterNoImage && !sprLoadFailed.Contains(item.SprId))
                                continue;

                            // 載入 SPR 圖片
                            Image sprImg = LoadSprImage(item.SprId);
                            string imgKey = $"spr_{item.SprId}";
                            if (!sprImageList.Images.ContainsKey(imgKey))
                            {
                                sprImageList.Images.Add(imgKey, sprImg);
                            }

                            // 欄位順序: S32檔案(0), 擴展(1), SprId(2), 預覽(3), X(4), Y(5), ExtData(6)
                            ListViewItem lvi = new ListViewItem(fileName);
                            lvi.SubItems.Add(hasExtended ? LocalizationManager.L("L8_Yes") : "");
                            lvi.SubItems.Add(item.SprId.ToString());
                            lvi.SubItems.Add(""); // 預覽欄位 (圖片)
                            lvi.SubItems[3].Tag = imgKey; // 儲存圖片 key
                            lvi.ImageKey = imgKey; // 使用 ImageKey 顯示圖片
                            lvi.SubItems.Add(item.X.ToString());
                            lvi.SubItems.Add(item.Y.ToString());
                            lvi.SubItems.Add(item.ExtendedData.ToString());
                            lvi.Tag = (filePath, item);
                            lv.Items.Add(lvi);
                        }
                    }
                }
            }

            // 填入兩個 ListView
            FillListView(lvSelected, s32WithL8Selected);
            FillListView(lvAll, s32WithL8All);

            // 更新無圖項目計數
            int noImageCount = sprLoadFailed.Count;
            lblNoImageCount.Text = string.Format(LocalizationManager.L("L8_NoImageCount"), noImageCount);

            // 篩選無圖項目
            chkFilterNoImage.CheckedChanged += (s, args) =>
            {
                FillListView(lvSelected, s32WithL8Selected, chkFilterNoImage.Checked == true);
                FillListView(lvAll, s32WithL8All, chkFilterNoImage.Checked == true);
            };

            // 目前選取的項目資訊 (用於跳轉)
            (string filePath, Layer8Item item)? currentSelectedItem = null;

            // 選取項目時更新預覽
            void UpdatePreview(ListView lv)
            {
                if (lv.SelectedItems.Count == 1 && lv.SelectedItems[0].Tag != null)
                {
                    var lvi = lv.SelectedItems[0];
                    var (filePath, item) = ((string, Layer8Item))lvi.Tag;
                    currentSelectedItem = (filePath, item);
                    btnJumpToLocation.Enabled = true;

                    // 檢查是否有動畫帧
                    if (sprAnimationCache.TryGetValue(item.SprId, out List<Image> frames) && frames.Count > 0)
                    {
                        // 設定動畫
                        currentAnimFrames = frames;
                        currentAnimFrame = 0;
                        currentAnimSprId = item.SprId;
                        pbPreview.Image = frames[0];

                        string frameInfo = frames.Count > 1 ? $" ({frames.Count} 帧)" : "";
                        lblPreviewInfo.Text = $"SprId: {item.SprId}{frameInfo}\n大小: {frames[0].Width}x{frames[0].Height}\n位置: ({item.X}, {item.Y})";
                        lblPreviewInfo.TextColor = Colors.Black;

                        // 只有多帧才啟動動畫
                        if (frames.Count > 1)
                        {
                            animTimer.Start();
                        }
                        else
                        {
                            animTimer.Stop();
                        }
                    }
                    else if (sprFullImageCache.TryGetValue(item.SprId, out Image fullImg))
                    {
                        // 停止動畫
                        animTimer.Stop();
                        currentAnimFrames = null;
                        currentAnimSprId = -1;

                        pbPreview.Image = fullImg;
                        lblPreviewInfo.Text = $"SprId: {item.SprId}\n大小: {fullImg.Width}x{fullImg.Height}\n位置: ({item.X}, {item.Y})";
                        lblPreviewInfo.TextColor = Colors.Black;
                    }
                    else
                    {
                        // 停止動畫
                        animTimer.Stop();
                        currentAnimFrames = null;
                        currentAnimSprId = -1;

                        pbPreview.Image = null;
                        lblPreviewInfo.Text = $"SprId: {item.SprId}\n(無法載入圖片)\n位置: ({item.X}, {item.Y})";
                        lblPreviewInfo.TextColor = Colors.OrangeRed;
                    }
                }
                else
                {
                    // 停止動畫
                    animTimer.Stop();
                    currentAnimFrames = null;
                    currentAnimSprId = -1;

                    currentSelectedItem = null;
                    btnJumpToLocation.Enabled = false;
                    pbPreview.Image = null;
                    lblPreviewInfo.Text = LocalizationManager.L("L8_SelectToPreview");
                    lblPreviewInfo.TextColor = Colors.Gray;
                }
            }

            lvSelected.SelectedIndexChanged += (s, args) => UpdatePreview(lvSelected);
            lvAll.SelectedIndexChanged += (s, args) => UpdatePreview(lvAll);

            // 跳轉按鈕點擊事件
            btnJumpToLocation.Click += (s, args) =>
            {
                if (currentSelectedItem == null) return;
                var (filePath, item) = currentSelectedItem.Value;

                if (_document.S32Files.TryGetValue(filePath, out S32Data s32Data))
                {
                    // Layer8 的 X, Y 是 Layer3 座標系 (0-63)，轉換為全域遊戲座標
                    int globalX = item.X;
                    int globalY = item.Y;

                    // 使用既有的座標跳轉方法
                    JumpToGameCoordinate(globalX, globalY);

                    this.toolStripStatusLabel1.Text = string.Format(LocalizationManager.L("L8_JumpedToLocation"), globalX, globalY, item.SprId);
                }
            };

            List<(string filePath, Layer8Item item)> itemInfoList = new List<(string, Layer8Item)>();
            foreach (var (filePath, fileName, count, items) in s32WithL8All)
            {
                foreach (var item in items)
                {
                    itemInfoList.Add((filePath, item));
                }
            }

            // 編輯區域
            GroupBox gbEdit = new GroupBox();
            gbEdit.Text = LocalizationManager.L("L8_EditSection");
            gbEdit.SetLocation(new Point(10, 455));
            gbEdit.Size = new Size(810, 75);

            Label lblSprId = new Label { Text = "SprId:", Size = new Size(45, 20) };
            lblSprId.SetLocation(new Point(10, 28));
            TextBox txtSprId = new TextBox { Size = new Size(80, 23) };
            txtSprId.SetLocation(new Point(60, 25));
            Label lblX = new Label { Text = "X:", Size = new Size(20, 20) };
            lblX.SetLocation(new Point(155, 28));
            TextBox txtX = new TextBox { Size = new Size(80, 23) };
            txtX.SetLocation(new Point(175, 25));
            Label lblY = new Label { Text = "Y:", Size = new Size(20, 20) };
            lblY.SetLocation(new Point(270, 28));
            TextBox txtY = new TextBox { Size = new Size(80, 23) };
            txtY.SetLocation(new Point(290, 25));
            Label lblExtData = new Label { Text = "ExtData:", Size = new Size(55, 20) };
            lblExtData.SetLocation(new Point(385, 28));
            TextBox txtExtData = new TextBox { Size = new Size(80, 23) };
            txtExtData.SetLocation(new Point(445, 25));

            Button btnApplyEdit = new Button();
            btnApplyEdit.Text = LocalizationManager.L("L8_ApplyEdit");
            btnApplyEdit.SetLocation(new Point(545, 22));
            btnApplyEdit.Size = new Size(80, 28);
            btnApplyEdit.Click += (s, args) =>
            {
                if (lvItems.SelectedItems.Count != 1)
                {
                    WinFormsMessageBox.Show(LocalizationManager.L("L8_SelectOneToEdit"), LocalizationManager.L("Title_Info"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                    return;
                }

                var lvi = lvItems.SelectedItems[0];
                var (filePath, item) = ((string, Layer8Item))lvi.Tag;

                if (!ushort.TryParse(txtSprId.Text, out ushort newSprId) ||
                    !ushort.TryParse(txtX.Text, out ushort newX) ||
                    !ushort.TryParse(txtY.Text, out ushort newY) ||
                    !int.TryParse(txtExtData.Text, out int newExtData))
                {
                    WinFormsMessageBox.Show(LocalizationManager.L("L8_InvalidValue"), LocalizationManager.L("Title_Error"), MessageBoxButtons.OK, MessageBoxIcon.Error);
                    return;
                }

                // 更新資料
                item.SprId = newSprId;
                item.X = newX;
                item.Y = newY;
                item.ExtendedData = newExtData;

                // 更新 ListView 顯示 (索引: 0=檔案, 1=擴展, 2=SprId, 3=預覽, 4=X, 5=Y, 6=ExtData)
                lvi.SubItems[2].Text = item.SprId.ToString();
                lvi.SubItems[4].Text = item.X.ToString();
                lvi.SubItems[5].Text = item.Y.ToString();
                lvi.SubItems[6].Text = item.ExtendedData.ToString();

                // 標記已修改
                if (_document.S32Files.TryGetValue(filePath, out S32Data s32Data))
                {
                    s32Data.IsModified = true;
                }

                WinFormsMessageBox.Show(LocalizationManager.L("L8_EditApplied"), LocalizationManager.L("Title_Done"), MessageBoxButtons.OK, MessageBoxIcon.Information);
            };

            // 新增項目按鈕
            Button btnAddNew = new Button();
            btnAddNew.Text = LocalizationManager.L("L8_AddNew");
            btnAddNew.SetLocation(new Point(635, 22));
            btnAddNew.Size = new Size(60, 28);
            btnAddNew.Click += (s, args) =>
            {
                if (_document.S32Files.Count == 0)
                {
                    WinFormsMessageBox.Show(LocalizationManager.L("Message_PleaseLoadMap"), LocalizationManager.L("Title_Info"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                    return;
                }

                if (!ushort.TryParse(txtSprId.Text, out ushort newSprId) ||
                    !ushort.TryParse(txtX.Text, out ushort newX) ||
                    !ushort.TryParse(txtY.Text, out ushort newY) ||
                    !int.TryParse(txtExtData.Text, out int newExtData))
                {
                    WinFormsMessageBox.Show(LocalizationManager.L("L8_InvalidValue"), LocalizationManager.L("Title_Error"), MessageBoxButtons.OK, MessageBoxIcon.Error);
                    return;
                }

                // 選擇要加入的 S32 檔案
                var s32Files = _document.S32Files.Keys.Select(k => Path.GetFileName(k)).ToArray();
                Form selectForm = new Form();
                selectForm.Text = LocalizationManager.L("L8_SelectS32File");
                selectForm.Size = new Size(300, 150);
                selectForm.SetFormBorderStyle(FormBorderStyle.FixedDialog);
                selectForm.SetStartPosition(FormStartPosition.CenterParent);

                Label lblSelect = new Label { Text = LocalizationManager.L("L8_SelectS32ForNewItem"), Size = new Size(260, 20) };
                lblSelect.SetLocation(new Point(10, 15));
                ComboBox cmbS32 = new ComboBox { Size = new Size(260, 23), DropDownStyle = ComboBoxStyle.DropDownList };
                cmbS32.SetLocation(new Point(10, 40));
                cmbS32.Items.AddRange(s32Files);
                if (cmbS32.Items.Count > 0) cmbS32.SelectedIndex = 0;

                Button btnOK = new Button { Text = LocalizationManager.L("Common_OK"), Size = new Size(80, 28), DialogResult = DialogResult.Ok };
                btnOK.SetLocation(new Point(100, 75));
                selectForm.GetControls().Add(lblSelect);
                selectForm.GetControls().Add(cmbS32);
                selectForm.GetControls().Add(btnOK);
                selectForm.AcceptButton = btnOK;

                if (selectForm.ShowDialog(this) == DialogResult.Ok && cmbS32.SelectedIndex >= 0)
                {
                    string selectedFileName = cmbS32.SelectedItem.ToString();
                    string selectedFilePath = _document.S32Files.Keys.FirstOrDefault(k => Path.GetFileName(k) == selectedFileName);

                    if (selectedFilePath != null && _document.S32Files.TryGetValue(selectedFilePath, out S32Data s32Data))
                    {
                        Layer8Item newItem = new Layer8Item
                        {
                            SprId = newSprId,
                            X = newX,
                            Y = newY,
                            ExtendedData = newExtData
                        };
                        s32Data.Layer8.Add(newItem);
                        s32Data.IsModified = true;

                        // 載入 SPR 圖片
                        Image sprImg = LoadSprImage(newSprId);
                        string imgKey = $"spr_{newSprId}";
                        if (!sprImageList.Images.ContainsKey(imgKey))
                        {
                            sprImageList.Images.Add(imgKey, sprImg);
                        }

                        // 更新 ListView (索引: 0=檔案, 1=擴展, 2=SprId, 3=預覽, 4=X, 5=Y, 6=ExtData)
                        ListViewItem lvi = new ListViewItem(selectedFileName);
                        lvi.SubItems.Add(s32Data.Layer8HasExtendedData ? "是" : "");
                        lvi.SubItems.Add(newItem.SprId.ToString());
                        lvi.SubItems.Add(""); // 預覽欄位
                        lvi.ImageKey = imgKey;
                        lvi.SubItems.Add(newItem.X.ToString());
                        lvi.SubItems.Add(newItem.Y.ToString());
                        lvi.SubItems.Add(newItem.ExtendedData.ToString());
                        lvi.Tag = (selectedFilePath, newItem);
                        lvItems.Items.Add(lvi);
                        itemInfoList.Add((selectedFilePath, newItem));

                        WinFormsMessageBox.Show(string.Format(LocalizationManager.L("L8_ItemAdded"), selectedFileName), LocalizationManager.L("Title_Done"),
                            MessageBoxButtons.OK, MessageBoxIcon.Information);
                    }
                }
            };

            gbEdit.GetControls().Add(lblSprId);
            gbEdit.GetControls().Add(txtSprId);
            gbEdit.GetControls().Add(lblX);
            gbEdit.GetControls().Add(txtX);
            gbEdit.GetControls().Add(lblY);
            gbEdit.GetControls().Add(txtY);
            gbEdit.GetControls().Add(lblExtData);
            gbEdit.GetControls().Add(txtExtData);
            gbEdit.GetControls().Add(btnApplyEdit);
            gbEdit.GetControls().Add(btnAddNew);
            resultForm.GetControls().Add(gbEdit);

            // 批次取代區域
            GroupBox gbBatchReplace = new GroupBox();
            gbBatchReplace.Text = LocalizationManager.L("L8_BatchReplace");
            gbBatchReplace.SetLocation(new Point(10, 535));
            gbBatchReplace.Size = new Size(500, 55);

            Label lblFromSpr = new Label { Text = LocalizationManager.L("L8_FromSprId"), Size = new Size(60, 20) };
            lblFromSpr.SetLocation(new Point(10, 20));
            TextBox txtFromSprId = new TextBox { Size = new Size(70, 23) };
            txtFromSprId.SetLocation(new Point(75, 17));
            Label lblToSpr = new Label { Text = LocalizationManager.L("L8_ToSprId"), Size = new Size(40, 20) };
            lblToSpr.SetLocation(new Point(155, 20));
            TextBox txtToSprId = new TextBox { Size = new Size(70, 23) };
            txtToSprId.SetLocation(new Point(195, 17));

            Button btnBatchReplace = new Button();
            btnBatchReplace.Text = LocalizationManager.L("L8_BatchReplaceBtn");
            btnBatchReplace.SetLocation(new Point(280, 15));
            btnBatchReplace.Size = new Size(80, 25);
            btnBatchReplace.Click += (s, args) =>
            {
                if (!ushort.TryParse(txtFromSprId.Text, out ushort fromSprId) ||
                    !ushort.TryParse(txtToSprId.Text, out ushort toSprId))
                {
                    WinFormsMessageBox.Show(LocalizationManager.L("L8_InvalidSprId"), LocalizationManager.L("Title_Error"), MessageBoxButtons.OK, MessageBoxIcon.Error);
                    return;
                }

                if (fromSprId == toSprId)
                {
                    WinFormsMessageBox.Show(LocalizationManager.L("L8_SameSprId"), LocalizationManager.L("Title_Info"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                    return;
                }

                // 計算會影響多少項目
                int affectedCount = 0;
                foreach (var kvp in _document.S32Files)
                {
                    foreach (var item in kvp.Value.Layer8)
                    {
                        if (item.SprId == fromSprId) affectedCount++;
                    }
                }

                if (affectedCount == 0)
                {
                    WinFormsMessageBox.Show(string.Format(LocalizationManager.L("L8_SprIdNotFound"), fromSprId), LocalizationManager.L("Title_Info"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                    return;
                }

                var confirmResult = WinFormsMessageBox.Show(
                    string.Format(LocalizationManager.L("L8_ConfirmBatchReplace"), fromSprId, affectedCount, toSprId),
                    LocalizationManager.L("L8_ConfirmBatchReplaceTitle"),
                    MessageBoxButtons.YesNo,
                    MessageBoxIcon.Question);

                if (confirmResult != DialogResult.Yes) return;

                // 執行批次取代
                int replacedCount = 0;
                HashSet<string> modifiedFiles = new HashSet<string>();
                foreach (var kvp in _document.S32Files)
                {
                    foreach (var item in kvp.Value.Layer8)
                    {
                        if (item.SprId == fromSprId)
                        {
                            item.SprId = toSprId;
                            replacedCount++;
                            modifiedFiles.Add(kvp.Key);
                        }
                    }
                    if (modifiedFiles.Contains(kvp.Key))
                    {
                        kvp.Value.IsModified = true;
                    }
                }

                // 載入新的 SPR 圖片
                Image newSprImg = LoadSprImage(toSprId);
                string newImgKey = $"spr_{toSprId}";
                if (!sprImageList.Images.ContainsKey(newImgKey))
                {
                    sprImageList.Images.Add(newImgKey, newSprImg);
                }

                // 更新 ListView 顯示
                foreach (ListView lv in new[] { lvSelected, lvAll })
                {
                    foreach (ListViewItem lvi in lv.Items)
                    {
                        if (lvi.Tag == null) continue;
                        var (filePath, item) = ((string, Layer8Item))lvi.Tag;
                        if (item.SprId == toSprId && lvi.SubItems[2].Text == fromSprId.ToString())
                        {
                            lvi.SubItems[2].Text = toSprId.ToString();
                            lvi.ImageKey = newImgKey;
                        }
                    }
                }

                WinFormsMessageBox.Show(
                    string.Format(LocalizationManager.L("L8_BatchReplaceComplete"), replacedCount, fromSprId, toSprId, modifiedFiles.Count),
                    LocalizationManager.L("L8_BatchReplaceCompleteTitle"),
                    MessageBoxButtons.OK,
                    MessageBoxIcon.Information);
            };

            Label lblBatchHint = new Label { Text = LocalizationManager.L("L8_AffectsAllS32"), Size = new Size(120, 20), ForeColor = Colors.Gray };
            lblBatchHint.SetLocation(new Point(370, 20));

            gbBatchReplace.GetControls().Add(lblFromSpr);
            gbBatchReplace.GetControls().Add(txtFromSprId);
            gbBatchReplace.GetControls().Add(lblToSpr);
            gbBatchReplace.GetControls().Add(txtToSprId);
            gbBatchReplace.GetControls().Add(btnBatchReplace);
            gbBatchReplace.GetControls().Add(lblBatchHint);
            resultForm.GetControls().Add(gbBatchReplace);

            // 調整表單高度以容納批次取代區域
            resultForm.Size = new Size(850, 720);

            // 選取項目時填入編輯區（為兩個 ListView 都註冊事件）
            void OnListViewSelectionChanged(object sender, EventArgs args)
            {
                ListView lv = sender as ListView;
                if (lv != null && lv.SelectedItems.Count == 1 && lv.SelectedItems[0].Tag != null)
                {
                    var lvi = lv.SelectedItems[0];
                    var (filePath, item) = ((string, Layer8Item))lvi.Tag;
                    txtSprId.Text = item.SprId.ToString();
                    txtX.Text = item.X.ToString();
                    txtY.Text = item.Y.ToString();
                    txtExtData.Text = item.ExtendedData.ToString();
                }
            }
            lvSelected.SelectedIndexChanged += OnListViewSelectionChanged;
            lvAll.SelectedIndexChanged += OnListViewSelectionChanged;

            Button btnSelectAll = new Button();
            btnSelectAll.Text = LocalizationManager.L("L8_SelectAll");
            btnSelectAll.SetLocation(new Point(10, 595));
            btnSelectAll.Size = new Size(80, 28);
            btnSelectAll.Click += (s, args) =>
            {
                ListView currentLv = tabControl.SelectedIndex == 0 ? lvAll : lvSelected;
                foreach (ListViewItem lvi in currentLv.Items)
                    lvi.Checked = true;
            };
            resultForm.GetControls().Add(btnSelectAll);

            Button btnDeselectAll = new Button();
            btnDeselectAll.Text = LocalizationManager.L("L8_DeselectAll");
            btnDeselectAll.SetLocation(new Point(100, 595));
            btnDeselectAll.Size = new Size(80, 28);
            btnDeselectAll.Click += (s, args) =>
            {
                ListView currentLv = tabControl.SelectedIndex == 0 ? lvAll : lvSelected;
                foreach (ListViewItem lvi in currentLv.Items)
                    lvi.Checked = false;
            };
            resultForm.GetControls().Add(btnDeselectAll);

            Button btnClearSelected = new Button();
            btnClearSelected.Text = LocalizationManager.L("L8_DeleteChecked");
            btnClearSelected.SetLocation(new Point(10, 630));
            btnClearSelected.Size = new Size(120, 32);
            btnClearSelected.BackgroundColor = WinFormsColors.LightCoral;
            btnClearSelected.Enabled = s32WithL8.Count > 0;
            btnClearSelected.Click += (s, args) =>
            {
                ListView currentLv = tabControl.SelectedIndex == 0 ? lvAll : lvSelected;
                int checkedCount = currentLv.CheckedItems.Count;
                if (checkedCount == 0)
                {
                    WinFormsMessageBox.Show(LocalizationManager.L("L8_SelectToDelete"), LocalizationManager.L("Title_Info"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                    return;
                }

                var confirmResult = WinFormsMessageBox.Show(
                    string.Format(LocalizationManager.L("L8_ConfirmDeleteChecked"), checkedCount),
                    LocalizationManager.L("L8_ConfirmDeleteTitle"),
                    MessageBoxButtons.YesNo,
                    MessageBoxIcon.Warning);

                if (confirmResult != DialogResult.Yes) return;

                Dictionary<string, List<Layer8Item>> toRemove = new Dictionary<string, List<Layer8Item>>();
                foreach (ListViewItem lvi in currentLv.CheckedItems)
                {
                    if (lvi.Tag == null) continue;
                    var (filePath, item) = ((string, Layer8Item))lvi.Tag;
                    if (!toRemove.ContainsKey(filePath))
                        toRemove[filePath] = new List<Layer8Item>();
                    toRemove[filePath].Add(item);
                }

                int removedCount = 0;
                foreach (var kvp in toRemove)
                {
                    if (_document.S32Files.TryGetValue(kvp.Key, out S32Data s32Data))
                    {
                        foreach (var item in kvp.Value)
                        {
                            if (s32Data.Layer8.Remove(item))
                                removedCount++;
                        }
                        s32Data.IsModified = true;
                    }
                }

                WinFormsMessageBox.Show(string.Format(LocalizationManager.L("L8_DeleteComplete"), removedCount), LocalizationManager.L("Title_Done"),
                    MessageBoxButtons.OK, MessageBoxIcon.Information);

                resultForm.Close();
                RenderS32Map();
            };
            resultForm.GetControls().Add(btnClearSelected);

            Button btnClearAll = new Button();
            btnClearAll.Text = LocalizationManager.L("L8_DeleteAll");
            btnClearAll.SetLocation(new Point(140, 630));
            btnClearAll.Size = new Size(120, 32);
            btnClearAll.BackgroundColor = WinFormsColors.Salmon;
            btnClearAll.Enabled = s32WithL8.Count > 0;
            btnClearAll.Click += (s, args) =>
            {
                var confirmResult = WinFormsMessageBox.Show(
                    string.Format(LocalizationManager.L("L8_ConfirmDeleteAll"), totalItems),
                    LocalizationManager.L("L8_ConfirmDeleteAllTitle"),
                    MessageBoxButtons.YesNo,
                    MessageBoxIcon.Warning);

                if (confirmResult != DialogResult.Yes) return;

                int removedCount = 0;
                foreach (var (filePath, fileName, count, items) in s32WithL8)
                {
                    if (_document.S32Files.TryGetValue(filePath, out S32Data s32Data))
                    {
                        removedCount += s32Data.Layer8.Count;
                        s32Data.Layer8.Clear();
                        s32Data.IsModified = true;
                    }
                }

                WinFormsMessageBox.Show(string.Format(LocalizationManager.L("L8_DeleteComplete"), removedCount), LocalizationManager.L("Title_Done"),
                    MessageBoxButtons.OK, MessageBoxIcon.Information);

                resultForm.Close();
                RenderS32Map();
            };
            resultForm.GetControls().Add(btnClearAll);

            Button btnClose = new Button();
            btnClose.Text = LocalizationManager.L("L8_Close");
            btnClose.SetLocation(new Point(730, 630));
            btnClose.Size = new Size(90, 32);
            btnClose.Click += (s, args) => resultForm.Close();
            resultForm.GetControls().Add(btnClose);

            // 使用非模態對話框，可以平行瀏覽地圖
            resultForm.Show();
        }

        // 啟用畫面中所有可見的 L8 特效
        private void btnEnableVisibleL8_Click(object sender, EventArgs e)
        {
            if (_document.S32Files.Count == 0)
            {
                WinFormsMessageBox.Show(LocalizationManager.L("Message_PleaseLoadMap"), LocalizationManager.L("Title_Info"), MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            int enabledCount = 0;

            foreach (var s32Data in _document.S32Files.Values)
            {
                if (s32Data.Layer8.Count == 0) continue;

                int[] loc = s32Data.SegInfo.GetLoc(1.0);
                int mx = loc[0];
                int my = loc[1];

                for (int i = 0; i < s32Data.Layer8.Count; i++)
                {
                    var item = s32Data.Layer8[i];

                    // Layer8 X,Y 是絕對遊戲座標，先轉為本地座標
                    int localLayer3X = item.X - s32Data.SegInfo.nLinBeginX;
                    int localLayer3Y = item.Y - s32Data.SegInfo.nLinBeginY;

                    if (localLayer3X < 0 || localLayer3X > 63 || localLayer3Y < 0 || localLayer3Y > 63)
                        continue;

                    int layer1X = localLayer3X * 2;
                    int layer1Y = localLayer3Y;

                    int baseX = -24 * (layer1X / 2);
                    int baseY = 63 * 12 - 12 * (layer1X / 2);

                    int markerWorldX = mx + baseX + layer1X * 24 + layer1Y * 24 + 12;
                    int markerWorldY = my + baseY + layer1Y * 12 + 12;

                    // 轉為螢幕座標
                    var markerScreenPoint = _mapViewerControl.WorldToScreen(new Point(markerWorldX, markerWorldY));
                    int markerX = markerScreenPoint.X;
                    int markerY = markerScreenPoint.Y;

                    // 檢查是否在可見範圍內
                    if (markerX >= -50 && markerX <= _mapViewerControl.Width + 50 &&
                        markerY >= -50 && markerY <= _mapViewerControl.Height + 50)
                    {
                        var key = (s32Data.FilePath, i);
                        if (!_editState.EnabledLayer8Items.Contains(key))
                        {
                            _editState.EnabledLayer8Items.Add(key);
                            _renderCache.Layer8AnimFrame[key] = 0;
                            enabledCount++;
                        }
                    }
                }
            }

            // 啟動動畫計時器
            if (enabledCount > 0 && _layer8AnimTimer != null && !_layer8AnimTimer.Enabled)
            {
                _layer8AnimTimer.Start();
            }

            // 重繪 L8 動畫覆蓋層
            _mapViewerControl?.InvalidateAnimationOverlay();
        }

        // 查看與編輯第一層（地板圖塊）資料
        private void btnToolCheckL1_Click(object sender, EventArgs e)
        {
            if (_document.S32Files.Count == 0)
            {
                WinFormsMessageBox.Show("請先載入地圖", "提示", MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            // 顯示結果
            Form resultForm = new Form();
            resultForm.Text = $"L1 檢查與編輯 - {_document.S32Files.Count} 個 S32 檔案";
            resultForm.Size = new Size(750, 620);
            resultForm.SetFormBorderStyle(FormBorderStyle.Sizable);
            resultForm.SetStartPosition(FormStartPosition.CenterParent);

            Label lblSummary = new Label();
            lblSummary.Text = $"共 {_document.S32Files.Count} 個 S32 檔案。選擇 S32 檔案後可編輯指定座標的 Layer1 資料：";
            lblSummary.SetLocation(new Point(10, 10));
            lblSummary.Size = new Size(710, 20);
            resultForm.GetControls().Add(lblSummary);

            // S32 檔案選擇清單
            Label lblS32 = new Label { Text = "S32 檔案:", Size = new Size(70, 20) };
            lblS32.SetLocation(new Point(10, 40));
            resultForm.GetControls().Add(lblS32);

            ComboBox cmbS32Files = new ComboBox();
            cmbS32Files.SetLocation(new Point(85, 37));
            cmbS32Files.Size = new Size(200, 23);
            cmbS32Files.DropDownStyle = ComboBoxStyle.DropDownList;
            foreach (var kvp in _document.S32Files)
            {
                cmbS32Files.Items.Add(Path.GetFileName(kvp.Key));
            }
            if (cmbS32Files.Items.Count > 0)
                cmbS32Files.SelectedIndex = 0;
            resultForm.GetControls().Add(cmbS32Files);

            // 座標輸入
            Label lblLocX = new Label { Text = "X:", Size = new Size(20, 20) };
            lblLocX.SetLocation(new Point(300, 40));
            TextBox txtLocX = new TextBox { Size = new Size(50, 23), Text = "0" };
            txtLocX.SetLocation(new Point(325, 37));
            Label lblLocY = new Label { Text = "Y:", Size = new Size(20, 20) };
            lblLocY.SetLocation(new Point(385, 40));
            TextBox txtLocY = new TextBox { Size = new Size(50, 23), Text = "0" };
            txtLocY.SetLocation(new Point(410, 37));
            resultForm.GetControls().Add(lblLocX);
            resultForm.GetControls().Add(txtLocX);
            resultForm.GetControls().Add(lblLocY);
            resultForm.GetControls().Add(txtLocY);

            Button btnQuery = new Button();
            btnQuery.Text = "查詢";
            btnQuery.SetLocation(new Point(470, 35));
            btnQuery.Size = new Size(60, 27);
            resultForm.GetControls().Add(btnQuery);

            // 結果顯示區
            GroupBox gbResult = new GroupBox();
            gbResult.Text = "查詢結果 / 編輯區域";
            gbResult.SetLocation(new Point(10, 75));
            gbResult.Size = new Size(710, 120);

            Label lblResultInfo = new Label { Text = "請選擇 S32 檔案並輸入座標後點擊「查詢」", Size = new Size(400, 20) };
            lblResultInfo.SetLocation(new Point(10, 25));
            gbResult.GetControls().Add(lblResultInfo);

            Label lblTileId = new Label { Text = "TileId:", Size = new Size(50, 20) };
            lblTileId.SetLocation(new Point(10, 55));
            TextBox txtTileId = new TextBox { Size = new Size(80, 23), Enabled = false };
            txtTileId.SetLocation(new Point(65, 52));
            Label lblIndexId = new Label { Text = "IndexId:", Size = new Size(55, 20) };
            lblIndexId.SetLocation(new Point(160, 55));
            TextBox txtIndexId = new TextBox { Size = new Size(80, 23), Enabled = false };
            txtIndexId.SetLocation(new Point(220, 52));
            gbResult.GetControls().Add(lblTileId);
            gbResult.GetControls().Add(txtTileId);
            gbResult.GetControls().Add(lblIndexId);
            gbResult.GetControls().Add(txtIndexId);

            Button btnApplyEdit = new Button();
            btnApplyEdit.Text = "套用修改";
            btnApplyEdit.SetLocation(new Point(320, 50));
            btnApplyEdit.Size = new Size(80, 28);
            btnApplyEdit.Enabled = false;
            gbResult.GetControls().Add(btnApplyEdit);

            resultForm.GetControls().Add(gbResult);

            // 批量修改區域
            GroupBox gbBatch = new GroupBox();
            gbBatch.Text = "批量替換 TileId";
            gbBatch.SetLocation(new Point(10, 205));
            gbBatch.Size = new Size(710, 80);

            Label lblOldTileId = new Label { Text = "原 TileId:", Size = new Size(60, 20) };
            lblOldTileId.SetLocation(new Point(10, 30));
            TextBox txtOldTileId = new TextBox { Size = new Size(80, 23) };
            txtOldTileId.SetLocation(new Point(75, 27));
            Label lblNewTileId = new Label { Text = "新 TileId:", Size = new Size(60, 20) };
            lblNewTileId.SetLocation(new Point(170, 30));
            TextBox txtNewTileId = new TextBox { Size = new Size(80, 23) };
            txtNewTileId.SetLocation(new Point(235, 27));
            Label lblBatchScope = new Label { Text = "範圍:", Size = new Size(40, 20) };
            lblBatchScope.SetLocation(new Point(330, 30));
            ComboBox cmbBatchScope = new ComboBox { Size = new Size(150, 23), DropDownStyle = ComboBoxStyle.DropDownList };
            cmbBatchScope.SetLocation(new Point(375, 27));
            cmbBatchScope.Items.Add("當前選擇的 S32");
            cmbBatchScope.Items.Add("所有 S32 檔案");
            cmbBatchScope.SelectedIndex = 0;

            Button btnBatchReplace = new Button();
            btnBatchReplace.Text = "批量替換";
            btnBatchReplace.SetLocation(new Point(540, 25));
            btnBatchReplace.Size = new Size(80, 28);
            btnBatchReplace.BackgroundColor = Colors.LightYellow;

            gbBatch.GetControls().Add(lblOldTileId);
            gbBatch.GetControls().Add(txtOldTileId);
            gbBatch.GetControls().Add(lblNewTileId);
            gbBatch.GetControls().Add(txtNewTileId);
            gbBatch.GetControls().Add(lblBatchScope);
            gbBatch.GetControls().Add(cmbBatchScope);
            gbBatch.GetControls().Add(btnBatchReplace);
            resultForm.GetControls().Add(gbBatch);

            // 批量刪除區域
            GroupBox gbDelete = new GroupBox();
            gbDelete.Text = "批量刪除（將 TileId 設為 0）";
            gbDelete.SetLocation(new Point(10, 290));
            gbDelete.Size = new Size(710, 80);

            Label lblDelTileId = new Label { Text = "TileId:", Size = new Size(50, 20) };
            lblDelTileId.SetLocation(new Point(10, 30));
            TextBox txtDelTileId = new TextBox { Size = new Size(80, 23) };
            txtDelTileId.SetLocation(new Point(65, 27));
            Label lblDelScope = new Label { Text = "範圍:", Size = new Size(40, 20) };
            lblDelScope.SetLocation(new Point(160, 30));
            ComboBox cmbDelScope = new ComboBox { Size = new Size(150, 23), DropDownStyle = ComboBoxStyle.DropDownList };
            cmbDelScope.SetLocation(new Point(205, 27));
            cmbDelScope.Items.Add("當前選擇的 S32");
            cmbDelScope.Items.Add("所有 S32 檔案");
            cmbDelScope.SelectedIndex = 0;

            Button btnBatchDelete = new Button();
            btnBatchDelete.Text = "批量刪除";
            btnBatchDelete.SetLocation(new Point(370, 25));
            btnBatchDelete.Size = new Size(80, 28);
            btnBatchDelete.BackgroundColor = WinFormsColors.LightCoral;

            Button btnDeleteFromStats = new Button();
            btnDeleteFromStats.Text = "刪除選中統計項";
            btnDeleteFromStats.SetLocation(new Point(460, 25));
            btnDeleteFromStats.Size = new Size(110, 28);
            btnDeleteFromStats.BackgroundColor = WinFormsColors.LightCoral;
            this.toolTip1.SetToolTip(btnDeleteFromStats, "在下方統計清單中選擇項目後，點擊此按鈕刪除");

            gbDelete.GetControls().Add(lblDelTileId);
            gbDelete.GetControls().Add(txtDelTileId);
            gbDelete.GetControls().Add(lblDelScope);
            gbDelete.GetControls().Add(cmbDelScope);
            gbDelete.GetControls().Add(btnBatchDelete);
            gbDelete.GetControls().Add(btnDeleteFromStats);
            resultForm.GetControls().Add(gbDelete);

            // 統計資訊
            GroupBox gbStats = new GroupBox();
            gbStats.Text = "統計資訊（點擊項目可填入 TileId）";
            gbStats.SetLocation(new Point(10, 375));
            gbStats.Size = new Size(710, 130);

            ListView lvStats = new ListView();
            lvStats.SetLocation(new Point(10, 20));
            lvStats.Size = new Size(690, 130);
            lvStats.Font = new Font("Consolas", 9);
            lvStats.View = View.Details;
            lvStats.FullRowSelect = true;
            lvStats.Columns.Add("TileId", 80);
            lvStats.Columns.Add("使用次數", 80);
            lvStats.Columns.Add("IndexId", 80);
            gbStats.GetControls().Add(lvStats);

            resultForm.GetControls().Add(gbStats);

            Button btnClose = new Button();
            btnClose.Text = "關閉";
            btnClose.SetLocation(new Point(630, 525));
            btnClose.Size = new Size(90, 35);
            btnClose.Click += (s, args) => resultForm.Close();
            resultForm.GetControls().Add(btnClose);

            // ListView 項目點擊填入 TileId
            lvStats.Click += (s, args) =>
            {
                if (lvStats.SelectedItems.Count > 0)
                {
                    string tileIdStr = lvStats.SelectedItems[0].Text;
                    txtDelTileId.Text = tileIdStr;
                    txtOldTileId.Text = tileIdStr;
                }
            };

            // 當前查詢的 TileCell
            TileCell currentCell = null;
            string currentFilePath = null;
            int currentX = -1, currentY = -1;

            // 更新統計資訊
            Action updateStats = () =>
            {
                lvStats.Items.Clear();
                if (cmbS32Files.SelectedItem == null) return;

                string selectedFileName = cmbS32Files.SelectedItem.ToString();
                string selectedFilePath = _document.S32Files.Keys.FirstOrDefault(k => Path.GetFileName(k) == selectedFileName);
                if (selectedFilePath == null || !_document.S32Files.TryGetValue(selectedFilePath, out S32Data s32Data)) return;

                // 統計 TileId 使用次數
                Dictionary<int, (int count, int indexId)> tileStats = new Dictionary<int, (int, int)>();
                for (int y = 0; y < 64; y++)
                {
                    for (int x = 0; x < 128; x++)
                    {
                        var cell = s32Data.Layer1[y, x];
                        if (cell != null)
                        {
                            if (!tileStats.ContainsKey(cell.TileId))
                                tileStats[cell.TileId] = (1, cell.IndexId);
                            else
                                tileStats[cell.TileId] = (tileStats[cell.TileId].count + 1, cell.IndexId);
                        }
                    }
                }

                // 排序顯示
                foreach (var kvp in tileStats.OrderByDescending(k => k.Value.count))
                {
                    ListViewItem lvi = new ListViewItem(kvp.Key.ToString());
                    lvi.SubItems.Add(kvp.Value.count.ToString());
                    lvi.SubItems.Add(kvp.Value.indexId.ToString());
                    lvStats.Items.Add(lvi);
                }
            };

            // 查詢按鈕事件
            btnQuery.Click += (s, args) =>
            {
                if (cmbS32Files.SelectedItem == null)
                {
                    WinFormsMessageBox.Show("請選擇 S32 檔案", "提示", MessageBoxButtons.OK, MessageBoxIcon.Information);
                    return;
                }

                if (!int.TryParse(txtLocX.Text, out int locX) || !int.TryParse(txtLocY.Text, out int locY))
                {
                    WinFormsMessageBox.Show("請輸入有效的座標", "錯誤", MessageBoxButtons.OK, MessageBoxIcon.Error);
                    return;
                }

                if (locX < 0 || locX >= 128 || locY < 0 || locY >= 64)
                {
                    WinFormsMessageBox.Show("座標超出範圍。X 範圍: 0-127, Y 範圍: 0-63", "錯誤", MessageBoxButtons.OK, MessageBoxIcon.Error);
                    return;
                }

                string selectedFileName = cmbS32Files.SelectedItem.ToString();
                string selectedFilePath = _document.S32Files.Keys.FirstOrDefault(k => Path.GetFileName(k) == selectedFileName);
                if (selectedFilePath == null || !_document.S32Files.TryGetValue(selectedFilePath, out S32Data s32Data))
                {
                    WinFormsMessageBox.Show("無法載入 S32 資料", "錯誤", MessageBoxButtons.OK, MessageBoxIcon.Error);
                    return;
                }

                var cell = s32Data.Layer1[locY, locX];
                if (cell == null)
                {
                    lblResultInfo.Text = $"座標 ({locX}, {locY}) 無資料";
                    txtTileId.Text = "";
                    txtIndexId.Text = "";
                    txtTileId.Enabled = false;
                    txtIndexId.Enabled = false;
                    btnApplyEdit.Enabled = false;
                    currentCell = null;
                }
                else
                {
                    lblResultInfo.Text = $"座標 ({locX}, {locY}) 的 Layer1 資料：";
                    txtTileId.Text = cell.TileId.ToString();
                    txtIndexId.Text = cell.IndexId.ToString();
                    txtTileId.Enabled = true;
                    txtIndexId.Enabled = true;
                    btnApplyEdit.Enabled = true;
                    currentCell = cell;
                    currentFilePath = selectedFilePath;
                    currentX = locX;
                    currentY = locY;
                }
            };

            // 套用修改按鈕事件
            btnApplyEdit.Click += (s, args) =>
            {
                if (currentCell == null || currentFilePath == null)
                {
                    WinFormsMessageBox.Show("請先查詢一個有效的座標", "提示", MessageBoxButtons.OK, MessageBoxIcon.Information);
                    return;
                }

                if (!int.TryParse(txtTileId.Text, out int newTileId) || !int.TryParse(txtIndexId.Text, out int newIndexId))
                {
                    WinFormsMessageBox.Show("請輸入有效的數值", "錯誤", MessageBoxButtons.OK, MessageBoxIcon.Error);
                    return;
                }

                currentCell.TileId = newTileId;
                currentCell.IndexId = newIndexId;

                if (_document.S32Files.TryGetValue(currentFilePath, out S32Data s32Data))
                {
                    s32Data.IsModified = true;
                }

                WinFormsMessageBox.Show($"已修改座標 ({currentX}, {currentY}) 的 Layer1 資料。\n\n請記得儲存 S32 檔案。", "完成",
                    MessageBoxButtons.OK, MessageBoxIcon.Information);

                updateStats();
            };

            // 批量替換按鈕事件
            btnBatchReplace.Click += (s, args) =>
            {
                if (!int.TryParse(txtOldTileId.Text, out int oldTileId) || !int.TryParse(txtNewTileId.Text, out int newTileId))
                {
                    WinFormsMessageBox.Show("請輸入有效的 TileId", "錯誤", MessageBoxButtons.OK, MessageBoxIcon.Error);
                    return;
                }

                bool allFiles = cmbBatchScope.SelectedIndex == 1;
                int replacedCount = 0;

                if (allFiles)
                {
                    var confirmResult = WinFormsMessageBox.Show(
                        $"確定要在所有 S32 檔案中將 TileId {oldTileId} 替換為 {newTileId} 嗎？",
                        "確認批量替換",
                        MessageBoxButtons.YesNo,
                        MessageBoxIcon.Warning);
                    if (confirmResult != DialogResult.Yes) return;

                    foreach (var kvp in _document.S32Files)
                    {
                        S32Data s32Data = kvp.Value;
                        for (int y = 0; y < 64; y++)
                        {
                            for (int x = 0; x < 128; x++)
                            {
                                var cell = s32Data.Layer1[y, x];
                                if (cell != null && cell.TileId == oldTileId)
                                {
                                    cell.TileId = newTileId;
                                    replacedCount++;
                                }
                            }
                        }
                        if (replacedCount > 0)
                            s32Data.IsModified = true;
                    }
                }
                else
                {
                    if (cmbS32Files.SelectedItem == null)
                    {
                        WinFormsMessageBox.Show("請選擇 S32 檔案", "提示", MessageBoxButtons.OK, MessageBoxIcon.Information);
                        return;
                    }

                    string selectedFileName = cmbS32Files.SelectedItem.ToString();
                    string selectedFilePath = _document.S32Files.Keys.FirstOrDefault(k => Path.GetFileName(k) == selectedFileName);
                    if (selectedFilePath == null || !_document.S32Files.TryGetValue(selectedFilePath, out S32Data s32Data))
                    {
                        WinFormsMessageBox.Show("無法載入 S32 資料", "錯誤", MessageBoxButtons.OK, MessageBoxIcon.Error);
                        return;
                    }

                    var confirmResult = WinFormsMessageBox.Show(
                        $"確定要在 {selectedFileName} 中將 TileId {oldTileId} 替換為 {newTileId} 嗎？",
                        "確認批量替換",
                        MessageBoxButtons.YesNo,
                        MessageBoxIcon.Warning);
                    if (confirmResult != DialogResult.Yes) return;

                    for (int y = 0; y < 64; y++)
                    {
                        for (int x = 0; x < 128; x++)
                        {
                            var cell = s32Data.Layer1[y, x];
                            if (cell != null && cell.TileId == oldTileId)
                            {
                                cell.TileId = newTileId;
                                replacedCount++;
                            }
                        }
                    }
                    if (replacedCount > 0)
                        s32Data.IsModified = true;
                }

                WinFormsMessageBox.Show($"已替換 {replacedCount} 個 Layer1 項目。\n\n請記得儲存 S32 檔案。", "完成",
                    MessageBoxButtons.OK, MessageBoxIcon.Information);

                updateStats();
                RenderS32Map();
            };

            // 批量刪除按鈕事件
            btnBatchDelete.Click += (s, args) =>
            {
                if (!int.TryParse(txtDelTileId.Text, out int delTileId))
                {
                    WinFormsMessageBox.Show("請輸入有效的 TileId", "錯誤", MessageBoxButtons.OK, MessageBoxIcon.Error);
                    return;
                }

                bool allFiles = cmbDelScope.SelectedIndex == 1;
                int deletedCount = 0;

                if (allFiles)
                {
                    var confirmResult = WinFormsMessageBox.Show(
                        $"確定要在所有 S32 檔案中刪除 TileId = {delTileId} 的所有項目嗎？\n\n（將 TileId 設為 0）",
                        "確認批量刪除",
                        MessageBoxButtons.YesNo,
                        MessageBoxIcon.Warning);
                    if (confirmResult != DialogResult.Yes) return;

                    foreach (var kvp in _document.S32Files)
                    {
                        S32Data s32Data = kvp.Value;
                        bool modified = false;
                        for (int y = 0; y < 64; y++)
                        {
                            for (int x = 0; x < 128; x++)
                            {
                                var cell = s32Data.Layer1[y, x];
                                if (cell != null && cell.TileId == delTileId)
                                {
                                    cell.TileId = 0;
                                    cell.IndexId = 0;
                                    deletedCount++;
                                    modified = true;
                                }
                            }
                        }
                        if (modified)
                            s32Data.IsModified = true;
                    }
                }
                else
                {
                    if (cmbS32Files.SelectedItem == null)
                    {
                        WinFormsMessageBox.Show("請選擇 S32 檔案", "提示", MessageBoxButtons.OK, MessageBoxIcon.Information);
                        return;
                    }

                    string selectedFileName = cmbS32Files.SelectedItem.ToString();
                    string selectedFilePath = _document.S32Files.Keys.FirstOrDefault(k => Path.GetFileName(k) == selectedFileName);
                    if (selectedFilePath == null || !_document.S32Files.TryGetValue(selectedFilePath, out S32Data s32Data))
                    {
                        WinFormsMessageBox.Show("無法載入 S32 資料", "錯誤", MessageBoxButtons.OK, MessageBoxIcon.Error);
                        return;
                    }

                    var confirmResult = WinFormsMessageBox.Show(
                        $"確定要在 {selectedFileName} 中刪除 TileId = {delTileId} 的所有項目嗎？\n\n（將 TileId 設為 0）",
                        "確認批量刪除",
                        MessageBoxButtons.YesNo,
                        MessageBoxIcon.Warning);
                    if (confirmResult != DialogResult.Yes) return;

                    for (int y = 0; y < 64; y++)
                    {
                        for (int x = 0; x < 128; x++)
                        {
                            var cell = s32Data.Layer1[y, x];
                            if (cell != null && cell.TileId == delTileId)
                            {
                                cell.TileId = 0;
                                cell.IndexId = 0;
                                deletedCount++;
                            }
                        }
                    }
                    if (deletedCount > 0)
                        s32Data.IsModified = true;
                }

                WinFormsMessageBox.Show($"已刪除 {deletedCount} 個 Layer1 項目（TileId 設為 0）。\n\n請記得儲存 S32 檔案。", "完成",
                    MessageBoxButtons.OK, MessageBoxIcon.Information);

                updateStats();
                ClearS32BlockCache();
                RenderS32Map();
            };

            // 從統計清單刪除選中項目
            btnDeleteFromStats.Click += (s, args) =>
            {
                if (lvStats.SelectedItems.Count == 0)
                {
                    WinFormsMessageBox.Show("請先在統計清單中選擇要刪除的 TileId", "提示", MessageBoxButtons.OK, MessageBoxIcon.Information);
                    return;
                }

                // 收集所有選中的 TileId
                var selectedTileIds = new List<int>();
                foreach (ListViewItem item in lvStats.SelectedItems)
                {
                    if (int.TryParse(item.Text, out int tileId))
                        selectedTileIds.Add(tileId);
                }

                if (selectedTileIds.Count == 0) return;

                bool allFiles = cmbDelScope.SelectedIndex == 1;
                string scopeText = allFiles ? "所有 S32 檔案" : cmbS32Files.SelectedItem?.ToString() ?? "當前 S32";
                string tileIdsText = string.Join(", ", selectedTileIds);

                var confirmResult = WinFormsMessageBox.Show(
                    $"確定要在 {scopeText} 中刪除以下 TileId 嗎？\n\nTileId: {tileIdsText}\n\n（將 TileId 設為 0）",
                    "確認批量刪除",
                    MessageBoxButtons.YesNo,
                    MessageBoxIcon.Warning);
                if (confirmResult != DialogResult.Yes) return;

                int deletedCount = 0;
                var tileIdSet = new HashSet<int>(selectedTileIds);

                if (allFiles)
                {
                    foreach (var kvp in _document.S32Files)
                    {
                        S32Data s32Data = kvp.Value;
                        bool modified = false;
                        for (int y = 0; y < 64; y++)
                        {
                            for (int x = 0; x < 128; x++)
                            {
                                var cell = s32Data.Layer1[y, x];
                                if (cell != null && tileIdSet.Contains(cell.TileId))
                                {
                                    cell.TileId = 0;
                                    cell.IndexId = 0;
                                    deletedCount++;
                                    modified = true;
                                }
                            }
                        }
                        if (modified)
                            s32Data.IsModified = true;
                    }
                }
                else
                {
                    if (cmbS32Files.SelectedItem == null)
                    {
                        WinFormsMessageBox.Show("請選擇 S32 檔案", "提示", MessageBoxButtons.OK, MessageBoxIcon.Information);
                        return;
                    }

                    string selectedFileName = cmbS32Files.SelectedItem.ToString();
                    string selectedFilePath = _document.S32Files.Keys.FirstOrDefault(k => Path.GetFileName(k) == selectedFileName);
                    if (selectedFilePath != null && _document.S32Files.TryGetValue(selectedFilePath, out S32Data s32Data))
                    {
                        for (int y = 0; y < 64; y++)
                        {
                            for (int x = 0; x < 128; x++)
                            {
                                var cell = s32Data.Layer1[y, x];
                                if (cell != null && tileIdSet.Contains(cell.TileId))
                                {
                                    cell.TileId = 0;
                                    cell.IndexId = 0;
                                    deletedCount++;
                                }
                            }
                        }
                        if (deletedCount > 0)
                            s32Data.IsModified = true;
                    }
                }

                WinFormsMessageBox.Show($"已刪除 {deletedCount} 個 Layer1 項目（TileId 設為 0）。\n\n請記得儲存 S32 檔案。", "完成",
                    MessageBoxButtons.OK, MessageBoxIcon.Information);

                updateStats();
                ClearS32BlockCache();
                RenderS32Map();
            };

            // S32 檔案選擇變更時更新統計
            cmbS32Files.SelectedIndexChanged += (s, args) =>
            {
                updateStats();
                // 清除查詢結果
                lblResultInfo.Text = "請選擇 S32 檔案並輸入座標後點擊「查詢」";
                txtTileId.Text = "";
                txtIndexId.Text = "";
                txtTileId.Enabled = false;
                txtIndexId.Enabled = false;
                btnApplyEdit.Enabled = false;
                currentCell = null;
            };

            // 初始載入統計
            updateStats();

            resultForm.Resize += (s, args) =>
            {
                // 確保 Size 不會是負數
                int clientWidth = Math.Max(100, resultForm.ClientSize.Width);
                int clientHeight = Math.Max(500, resultForm.ClientSize.Height);

                gbResult.Size = new Size(Math.Max(10, clientWidth - 20), 120);
                gbBatch.Size = new Size(Math.Max(10, clientWidth - 20), 80);
                gbBatch.SetLocation(new Point(10, 205));
                gbDelete.Size = new Size(Math.Max(10, clientWidth - 20), 80);
                gbDelete.SetLocation(new Point(10, 290));
                gbStats.Size = new Size(Math.Max(10, clientWidth - 20), Math.Max(10, clientHeight - 430));
                gbStats.SetLocation(new Point(10, 375));
                lvStats.Size = new Size(Math.Max(10, gbStats.Width - 20), Math.Max(10, gbStats.Height - 30));
                btnClose.SetLocation(new Point(Math.Max(10, clientWidth - 100), Math.Max(10, clientHeight - 45)));
            };

            resultForm.ShowDialog(this);
        }

        // 查看與清除第二層資料
        private void btnToolCheckL2_Click(object sender, EventArgs e)
        {
            if (_document.S32Files.Count == 0)
            {
                WinFormsMessageBox.Show("請先載入地圖", "提示", MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            // 收集所有 S32 的 Layer2 資料
            var s32WithL2 = new List<(string filePath, string fileName, int count, List<Layer2Item> items)>();
            int totalItems = 0;

            foreach (var kvp in _document.S32Files)
            {
                string filePath = kvp.Key;
                string fileName = Path.GetFileName(kvp.Key);
                S32Data s32Data = kvp.Value;

                if (s32Data.Layer2.Count > 0)
                {
                    s32WithL2.Add((filePath, fileName, s32Data.Layer2.Count, s32Data.Layer2.ToList()));
                    totalItems += s32Data.Layer2.Count;
                }
            }

            if (totalItems == 0)
            {
                WinFormsMessageBox.Show("目前沒有任何 Layer2 資料。", "提示", MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            // 顯示結果
            Form resultForm = new Form();
            resultForm.Text = $"L2 查看與清除 - {s32WithL2.Count} 個 S32 有資料，共 {totalItems} 項";
            resultForm.Size = new Size(850, 600);
            resultForm.SetFormBorderStyle(FormBorderStyle.Sizable);
            resultForm.SetStartPosition(FormStartPosition.CenterParent);

            Label lblSummary = new Label();
            lblSummary.Text = $"共 {s32WithL2.Count} 個 S32 檔案有 Layer2 資料，總計 {totalItems} 項。勾選後可清除：";
            lblSummary.SetLocation(new Point(10, 10));
            lblSummary.Size = new Size(810, 20);
            resultForm.GetControls().Add(lblSummary);

            // 使用 CheckedListBox 顯示所有 Layer2 項目
            CheckedListBox clbItems = new CheckedListBox();
            clbItems.SetLocation(new Point(10, 35));
            // 使用固定初始高度，Anchor 會在 Form 顯示後自動調整
            clbItems.Size = new Size(810, 370);
            clbItems.Font = new Font("Consolas", 9);
            clbItems.CheckOnClick = true;
            clbItems.SetAnchor(AnchorStyles.Top | AnchorStyles.Bottom | AnchorStyles.Left | AnchorStyles.Right);

            // 建立項目對應表（用於刪除）
            var itemMap = new List<(string filePath, Layer2Item item)>();

            foreach (var (filePath, fileName, count, items) in s32WithL2)
            {
                foreach (var item in items)
                {
                    string displayText = $"[{fileName}] X={item.X}, Y={item.Y}, Tile={item.TileId}, Idx={item.IndexId}, UK={item.UK}";
                    clbItems.Items.Add(displayText);
                    itemMap.Add((filePath, item));
                }
            }
            resultForm.GetControls().Add(clbItems);

            // 按鈕面板
            Panel pnlButtons = new Panel();
            // 使用固定初始位置，Anchor 會在 Form 顯示後自動調整
            pnlButtons.SetLocation(new Point(10, 410));
            pnlButtons.Size = new Size(810, 80);
            pnlButtons.SetAnchor(AnchorStyles.Bottom | AnchorStyles.Left | AnchorStyles.Right);
            resultForm.GetControls().Add(pnlButtons);

            Button btnSelectAll = new Button { Text = "全選", Size = new Size(80, 30) };
            btnSelectAll.SetLocation(new Point(0, 0));
            btnSelectAll.Click += (s, args) => { for (int i = 0; i < clbItems.Items.Count; i++) clbItems.SetItemChecked(i, true); };
            pnlButtons.GetControls().Add(btnSelectAll);

            Button btnDeselectAll = new Button { Text = "取消全選", Size = new Size(80, 30) };
            btnDeselectAll.SetLocation(new Point(90, 0));
            btnDeselectAll.Click += (s, args) => { for (int i = 0; i < clbItems.Items.Count; i++) clbItems.SetItemChecked(i, false); };
            pnlButtons.GetControls().Add(btnDeselectAll);

            // 按 S32 選擇
            Button btnSelectByS32 = new Button { Text = "按S32選", Size = new Size(80, 30) };
            btnSelectByS32.SetLocation(new Point(180, 0));
            btnSelectByS32.Click += (s, args) =>
            {
                // 顯示 S32 選擇對話框
                var s32Names = s32WithL2.Select(x => x.fileName).Distinct().ToList();
                using (var selectForm = new Form())
                {
                    selectForm.Text = "選擇 S32 檔案";
                    selectForm.Size = new Size(300, 400);
                    selectForm.SetStartPosition(FormStartPosition.CenterParent);

                    CheckedListBox clbS32 = new CheckedListBox();
                    clbS32.SetLocation(new Point(10, 10));
                    clbS32.Size = new Size(260, 300);
                    clbS32.CheckOnClick = true;
                    foreach (var name in s32Names) clbS32.Items.Add(name);
                    selectForm.GetControls().Add(clbS32);

                    Button btnOk = new Button { Text = "確定", Size = new Size(80, 30) };
                    btnOk.SetLocation(new Point(100, 320));
                    btnOk.Click += (s2, args2) =>
                    {
                        var selectedS32 = new HashSet<string>();
                        foreach (int idx in clbS32.CheckedIndices)
                            selectedS32.Add(s32Names[idx]);

                        for (int i = 0; i < itemMap.Count; i++)
                        {
                            string fileName = Path.GetFileName(itemMap[i].filePath);
                            clbItems.SetItemChecked(i, selectedS32.Contains(fileName));
                        }
                        selectForm.Close();
                    };
                    selectForm.GetControls().Add(btnOk);
                    selectForm.ShowDialog(this);
                }
            };
            pnlButtons.GetControls().Add(btnSelectByS32);

            Button btnClearSelected = new Button { Text = "清除勾選", Size = new Size(100, 35), BackColor = WinFormsColors.LightCoral };
            btnClearSelected.SetLocation(new Point(0, 40));
            btnClearSelected.Click += (s, args) =>
            {
                if (clbItems.CheckedIndices.Count == 0)
                {
                    WinFormsMessageBox.Show("請先勾選要清除的項目", "提示");
                    return;
                }

                if (WinFormsMessageBox.Show($"確定要清除勾選的 {clbItems.CheckedIndices.Count} 個 Layer2 項目嗎？",
                    "確認刪除", MessageBoxButtons.YesNo, MessageBoxIcon.Warning) != DialogResult.Yes)
                    return;

                // 按 S32 分組要刪除的項目
                var toDelete = new Dictionary<string, List<Layer2Item>>();
                foreach (int idx in clbItems.CheckedIndices)
                {
                    var (filePath, item) = itemMap[idx];
                    if (!toDelete.ContainsKey(filePath))
                        toDelete[filePath] = new List<Layer2Item>();
                    toDelete[filePath].Add(item);
                }

                int deletedCount = 0;
                foreach (var kvp in toDelete)
                {
                    if (_document.S32Files.TryGetValue(kvp.Key, out var s32Data))
                    {
                        foreach (var item in kvp.Value)
                        {
                            s32Data.Layer2.Remove(item);
                            deletedCount++;
                        }
                        s32Data.IsModified = true;
                    }
                }

                WinFormsMessageBox.Show($"已清除 {deletedCount} 個 Layer2 項目", "清除完成");
                ClearS32BlockCache();
                resultForm.Close();
                RenderS32Map();
            };
            pnlButtons.GetControls().Add(btnClearSelected);

            Button btnClearAll = new Button { Text = "清除全部", Size = new Size(100, 35), BackColor = WinFormsColors.Salmon };
            btnClearAll.SetLocation(new Point(110, 40));
            btnClearAll.Click += (s, args) =>
            {
                if (WinFormsMessageBox.Show($"確定要清除所有 {totalItems} 個 Layer2 項目嗎？\n\n這將清除所有 S32 檔案中的 Layer2 資料！",
                    "確認刪除全部", MessageBoxButtons.YesNo, MessageBoxIcon.Warning) != DialogResult.Yes)
                    return;

                int deletedCount = 0;
                foreach (var (filePath, _, _, _) in s32WithL2)
                {
                    if (_document.S32Files.TryGetValue(filePath, out var s32Data))
                    {
                        deletedCount += s32Data.Layer2.Count;
                        s32Data.Layer2.Clear();
                        s32Data.IsModified = true;
                    }
                }

                WinFormsMessageBox.Show($"已清除 {deletedCount} 個 Layer2 項目", "清除完成");
                ClearS32BlockCache();
                resultForm.Close();
                RenderS32Map();
            };
            pnlButtons.GetControls().Add(btnClearAll);

            Button btnClose = new Button { Text = "關閉", Size = new Size(80, 35), Anchor = AnchorStyles.Right };
            btnClose.SetLocation(new Point(pnlButtons.Width - 90, 40));
            btnClose.Click += (s, args) => resultForm.Close();
            pnlButtons.GetControls().Add(btnClose);

            resultForm.ShowDialog(this);
        }

        // 查看第三層（屬性）資料
        private void btnToolCheckL3_Click(object sender, EventArgs e)
        {
            if (_document.S32Files.Count == 0)
            {
                WinFormsMessageBox.Show("請先載入地圖", "提示", MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            // 收集所有 Layer3 資料項目 (同時保留本地座標和全域遊戲座標)
            var allItems = new List<(string filePath, string fileName, int localX, int localY, int globalX, int globalY, short attr1, short attr2, string region1, string pass1, string region2, string pass2)>();
            var s32Stats = new List<(string filePath, string fileName, int safeCount, int combatCount, int impassableCount, int totalNonZero)>();

            foreach (var kvp in _document.S32Files)
            {
                string filePath = kvp.Key;
                string fileName = Path.GetFileName(kvp.Key);
                S32Data s32Data = kvp.Value;

                // S32 的起始遊戲座標
                int baseGameX = s32Data.SegInfo.nLinBeginX;
                int baseGameY = s32Data.SegInfo.nLinBeginY;

                int safeCount = 0, combatCount = 0, impassableCount = 0, totalNonZero = 0;

                for (int y = 0; y < 64; y++)
                {
                    for (int x = 0; x < 64; x++)
                    {
                        var attr = s32Data.Layer3[y, x];
                        if (attr == null || (attr.Attribute1 == 0 && attr.Attribute2 == 0)) continue;

                        // 解析 Attribute1
                        int val1 = attr.Attribute1 & 0x0F;
                        bool pass1 = (attr.Attribute1 & 0x01) == 0;
                        string region1 = "一般";
                        if ((val1 & 0x04) != 0) { region1 = "安全"; safeCount++; }
                        else if ((val1 & 0x0C) == 0x08) { region1 = "戰鬥"; combatCount++; }
                        if (!pass1) impassableCount++;

                        // 解析 Attribute2
                        int val2 = attr.Attribute2 & 0x0F;
                        bool pass2 = (attr.Attribute2 & 0x01) == 0;
                        string region2 = "一般";
                        if ((val2 & 0x04) != 0) { region2 = "安全"; safeCount++; }
                        else if ((val2 & 0x0C) == 0x08) { region2 = "戰鬥"; combatCount++; }
                        if (!pass2) impassableCount++;

                        totalNonZero++;
                        // 計算全域遊戲座標
                        int globalX = baseGameX + x;
                        int globalY = baseGameY + y;
                        allItems.Add((filePath, fileName, x, y, globalX, globalY, attr.Attribute1, attr.Attribute2,
                            region1, pass1 ? "可通行" : "不可通行",
                            region2, pass2 ? "可通行" : "不可通行"));
                    }
                }

                if (totalNonZero > 0)
                    s32Stats.Add((filePath, fileName, safeCount, combatCount, impassableCount, totalNonZero));
            }

            // 預設排序：S32 asc, X asc, Y asc
            allItems.Sort((a, b) =>
            {
                int cmp = string.Compare(a.fileName, b.fileName, StringComparison.Ordinal);
                if (cmp != 0) return cmp;
                cmp = a.globalX.CompareTo(b.globalX);
                if (cmp != 0) return cmp;
                return a.globalY.CompareTo(b.globalY);
            });

            // 顯示結果
            Form resultForm = new Form();
            resultForm.Text = $"L3 查看 - 共 {allItems.Count} 筆資料";
            resultForm.Size = new Size(1000, 650);
            resultForm.SetFormBorderStyle(FormBorderStyle.Sizable);
            resultForm.SetStartPosition(FormStartPosition.CenterParent);

            TabControl tabControl = new TabControl();
            tabControl.SetDock(DockStyle.Fill);

            // Tab 1: 資料列表
            TabPage tabList = new TabPage("資料列表");
            ListView lvItems = new ListView();
            lvItems.SetDock(DockStyle.Fill);
            lvItems.View = View.Details;
            lvItems.FullRowSelect = true;
            lvItems.GridLines = true;
            lvItems.Font = new Font("Consolas", 9);

            lvItems.Columns.Add("S32", 100);
            lvItems.Columns.Add("本地X", 55);
            lvItems.Columns.Add("本地Y", 55);
            lvItems.Columns.Add("遊戲X", 60);
            lvItems.Columns.Add("遊戲Y", 60);
            lvItems.Columns.Add("Attr1(左上)", 90);
            lvItems.Columns.Add("區域1", 60);
            lvItems.Columns.Add("通行1", 70);
            lvItems.Columns.Add("Attr2(右上)", 95);
            lvItems.Columns.Add("區域2", 60);
            lvItems.Columns.Add("通行2", 70);

            // 使用 VirtualMode 處理大量資料
            lvItems.VirtualMode = true;
            lvItems.VirtualListSize = allItems.Count;
            lvItems.RetrieveVirtualItem += (s, args) =>
            {
                var item = allItems[args.ItemIndex];
                var lvi = new ListViewItem(item.fileName);
                lvi.SubItems.Add(item.localX.ToString());
                lvi.SubItems.Add(item.localY.ToString());
                lvi.SubItems.Add(item.globalX.ToString());
                lvi.SubItems.Add(item.globalY.ToString());
                lvi.SubItems.Add($"0x{item.attr1:X4}");
                lvi.SubItems.Add(item.region1);
                lvi.SubItems.Add(item.pass1);
                lvi.SubItems.Add($"0x{item.attr2:X4}");
                lvi.SubItems.Add(item.region2);
                lvi.SubItems.Add(item.pass2);
                lvi.Tag = item.filePath;
                args.Item = lvi;
            };

            // 標題排序 (VirtualMode)
            int sortColumn = -1;
            bool sortAsc = true;
            lvItems.ColumnClick += (s, args) =>
            {
                if (args.Column == sortColumn)
                    sortAsc = !sortAsc;
                else
                {
                    sortColumn = args.Column;
                    sortAsc = true;
                }

                allItems.Sort((a, b) =>
                {
                    int cmp = 0;
                    switch (sortColumn)
                    {
                        case 0: cmp = string.Compare(a.fileName, b.fileName); break;
                        case 1: cmp = a.localX.CompareTo(b.localX); break;
                        case 2: cmp = a.localY.CompareTo(b.localY); break;
                        case 3: cmp = a.globalX.CompareTo(b.globalX); break;
                        case 4: cmp = a.globalY.CompareTo(b.globalY); break;
                        case 5: cmp = a.attr1.CompareTo(b.attr1); break;
                        case 6: cmp = string.Compare(a.region1, b.region1); break;
                        case 7: cmp = string.Compare(a.pass1, b.pass1); break;
                        case 8: cmp = a.attr2.CompareTo(b.attr2); break;
                        case 9: cmp = string.Compare(a.region2, b.region2); break;
                        case 10: cmp = string.Compare(a.pass2, b.pass2); break;
                    }
                    return sortAsc ? cmp : -cmp;
                });
                lvItems.Invalidate();
            };

            // 雙擊跳轉 (VirtualMode 使用 SelectedIndices)
            lvItems.DoubleClick += (s, args) =>
            {
                if (lvItems.SelectedIndices.Count > 0)
                {
                    int idx = lvItems.SelectedIndices[0];
                    var item = allItems[idx];
                    // 使用全域遊戲座標跳轉
                    JumpToGameCoordinate(item.globalX, item.globalY);
                    this.toolStripStatusLabel1.Text = $"已跳轉到 本地({item.localX},{item.localY}) 遊戲座標({item.globalX},{item.globalY})";
                }
            };

            tabList.GetControls().Add(lvItems);
            tabControl.GetTabPages().Add(tabList);

            // Tab 2: 統計
            TabPage tabStats = new TabPage("統計");
            ListView lvStats = new ListView();
            lvStats.SetDock(DockStyle.Fill);
            lvStats.View = View.Details;
            lvStats.FullRowSelect = true;
            lvStats.GridLines = true;

            lvStats.Columns.Add("S32 檔案", 200);
            lvStats.Columns.Add("安全區", 80);
            lvStats.Columns.Add("戰鬥區", 80);
            lvStats.Columns.Add("不可通行", 80);
            lvStats.Columns.Add("總計", 80);

            lvStats.BeginUpdate();
            foreach (var stat in s32Stats)
            {
                var item = new ListViewItem(stat.fileName);
                item.SubItems.Add(stat.safeCount.ToString());
                item.SubItems.Add(stat.combatCount.ToString());
                item.SubItems.Add(stat.impassableCount.ToString());
                item.SubItems.Add(stat.totalNonZero.ToString());
                item.Tag = stat.filePath;
                lvStats.Items.Add(item);
            }
            lvStats.EndUpdate();

            int totalSafe = s32Stats.Sum(x => x.safeCount);
            int totalCombat = s32Stats.Sum(x => x.combatCount);
            int totalImpassable = s32Stats.Sum(x => x.impassableCount);

            Label lblSummary = new Label();
            lblSummary.Text = $"安全區: {totalSafe} | 戰鬥區: {totalCombat} | 不可通行: {totalImpassable}";
            lblSummary.SetDock(DockStyle.Bottom);
            lblSummary.Height = 25;

            tabStats.GetControls().Add(lvStats);
            tabStats.GetControls().Add(lblSummary);
            tabControl.GetTabPages().Add(tabStats);

            resultForm.GetControls().Add(tabControl);
            resultForm.Show(this); // 非模態視窗
        }

        // 查看與編輯第四層（物件）資料
        private void btnToolCheckL4_Click(object sender, EventArgs e)
        {
            if (_document.S32Files.Count == 0)
            {
                WinFormsMessageBox.Show("請先載入地圖", "提示", MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            // 收集所有 Layer4 資料
            List<(string filePath, string fileName, List<ObjectTile> items)> s32WithL4 =
                new List<(string, string, List<ObjectTile>)>();

            foreach (var kvp in _document.S32Files)
            {
                string filePath = kvp.Key;
                string fileName = Path.GetFileName(kvp.Key);
                S32Data s32Data = kvp.Value;

                if (s32Data.Layer4.Count > 0)
                {
                    s32WithL4.Add((filePath, fileName, s32Data.Layer4.ToList()));
                }
            }

            // 顯示結果
            Form resultForm = new Form();
            resultForm.Text = $"L4 檢查、編輯與清除 - {s32WithL4.Count} 個 S32 有資料";
            resultForm.Size = new Size(900, 650);
            resultForm.SetFormBorderStyle(FormBorderStyle.Sizable);
            resultForm.SetStartPosition(FormStartPosition.CenterParent);

            int totalItems = s32WithL4.Sum(x => x.items.Count);
            Label lblSummary = new Label();
            lblSummary.Text = $"共 {s32WithL4.Count} 個 S32 檔案有 Layer4（物件）資料，總計 {totalItems} 項。選取項目後可編輯或刪除：";
            lblSummary.SetLocation(new Point(10, 10));
            lblSummary.Size = new Size(860, 20);
            resultForm.GetControls().Add(lblSummary);

            // 使用 ListView 來顯示詳細資訊
            ListView lvItems = new ListView();
            lvItems.SetLocation(new Point(10, 35));
            lvItems.Size = new Size(860, 380);
            lvItems.Font = new Font("Consolas", 9);
            lvItems.View = View.Details;
            lvItems.FullRowSelect = true;
            lvItems.CheckBoxes = true;
            lvItems.Columns.Add("S32 檔案", 100);
            lvItems.Columns.Add("GroupId", 65);
            lvItems.Columns.Add("X", 50);
            lvItems.Columns.Add("Y", 50);
            lvItems.Columns.Add("Layer", 50);
            lvItems.Columns.Add("IndexId", 65);
            lvItems.Columns.Add("TileId", 65);

            List<(string filePath, ObjectTile item)> itemInfoList = new List<(string, ObjectTile)>();

            if (s32WithL4.Count == 0)
            {
                lvItems.Items.Add(new ListViewItem("沒有任何 S32 檔案有 Layer4 資料"));
                lvItems.Enabled = false;
            }
            else
            {
                foreach (var (filePath, fileName, items) in s32WithL4)
                {
                    foreach (var item in items)
                    {
                        ListViewItem lvi = new ListViewItem(fileName);
                        lvi.SubItems.Add(item.GroupId.ToString());
                        lvi.SubItems.Add(item.X.ToString());
                        lvi.SubItems.Add(item.Y.ToString());
                        lvi.SubItems.Add(item.Layer.ToString());
                        lvi.SubItems.Add(item.IndexId.ToString());
                        lvi.SubItems.Add(item.TileId.ToString());
                        lvi.Tag = (filePath, item);
                        lvItems.Items.Add(lvi);
                        itemInfoList.Add((filePath, item));
                    }
                }
            }
            resultForm.GetControls().Add(lvItems);

            // 編輯區域
            GroupBox gbEdit = new GroupBox();
            gbEdit.Text = "編輯選取的項目";
            gbEdit.SetLocation(new Point(10, 425));
            gbEdit.Size = new Size(860, 80);

            Label lblGroupId = new Label { Text = "GroupId:", Size = new Size(55, 20) };
            lblGroupId.SetLocation(new Point(10, 25));
            TextBox txtGroupId = new TextBox { Size = new Size(60, 23) };
            txtGroupId.SetLocation(new Point(70, 22));
            Label lblX = new Label { Text = "X:", Size = new Size(20, 20) };
            lblX.SetLocation(new Point(140, 25));
            TextBox txtX = new TextBox { Size = new Size(50, 23) };
            txtX.SetLocation(new Point(160, 22));
            Label lblY = new Label { Text = "Y:", Size = new Size(20, 20) };
            lblY.SetLocation(new Point(220, 25));
            TextBox txtY = new TextBox { Size = new Size(50, 23) };
            txtY.SetLocation(new Point(240, 22));
            Label lblLayer = new Label { Text = "Layer:", Size = new Size(40, 20) };
            lblLayer.SetLocation(new Point(300, 25));
            TextBox txtLayer = new TextBox { Size = new Size(50, 23) };
            txtLayer.SetLocation(new Point(345, 22));
            Label lblIndexId = new Label { Text = "IndexId:", Size = new Size(50, 20) };
            lblIndexId.SetLocation(new Point(405, 25));
            TextBox txtIndexId = new TextBox { Size = new Size(60, 23) };
            txtIndexId.SetLocation(new Point(460, 22));
            Label lblTileId = new Label { Text = "TileId:", Size = new Size(40, 20) };
            lblTileId.SetLocation(new Point(530, 25));
            TextBox txtTileId = new TextBox { Size = new Size(70, 23) };
            txtTileId.SetLocation(new Point(575, 22));

            Button btnApplyEdit = new Button();
            btnApplyEdit.Text = "套用修改";
            btnApplyEdit.SetLocation(new Point(660, 20));
            btnApplyEdit.Size = new Size(80, 28);
            btnApplyEdit.Click += (s, args) =>
            {
                if (lvItems.SelectedItems.Count != 1)
                {
                    WinFormsMessageBox.Show("請選取一個項目進行編輯", "提示", MessageBoxButtons.OK, MessageBoxIcon.Information);
                    return;
                }

                var lvi = lvItems.SelectedItems[0];
                var (filePath, item) = ((string, ObjectTile))lvi.Tag;

                if (!int.TryParse(txtGroupId.Text, out int newGroupId) ||
                    !int.TryParse(txtX.Text, out int newX) ||
                    !int.TryParse(txtY.Text, out int newY) ||
                    !int.TryParse(txtLayer.Text, out int newLayer) ||
                    !int.TryParse(txtIndexId.Text, out int newIndexId) ||
                    !int.TryParse(txtTileId.Text, out int newTileId))
                {
                    WinFormsMessageBox.Show("請輸入有效的數值", "錯誤", MessageBoxButtons.OK, MessageBoxIcon.Error);
                    return;
                }

                // 更新資料
                item.GroupId = newGroupId;
                item.X = newX;
                item.Y = newY;
                item.Layer = newLayer;
                item.IndexId = newIndexId;
                item.TileId = newTileId;

                // 更新 ListView 顯示
                lvi.SubItems[1].Text = item.GroupId.ToString();
                lvi.SubItems[2].Text = item.X.ToString();
                lvi.SubItems[3].Text = item.Y.ToString();
                lvi.SubItems[4].Text = item.Layer.ToString();
                lvi.SubItems[5].Text = item.IndexId.ToString();
                lvi.SubItems[6].Text = item.TileId.ToString();

                // 標記已修改
                if (_document.S32Files.TryGetValue(filePath, out S32Data s32Data))
                {
                    s32Data.IsModified = true;
                }

                WinFormsMessageBox.Show("已套用修改。請記得儲存 S32 檔案。", "完成", MessageBoxButtons.OK, MessageBoxIcon.Information);
            };

            // 新增項目按鈕
            Button btnAddNew = new Button();
            btnAddNew.Text = "新增";
            btnAddNew.SetLocation(new Point(760, 20));
            btnAddNew.Size = new Size(80, 28);
            btnAddNew.Click += (s, args) =>
            {
                // 選擇要新增到哪個 S32 檔案
                Form selectForm = new Form();
                selectForm.Text = "選擇 S32 檔案";
                selectForm.Size = new Size(400, 350);
                selectForm.SetFormBorderStyle(FormBorderStyle.FixedDialog);
                selectForm.SetStartPosition(FormStartPosition.CenterParent);
                selectForm.SetMaximizeBox(false);
                selectForm.SetMinimizeBox(false);

                Label lblSelect = new Label();
                lblSelect.Text = "選擇要新增 Layer4 項目的 S32 檔案：";
                lblSelect.SetLocation(new Point(10, 10));
                lblSelect.Size = new Size(360, 20);
                selectForm.GetControls().Add(lblSelect);

                ListBox lbS32Files = new ListBox();
                lbS32Files.SetLocation(new Point(10, 35));
                lbS32Files.Size = new Size(360, 220);
                foreach (var kvp in _document.S32Files)
                {
                    lbS32Files.Items.Add(Path.GetFileName(kvp.Key));
                }
                if (lbS32Files.Items.Count > 0)
                    lbS32Files.SelectedIndex = 0;
                selectForm.GetControls().Add(lbS32Files);

                Button btnOK = new Button();
                btnOK.Text = "確定";
                btnOK.SetLocation(new Point(100, 265));
                btnOK.Size = new Size(80, 30);
                btnOK.DialogResult = DialogResult.Ok;
                selectForm.GetControls().Add(btnOK);

                Button btnCancel = new Button();
                btnCancel.Text = "取消";
                btnCancel.SetLocation(new Point(200, 265));
                btnCancel.Size = new Size(80, 30);
                btnCancel.DialogResult = DialogResult.Cancel;
                selectForm.GetControls().Add(btnCancel);

                selectForm.AcceptButton = btnOK;
                selectForm.CancelButton = btnCancel;

                if (selectForm.ShowDialog(this) == DialogResult.Ok && lbS32Files.SelectedItem != null)
                {
                    string selectedFileName = lbS32Files.SelectedItem.ToString();
                    string selectedFilePath = _document.S32Files.Keys.FirstOrDefault(k => Path.GetFileName(k) == selectedFileName);

                    if (selectedFilePath != null && _document.S32Files.TryGetValue(selectedFilePath, out S32Data s32Data))
                    {
                        // 驗證輸入
                        if (!int.TryParse(txtGroupId.Text, out int newGroupId))
                            newGroupId = 0;
                        if (!int.TryParse(txtX.Text, out int newX))
                            newX = 0;
                        if (!int.TryParse(txtY.Text, out int newY))
                            newY = 0;
                        if (!int.TryParse(txtLayer.Text, out int newLayer))
                            newLayer = 0;
                        if (!int.TryParse(txtIndexId.Text, out int newIndexId))
                            newIndexId = 0;
                        if (!int.TryParse(txtTileId.Text, out int newTileId))
                            newTileId = 0;

                        // 建立新項目
                        ObjectTile newItem = new ObjectTile
                        {
                            GroupId = newGroupId,
                            X = newX,
                            Y = newY,
                            Layer = newLayer,
                            IndexId = newIndexId,
                            TileId = newTileId
                        };

                        // 加入 S32 資料
                        s32Data.Layer4.Add(newItem);
                        Layer4Index_Add(s32Data, newItem);
                        s32Data.IsModified = true;

                        // 更新 ListView
                        ListViewItem newLvi = new ListViewItem(selectedFileName);
                        newLvi.SubItems.Add(newItem.GroupId.ToString());
                        newLvi.SubItems.Add(newItem.X.ToString());
                        newLvi.SubItems.Add(newItem.Y.ToString());
                        newLvi.SubItems.Add(newItem.Layer.ToString());
                        newLvi.SubItems.Add(newItem.IndexId.ToString());
                        newLvi.SubItems.Add(newItem.TileId.ToString());
                        newLvi.Tag = (selectedFilePath, newItem);
                        lvItems.Items.Add(newLvi);
                        itemInfoList.Add((selectedFilePath, newItem));

                        // 選取新增的項目
                        newLvi.Selected = true;
                        newLvi.EnsureVisible();

                        WinFormsMessageBox.Show($"已新增 Layer4 項目到 {selectedFileName}。\n\n請記得儲存 S32 檔案。", "完成",
                            MessageBoxButtons.OK, MessageBoxIcon.Information);
                    }
                }
            };

            gbEdit.GetControls().Add(lblGroupId);
            gbEdit.GetControls().Add(txtGroupId);
            gbEdit.GetControls().Add(lblX);
            gbEdit.GetControls().Add(txtX);
            gbEdit.GetControls().Add(lblY);
            gbEdit.GetControls().Add(txtY);
            gbEdit.GetControls().Add(lblLayer);
            gbEdit.GetControls().Add(txtLayer);
            gbEdit.GetControls().Add(lblIndexId);
            gbEdit.GetControls().Add(txtIndexId);
            gbEdit.GetControls().Add(lblTileId);
            gbEdit.GetControls().Add(txtTileId);
            gbEdit.GetControls().Add(btnApplyEdit);
            gbEdit.GetControls().Add(btnAddNew);
            resultForm.GetControls().Add(gbEdit);

            // 選取項目時填入編輯區
            lvItems.SelectedIndexChanged += (s, args) =>
            {
                if (lvItems.SelectedItems.Count == 1)
                {
                    var lvi = lvItems.SelectedItems[0];
                    var (filePath, item) = ((string, ObjectTile))lvi.Tag;
                    txtGroupId.Text = item.GroupId.ToString();
                    txtX.Text = item.X.ToString();
                    txtY.Text = item.Y.ToString();
                    txtLayer.Text = item.Layer.ToString();
                    txtIndexId.Text = item.IndexId.ToString();
                    txtTileId.Text = item.TileId.ToString();
                }
            };

            Button btnSelectAll = new Button();
            btnSelectAll.Text = "全選";
            btnSelectAll.SetLocation(new Point(10, 515));
            btnSelectAll.Size = new Size(80, 30);
            btnSelectAll.Click += (s, args) =>
            {
                foreach (ListViewItem lvi in lvItems.Items)
                    lvi.Checked = true;
            };
            resultForm.GetControls().Add(btnSelectAll);

            Button btnDeselectAll = new Button();
            btnDeselectAll.Text = "取消全選";
            btnDeselectAll.SetLocation(new Point(100, 515));
            btnDeselectAll.Size = new Size(80, 30);
            btnDeselectAll.Click += (s, args) =>
            {
                foreach (ListViewItem lvi in lvItems.Items)
                    lvi.Checked = false;
            };
            resultForm.GetControls().Add(btnDeselectAll);

            Button btnClearSelected = new Button();
            btnClearSelected.Text = "刪除勾選項目";
            btnClearSelected.SetLocation(new Point(10, 555));
            btnClearSelected.Size = new Size(120, 35);
            btnClearSelected.BackgroundColor = WinFormsColors.LightCoral;
            btnClearSelected.Enabled = s32WithL4.Count > 0;
            btnClearSelected.Click += (s, args) =>
            {
                int checkedCount = lvItems.CheckedItems.Count;
                if (checkedCount == 0)
                {
                    WinFormsMessageBox.Show("請先勾選要刪除的項目", "提示", MessageBoxButtons.OK, MessageBoxIcon.Information);
                    return;
                }

                var confirmResult = WinFormsMessageBox.Show(
                    $"確定要刪除勾選的 {checkedCount} 個 Layer4 項目嗎？",
                    "確認刪除",
                    MessageBoxButtons.YesNo,
                    MessageBoxIcon.Warning);

                if (confirmResult != DialogResult.Yes) return;

                Dictionary<string, List<ObjectTile>> toRemove = new Dictionary<string, List<ObjectTile>>();
                foreach (ListViewItem lvi in lvItems.CheckedItems)
                {
                    var (filePath, item) = ((string, ObjectTile))lvi.Tag;
                    if (!toRemove.ContainsKey(filePath))
                        toRemove[filePath] = new List<ObjectTile>();
                    toRemove[filePath].Add(item);
                }

                int removedCount = 0;
                foreach (var kvp in toRemove)
                {
                    if (_document.S32Files.TryGetValue(kvp.Key, out S32Data s32Data))
                    {
                        foreach (var item in kvp.Value)
                        {
                            if (s32Data.Layer4.Remove(item))
                                removedCount++;
                        }
                        Layer4Index_RemoveRange(s32Data, kvp.Value);
                        s32Data.IsModified = true;
                    }
                }

                WinFormsMessageBox.Show($"已刪除 {removedCount} 個 Layer4 項目。\n\n請記得儲存 S32 檔案。", "完成",
                    MessageBoxButtons.OK, MessageBoxIcon.Information);

                resultForm.Close();
                RenderS32Map();
            };
            resultForm.GetControls().Add(btnClearSelected);

            Button btnClearAll = new Button();
            btnClearAll.Text = "刪除全部 L4";
            btnClearAll.SetLocation(new Point(140, 555));
            btnClearAll.Size = new Size(120, 35);
            btnClearAll.BackgroundColor = WinFormsColors.Salmon;
            btnClearAll.Enabled = s32WithL4.Count > 0;
            btnClearAll.Click += (s, args) =>
            {
                var confirmResult = WinFormsMessageBox.Show(
                    $"確定要刪除所有 {totalItems} 個 Layer4 項目嗎？",
                    "確認刪除全部",
                    MessageBoxButtons.YesNo,
                    MessageBoxIcon.Warning);

                if (confirmResult != DialogResult.Yes) return;

                int removedCount = 0;
                foreach (var (filePath, fileName, items) in s32WithL4)
                {
                    if (_document.S32Files.TryGetValue(filePath, out S32Data s32Data))
                    {
                        // 先更新空間索引（需要在 Clear 之前）
                        Layer4Index_RemoveRange(s32Data, s32Data.Layer4);
                        removedCount += s32Data.Layer4.Count;
                        s32Data.Layer4.Clear();
                        s32Data.IsModified = true;
                    }
                }

                WinFormsMessageBox.Show($"已刪除 {removedCount} 個 Layer4 項目。\n\n請記得儲存 S32 檔案。", "完成",
                    MessageBoxButtons.OK, MessageBoxIcon.Information);

                resultForm.Close();
                RenderS32Map();
            };
            resultForm.GetControls().Add(btnClearAll);

            Button btnClose = new Button();
            btnClose.Text = "關閉";
            btnClose.SetLocation(new Point(780, 555));
            btnClose.Size = new Size(90, 35);
            btnClose.Click += (s, args) => resultForm.Close();
            resultForm.GetControls().Add(btnClose);

            resultForm.Resize += (s, args) =>
            {
                int clientWidth = Math.Max(100, resultForm.ClientSize.Width);
                int clientHeight = Math.Max(300, resultForm.ClientSize.Height);
                lvItems.Size = new Size(Math.Max(10, clientWidth - 20), Math.Max(10, clientHeight - 230));
                gbEdit.SetLocation(new Point(10, Math.Max(10, clientHeight - 185)));
                gbEdit.Size = new Size(Math.Max(10, clientWidth - 20), 80);
                btnSelectAll.SetLocation(new Point(10, Math.Max(10, clientHeight - 95)));
                btnDeselectAll.SetLocation(new Point(100, Math.Max(10, clientHeight - 95)));
                btnClearSelected.SetLocation(new Point(10, Math.Max(10, clientHeight - 55)));
                btnClearAll.SetLocation(new Point(140, Math.Max(10, clientHeight - 55)));
                btnClose.SetLocation(new Point(Math.Max(10, clientWidth - 100), Math.Max(10, clientHeight - 55)));
            };

            resultForm.ShowDialog(this);
        }

        // 查看與管理第五層（透明圖塊）資料
        private void btnToolCheckL5_Click(object sender, EventArgs e)
        {
            if (_document.S32Files.Count == 0)
            {
                WinFormsMessageBox.Show("請先載入地圖", "提示", MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            // 收集有 Layer5 資料的 S32
            List<(string filePath, string fileName, int count, List<Layer5Item> items)> s32WithL5 =
                new List<(string, string, int, List<Layer5Item>)>();

            foreach (var kvp in _document.S32Files)
            {
                string filePath = kvp.Key;
                string fileName = Path.GetFileName(kvp.Key);
                S32Data s32Data = kvp.Value;

                if (s32Data.Layer5.Count > 0)
                {
                    s32WithL5.Add((filePath, fileName, s32Data.Layer5.Count, s32Data.Layer5.ToList()));
                }
            }

            // 顯示結果
            Form resultForm = new Form();
            resultForm.Text = $"L5 檢查與清除 - {s32WithL5.Count} 個 S32 有資料";
            resultForm.Size = new Size(700, 550);
            resultForm.SetFormBorderStyle(FormBorderStyle.Sizable);
            resultForm.SetStartPosition(FormStartPosition.CenterParent);

            int totalItems = s32WithL5.Sum(x => x.count);
            Label lblSummary = new Label();
            lblSummary.Text = $"共 {s32WithL5.Count} 個 S32 有 Layer5 資料，總計 {totalItems} 項。";

            // 搜尋區域
            Label lblSearch = new Label();
            lblSearch.Text = "搜尋:";

            TextBox txtSearchX = new TextBox();
            txtSearchX.Size = new Size(60, 22);
            txtSearchX.PlaceholderText = "X";

            TextBox txtSearchY = new TextBox();
            txtSearchY.Size = new Size(60, 22);
            txtSearchY.PlaceholderText = "Y";

            TextBox txtSearchObjIdx = new TextBox();
            txtSearchObjIdx.Size = new Size(70, 22);
            txtSearchObjIdx.PlaceholderText = "ObjIdx";

            Button btnSearch = new Button();
            btnSearch.Text = "搜尋";
            btnSearch.Size = new Size(50, 24);

            Button btnClearSearch = new Button();
            btnClearSearch.Text = "清除";
            btnClearSearch.Size = new Size(50, 24);

            Label lblSearchResult = new Label();
            lblSearchResult.Text = "";
            lblSearchResult.TextColor = Colors.Blue;

            CheckedListBox clbItems = new CheckedListBox();
            clbItems.Font = new Font("Consolas", 9);
            clbItems.CheckOnClick = true;

            List<(string filePath, int itemIndex, Layer5Item item)> itemInfoList =
                new List<(string, int, Layer5Item)>();
            List<(string filePath, int itemIndex, Layer5Item item, string fileName)> allItems =
                new List<(string, int, Layer5Item, string)>();

            // 建立完整項目列表
            foreach (var (filePath, fileName, count, items) in s32WithL5)
            {
                for (int i = 0; i < items.Count; i++)
                {
                    allItems.Add((filePath, i, items[i], fileName));
                }
            }

            // 顯示項目的方法
            Action<List<(string filePath, int itemIndex, Layer5Item item, string fileName)>> displayItems = (itemsToShow) =>
            {
                clbItems.BeginUpdate();
                clbItems.Items.Clear();
                itemInfoList.Clear();
                if (itemsToShow.Count == 0)
                {
                    clbItems.Items.Add("沒有符合條件的項目");
                    clbItems.Enabled = false;
                }
                else
                {
                    clbItems.Enabled = true;
                    foreach (var (filePath, itemIndex, item, fileName) in itemsToShow)
                    {
                        string displayText = $"[{fileName}] X={item.X}, Y={item.Y}, ObjIdx={item.ObjectIndex}, Type={item.Type}";
                        clbItems.Items.Add(displayText);
                        itemInfoList.Add((filePath, itemIndex, item));
                    }
                }
                clbItems.EndUpdate();
            };

            // 搜尋方法
            Action doSearch = () =>
            {
                string xText = txtSearchX.Text.Trim();
                string yText = txtSearchY.Text.Trim();
                string objIdxText = txtSearchObjIdx.Text.Trim();

                if (string.IsNullOrEmpty(xText) && string.IsNullOrEmpty(yText) && string.IsNullOrEmpty(objIdxText))
                {
                    displayItems(allItems);
                    lblSearchResult.Text = "";
                    return;
                }

                int? searchX = null, searchY = null;
                ushort? searchObjIdx = null;

                if (!string.IsNullOrEmpty(xText) && int.TryParse(xText, out int x)) searchX = x;
                if (!string.IsNullOrEmpty(yText) && int.TryParse(yText, out int y)) searchY = y;
                if (!string.IsNullOrEmpty(objIdxText) && ushort.TryParse(objIdxText, out ushort objIdx)) searchObjIdx = objIdx;

                var filtered = allItems.Where(a =>
                    (!searchX.HasValue || a.item.X == searchX.Value) &&
                    (!searchY.HasValue || a.item.Y == searchY.Value) &&
                    (!searchObjIdx.HasValue || a.item.ObjectIndex == searchObjIdx.Value)
                ).ToList();

                displayItems(filtered);

                var conditions = new List<string>();
                if (searchX.HasValue) conditions.Add($"X={searchX}");
                if (searchY.HasValue) conditions.Add($"Y={searchY}");
                if (searchObjIdx.HasValue) conditions.Add($"ObjIdx={searchObjIdx}");
                lblSearchResult.Text = $"找到 {filtered.Count} 個 ({string.Join(", ", conditions)})";
            };

            // 初始顯示全部
            if (s32WithL5.Count == 0)
            {
                clbItems.Items.Add("沒有任何 S32 檔案有 Layer5 資料");
                clbItems.Enabled = false;
            }
            else
            {
                displayItems(allItems);
            }

            // 搜尋事件
            btnSearch.Click += (s, args) => doSearch();

            // Enter 鍵搜尋
            EventHandler<KeyEventArgs> searchOnEnter = (s, args) =>
            {
                if (args.GetKeyCode() == Keys.Enter)
                {
                    doSearch();
                    args.SetSuppressKeyPress(true);
                }
            };
            txtSearchX.KeyDown += (s, args) => searchOnEnter(s, args);
            txtSearchY.KeyDown += (s, args) => searchOnEnter(s, args);
            txtSearchObjIdx.KeyDown += (s, args) => searchOnEnter(s, args);

            // 清除搜尋
            btnClearSearch.Click += (s, args) =>
            {
                txtSearchX.Text = "";
                txtSearchY.Text = "";
                txtSearchObjIdx.Text = "";
                displayItems(allItems);
                lblSearchResult.Text = "";
            };

            Button btnSelectAll = new Button();
            btnSelectAll.Text = "全選";
            btnSelectAll.Size = new Size(80, 30);
            btnSelectAll.Click += (s, args) =>
            {
                clbItems.BeginUpdate();
                for (int i = 0; i < clbItems.Items.Count; i++)
                    clbItems.SetItemChecked(i, true);
                clbItems.EndUpdate();
            };

            Button btnDeselectAll = new Button();
            btnDeselectAll.Text = "取消全選";
            btnDeselectAll.Size = new Size(80, 30);
            btnDeselectAll.Click += (s, args) =>
            {
                clbItems.BeginUpdate();
                for (int i = 0; i < clbItems.Items.Count; i++)
                    clbItems.SetItemChecked(i, false);
                clbItems.EndUpdate();
            };

            Button btnClearSelected = new Button();
            btnClearSelected.Text = "清除勾選項目";
            btnClearSelected.Size = new Size(120, 35);
            btnClearSelected.BackgroundColor = WinFormsColors.LightCoral;
            btnClearSelected.Enabled = s32WithL5.Count > 0;
            btnClearSelected.Click += (s, args) =>
            {
                if (clbItems.CheckedIndices.Count == 0)
                {
                    WinFormsMessageBox.Show("請先勾選要清除的項目", "提示", MessageBoxButtons.OK, MessageBoxIcon.Information);
                    return;
                }

                var confirmResult = WinFormsMessageBox.Show(
                    $"確定要清除勾選的 {clbItems.CheckedIndices.Count} 個 Layer5 項目嗎？",
                    "確認清除",
                    MessageBoxButtons.YesNo,
                    MessageBoxIcon.Warning);

                if (confirmResult != DialogResult.Yes) return;

                Dictionary<string, List<Layer5Item>> toRemove = new Dictionary<string, List<Layer5Item>>();
                foreach (int idx in clbItems.CheckedIndices)
                {
                    var info = itemInfoList[idx];
                    if (!toRemove.ContainsKey(info.filePath))
                        toRemove[info.filePath] = new List<Layer5Item>();
                    toRemove[info.filePath].Add(info.item);
                }

                int removedCount = 0;
                foreach (var kvp in toRemove)
                {
                    if (_document.S32Files.TryGetValue(kvp.Key, out S32Data s32Data))
                    {
                        foreach (var item in kvp.Value)
                        {
                            if (s32Data.Layer5.Remove(item))
                                removedCount++;
                        }
                        s32Data.IsModified = true;
                    }
                }

                WinFormsMessageBox.Show($"已清除 {removedCount} 個 Layer5 項目。\n\n請記得儲存 S32 檔案。", "完成",
                    MessageBoxButtons.OK, MessageBoxIcon.Information);

                UpdateMapValidateButton();
                resultForm.Close();
                RenderS32Map();
            };

            Button btnClearAll = new Button();
            btnClearAll.Text = "清除全部 L5";
            btnClearAll.Size = new Size(120, 35);
            btnClearAll.BackgroundColor = WinFormsColors.Salmon;
            btnClearAll.Enabled = s32WithL5.Count > 0;
            btnClearAll.Click += (s, args) =>
            {
                var confirmResult = WinFormsMessageBox.Show(
                    $"確定要清除所有 {totalItems} 個 Layer5 項目嗎？",
                    "確認清除全部",
                    MessageBoxButtons.YesNo,
                    MessageBoxIcon.Warning);

                if (confirmResult != DialogResult.Yes) return;

                int removedCount = 0;
                foreach (var (filePath, fileName, count, items) in s32WithL5)
                {
                    if (_document.S32Files.TryGetValue(filePath, out S32Data s32Data))
                    {
                        removedCount += s32Data.Layer5.Count;
                        s32Data.Layer5.Clear();
                        s32Data.IsModified = true;
                    }
                }

                WinFormsMessageBox.Show($"已清除 {removedCount} 個 Layer5 項目。\n\n請記得儲存 S32 檔案。", "完成",
                    MessageBoxButtons.OK, MessageBoxIcon.Information);

                UpdateMapValidateButton();
                resultForm.Close();
                RenderS32Map();
            };

            Button btnClose = new Button();
            btnClose.Text = "關閉";
            btnClose.Size = new Size(90, 35);
            btnClose.Click += (s, args) => resultForm.Close();

            // 頂部區域 (摘要 + 搜尋)
            var topPanel = new Eto.Forms.StackLayout
            {
                Orientation = Eto.Forms.Orientation.Vertical,
                Padding = new Eto.Drawing.Padding(10, 5),
                Spacing = 5,
                Items =
                {
                    lblSummary,
                    new Eto.Forms.StackLayout
                    {
                        Orientation = Eto.Forms.Orientation.Horizontal,
                        Spacing = 5,
                        Items = { lblSearch, txtSearchX, txtSearchY, txtSearchObjIdx, btnSearch, btnClearSearch, lblSearchResult }
                    }
                }
            };

            // 中間按鈕列 (全選/取消全選)
            var middleButtonPanel = new Eto.Forms.StackLayout
            {
                Orientation = Eto.Forms.Orientation.Horizontal,
                Padding = new Eto.Drawing.Padding(10, 5),
                Spacing = 10,
                Items = { btnSelectAll, btnDeselectAll }
            };

            // 底部按鈕列
            var bottomButtonPanel = new Eto.Forms.StackLayout
            {
                Orientation = Eto.Forms.Orientation.Horizontal,
                Padding = new Eto.Drawing.Padding(10, 10),
                Spacing = 10,
                Items = { btnClearSelected, btnClearAll, new Eto.Forms.StackLayoutItem(null, true), btnClose }
            };

            // 使用 TableLayout 安排整體佈局
            var layout = new Eto.Forms.TableLayout
            {
                Rows =
                {
                    new Eto.Forms.TableRow(topPanel),
                    new Eto.Forms.TableRow(clbItems) { ScaleHeight = true },
                    new Eto.Forms.TableRow(middleButtonPanel),
                    new Eto.Forms.TableRow(bottomButtonPanel)
                }
            };
            resultForm.Content = layout;

            resultForm.Show();
        }

        // 檢查 Layer5 異常並更新按鈕顯示狀態（異步版本，不阻塞 UI）
        private void UpdateMapValidateButton()
        {
            // 先隱藏按鈕，背景檢查完成後再更新
            btnMapValidate.Visible = false;

            Task.Run(() =>
            {
                var totalSw = Stopwatch.StartNew();

                var sw1 = Stopwatch.StartNew();
                var invalidL5Items = GetInvalidLayer5Items();
                sw1.Stop();

                var sw2 = Stopwatch.StartNew();
                var invalidTileItems = GetInvalidTileIds();
                sw2.Stop();

                var sw3 = Stopwatch.StartNew();
                var layer8ExtendedS32 = GetLayer8ExtendedS32Files();
                sw3.Stop();

                var sw4 = Stopwatch.StartNew();
                var (overLimitTileIds, tileLimit, maxTileId) = GetAllOverLimitTileIds();
                sw4.Stop();

                var sw5 = Stopwatch.StartNew();
                var invalidL5TypeItems = GetInvalidLayer5TypeItems();
                sw5.Stop();

                totalSw.Stop();

                int totalInvalid = invalidL5Items.Count + invalidTileItems.Count + layer8ExtendedS32.Count + overLimitTileIds.Count + invalidL5TypeItems.Count;
                Console.WriteLine($"[MapValidate] Total: {totalSw.ElapsedMilliseconds}ms | L5Check: {sw1.ElapsedMilliseconds}ms ({invalidL5Items.Count}) | TileValidate: {sw2.ElapsedMilliseconds}ms ({invalidTileItems.Count}) | L8Ext: {sw3.ElapsedMilliseconds}ms ({layer8ExtendedS32.Count}) | OverLimit: {sw4.ElapsedMilliseconds}ms ({overLimitTileIds.Count}) | L5Type: {sw5.ElapsedMilliseconds}ms ({invalidL5TypeItems.Count})");

                // 回到 UI 執行緒更新按鈕
                this.BeginInvoke((MethodInvoker)delegate
                {
                    btnMapValidate.Visible = totalInvalid > 0;
                    if (totalInvalid > 0)
                    {
                        var tooltipParts = new List<string>();
                        if (invalidL5Items.Count > 0)
                            tooltipParts.Add($"Layer5異常: {invalidL5Items.Count}");
                        if (invalidTileItems.Count > 0)
                            tooltipParts.Add($"無效TileId: {invalidTileItems.Count}");
                        if (layer8ExtendedS32.Count > 0)
                            tooltipParts.Add($"L8擴展: {layer8ExtendedS32.Count}");
                        if (overLimitTileIds.Count > 0)
                            tooltipParts.Add($"Tile超上限: {overLimitTileIds.Count}");
                        if (invalidL5TypeItems.Count > 0)
                            tooltipParts.Add($"L5無效Type: {invalidL5TypeItems.Count}");
                        toolTip1.SetToolTip(btnMapValidate, $"發現異常: {string.Join(", ", tooltipParts)}");
                    }
                });
            });
        }

        // 取得使用 Layer8 擴展格式的 S32 檔案
        private List<(string filePath, string fileName, int layer8Count)> GetLayer8ExtendedS32Files()
        {
            var result = new List<(string filePath, string fileName, int layer8Count)>();

            if (_document.S32Files.Count == 0)
                return result;

            foreach (var kvp in _document.S32Files)
            {
                if (kvp.Value.Layer8HasExtendedData)
                {
                    result.Add((kvp.Key, Path.GetFileName(kvp.Key), kvp.Value.Layer8.Count));
                }
            }

            return result;
        }

        // 取得 Layer5 中 ObjectIndex 不存在於 Layer4 GroupId 的項目
        // 或雖然存在但該格找不到對應 GroupId 的物件
        private List<(string filePath, string fileName, Layer5Item item, int itemIndex, string reason)> GetInvalidLayer5Items()
        {
            if (_document.S32Files.Count == 0)
                return new List<(string filePath, string fileName, Layer5Item item, int itemIndex, string reason)>();

            // 取得目前 viewport 範圍
            var viewportRect = _viewState.GetViewportWorldRect();

            // 過濾出 viewport 內的 S32 檔案
            var viewportS32Files = new Dictionary<string, S32Data>();
            foreach (var kvp in _document.S32Files)
            {
                S32Data s32Data = kvp.Value;

                // 檢查 S32 是否在 viewport 內
                int[] loc = s32Data.SegInfo.GetLoc(1.0);
                int blockWidth = 64 * 24 * 2;  // 3072
                int blockHeight = 64 * 12 * 2; // 1536
                Rectangle blockRect = new Rectangle(loc[0], loc[1], blockWidth, blockHeight);
                if (blockRect.IntersectsWith(viewportRect))
                {
                    viewportS32Files[kvp.Key] = s32Data;
                }
            }

            // 使用共用的 Layer5Checker 檢查（radius=0 表示只檢查該格）
            var results = Layer5Checker.Check(
                viewportS32Files,
                radius: -1,
                getSegInfo: s32 => (s32.SegInfo.nLinBeginX, s32.SegInfo.nLinBeginY));

            // 轉換為舊格式
            return results.Select(r => (r.FilePath, r.FileName, r.Item, r.ItemIndex, r.Reason)).ToList();
        }

        // 取得 Layer5 中 Type 不是 0 或 1 的項目
        private List<(string filePath, string fileName, Layer5Item item, int itemIndex)> GetInvalidLayer5TypeItems()
        {
            var result = new List<(string filePath, string fileName, Layer5Item item, int itemIndex)>();

            if (_document.S32Files.Count == 0)
                return result;

            foreach (var kvp in _document.S32Files)
            {
                string filePath = kvp.Key;
                string fileName = Path.GetFileName(filePath);
                S32Data s32Data = kvp.Value;

                for (int i = 0; i < s32Data.Layer5.Count; i++)
                {
                    var item = s32Data.Layer5[i];
                    // Type 只能是 0 (半透明) 或 1 (消失)
                    if (item.Type != 0 && item.Type != 1)
                    {
                        result.Add((filePath, fileName, item, i));
                    }
                }
            }

            return result;
        }

        /// <summary>
        /// 檢查指定的 S32 檔案是否有異常（Layer5、無效TileId、Layer8擴展、Tile超上限），如果有則提示用戶確認
        /// </summary>
        /// <param name="s32Files">要檢查的 S32 檔案字典</param>
        /// <param name="operationName">操作名稱（用於顯示訊息）</param>
        /// <param name="checkTileLimit">是否檢查 Tile 超過上限（匯出時不需要）</param>
        /// <param name="checkLayer8Extended">是否檢查 Layer8 擴展格式（若會移除則不需要）</param>
        /// <returns>true = 繼續操作, false = 取消操作</returns>
        private bool CheckLayer5IssuesAndConfirm(Dictionary<string, S32Data> s32Files, string operationName, bool checkTileLimit = true, bool checkLayer8Extended = true)
        {
            if (s32Files == null || s32Files.Count == 0)
                return true;

            try
            {
                // 過濾掉 SegInfo 為 null 的項目
                var validS32Files = s32Files.Where(kvp => kvp.Value?.SegInfo != null)
                    .ToDictionary(kvp => kvp.Key, kvp => kvp.Value);

                if (validS32Files.Count == 0)
                    return true;

                var msgParts = new List<string>();
                int totalIssues = 0;

                // 1. Layer5 檢查
                var l5Results = Layer5Checker.Check(
                    validS32Files,
                    radius: -1,
                    getSegInfo: s32 => (s32.SegInfo.nLinBeginX, s32.SegInfo.nLinBeginY));
                if (l5Results.Count > 0)
                {
                    int noGroupCount = l5Results.Count(r => r.Reason == "GroupId不存在");
                    int noObjCount = l5Results.Count(r => r.Reason == "周圍無對應物件");
                    var l5Parts = new List<string>();
                    if (noGroupCount > 0) l5Parts.Add($"GroupId不存在:{noGroupCount}");
                    if (noObjCount > 0) l5Parts.Add($"周圍無物件:{noObjCount}");
                    msgParts.Add($"• {l5Results.Count} 個 Layer5 異常 ({string.Join(", ", l5Parts)})");
                    totalIssues += l5Results.Count;
                }

                // 2. 無效 TileId 檢查
                var invalidTiles = CheckInvalidTileIds(validS32Files);
                if (invalidTiles.Count > 0)
                {
                    int l1Count = invalidTiles.Count(t => t.layer == "Layer1");
                    int l2Count = invalidTiles.Count(t => t.layer == "Layer2");
                    int l4Count = invalidTiles.Count(t => t.layer == "Layer4");
                    var tileParts = new List<string>();
                    if (l1Count > 0) tileParts.Add($"L1:{l1Count}");
                    if (l2Count > 0) tileParts.Add($"L2:{l2Count}");
                    if (l4Count > 0) tileParts.Add($"L4:{l4Count}");
                    msgParts.Add($"• {invalidTiles.Count} 個無效的 TileId ({string.Join(", ", tileParts)})");
                    totalIssues += invalidTiles.Count;
                }

                // 3. Layer8 擴展格式檢查（若會移除則不需要檢查）
                if (checkLayer8Extended)
                {
                    var l8Extended = validS32Files.Where(kvp => kvp.Value.Layer8HasExtendedData).ToList();
                    if (l8Extended.Count > 0)
                    {
                        int totalL8Items = l8Extended.Sum(kvp => kvp.Value.Layer8.Count);
                        msgParts.Add($"• {l8Extended.Count} 個 S32 使用 Layer8 擴展格式（共 {totalL8Items} 個項目，可能導致閃退）");
                        totalIssues += l8Extended.Count;
                    }
                }

                // 4. Tile 超過上限檢查（匯出時不需要）
                if (checkTileLimit)
                {
                    var (overLimitTiles, tileLimit, maxTileId) = CheckOverLimitTileIds(validS32Files);
                    if (overLimitTiles.Count > 0)
                    {
                        msgParts.Add($"• {overLimitTiles.Count} 個 Tile 超過上限 (上限={tileLimit}, 最大={maxTileId})，將無法顯示或導致閃退");
                        totalIssues += overLimitTiles.Count;
                    }
                }

                if (totalIssues == 0)
                    return true;

                string message = $"發現以下異常：\n\n{string.Join("\n", msgParts)}\n\n" +
                                 $"這些異常可能導致遊戲中出現問題。\n是否仍要繼續{operationName}？";

                var result = WinFormsMessageBox.Show(message, "異常檢查警告",
                    MessageBoxButtons.YesNo, MessageBoxIcon.Warning);

                return result == DialogResult.Yes;
            }
            catch (Exception ex)
            {
                Console.WriteLine($"[CheckIssues] Error: {ex}");
                var result = WinFormsMessageBox.Show($"異常檢查時發生錯誤：\n{ex.Message}\n\n{ex.StackTrace}\n\n是否仍要繼續{operationName}？",
                    "檢查錯誤", MessageBoxButtons.YesNo, MessageBoxIcon.Warning);
                return result == DialogResult.Yes;
            }
        }

        /// <summary>
        /// 檢查指定 S32 檔案中的無效 TileId
        /// </summary>
        private List<(string filePath, string layer, int tileId)> CheckInvalidTileIds(Dictionary<string, S32Data> s32Files)
        {
            var invalidTiles = new List<(string filePath, string layer, int tileId)>();

            // 建立可用 TileId 的 HashSet
            var availableTileIds = new HashSet<int>();
            L1PakReader.UnPack("Tile", "1.til");  // 觸發載入
            if (Share.IdxDataList.TryGetValue("Tile", out var tileIdx))
            {
                foreach (var key in tileIdx.Keys)
                {
                    string name = Path.GetFileNameWithoutExtension(key);
                    if (int.TryParse(name, out int tileId))
                        availableTileIds.Add(tileId);
                }
            }

            if (availableTileIds.Count == 0)
                return invalidTiles;

            foreach (var kvp in s32Files)
            {
                var s32Data = kvp.Value;

                // Layer1
                for (int y = 0; y < 64; y++)
                {
                    for (int x = 0; x < 128; x++)
                    {
                        var cell = s32Data.Layer1[y, x];
                        if (cell != null && cell.TileId > 0 && !availableTileIds.Contains(cell.TileId))
                            invalidTiles.Add((kvp.Key, "Layer1", cell.TileId));
                    }
                }

                // Layer2
                foreach (var item in s32Data.Layer2)
                {
                    if (item.TileId > 0 && !availableTileIds.Contains(item.TileId))
                        invalidTiles.Add((kvp.Key, "Layer2", item.TileId));
                }

                // Layer4
                foreach (var obj in s32Data.Layer4)
                {
                    if (obj.TileId > 0 && !availableTileIds.Contains(obj.TileId))
                        invalidTiles.Add((kvp.Key, "Layer4", obj.TileId));
                }
            }

            return invalidTiles;
        }

        /// <summary>
        /// 檢查指定 S32 檔案中超過上限的 TileId
        /// </summary>
        private (List<int> overLimitTileIds, int tileLimit, int maxTileId) CheckOverLimitTileIds(Dictionary<string, S32Data> s32Files)
        {
            var overLimitIds = new HashSet<int>();
            int maxId = 0;

            int tileLimit = TileHashManager.GetTileLimit();
            if (tileLimit <= 0)
                return (new List<int>(), tileLimit, maxId);

            foreach (var kvp in s32Files)
            {
                var s32Data = kvp.Value;

                // Layer1
                for (int y = 0; y < 64; y++)
                {
                    for (int x = 0; x < 128; x++)
                    {
                        var cell = s32Data.Layer1[y, x];
                        if (cell != null && cell.TileId > 0)
                        {
                            if (cell.TileId > maxId) maxId = cell.TileId;
                            if (cell.TileId > tileLimit) overLimitIds.Add(cell.TileId);
                        }
                    }
                }

                // Layer2
                foreach (var item in s32Data.Layer2)
                {
                    if (item.TileId > 0)
                    {
                        if (item.TileId > maxId) maxId = item.TileId;
                        if (item.TileId > tileLimit) overLimitIds.Add(item.TileId);
                    }
                }

                // Layer4
                foreach (var obj in s32Data.Layer4)
                {
                    if (obj.TileId > 0)
                    {
                        if (obj.TileId > maxId) maxId = obj.TileId;
                        if (obj.TileId > tileLimit) overLimitIds.Add(obj.TileId);
                    }
                }
            }

            return (overLimitIds.ToList(), tileLimit, maxId);
        }

        // 無效 TileId 資訊類別
        private class InvalidTileInfo
        {
            public string FilePath { get; set; } = string.Empty;
            public string FileName { get; set; } = string.Empty;
            public string Layer { get; set; } = string.Empty;  // "Layer1", "Layer2", "Layer4"
            public int X { get; set; }
            public int Y { get; set; }
            public int TileId { get; set; }
            public int IndexId { get; set; }
            public string Reason { get; set; } = string.Empty;  // "Til檔案不存在" 或 "IndexId超出範圍"
        }

        // 取得無效的 TileId（Layer1, Layer2, Layer4）- Fast mode 使用索引查詢
        private List<InvalidTileInfo> GetInvalidTileIds()
        {
            var invalidTiles = new List<InvalidTileInfo>();

            if (_document.S32Files.Count == 0)
                return invalidTiles;

            // Fast mode: 從 Tile 索引建立可用 TileId 的 HashSet
            var availableTileIds = new HashSet<int>();

            // 觸發載入 Tile 索引（如果尚未載入）
            L1PakReader.UnPack("Tile", "1.til");

            if (Share.IdxDataList.TryGetValue("Tile", out var tileIdx))
            {
                foreach (var key in tileIdx.Keys)
                {
                    // key 格式是 "123.til"
                    if (key.EndsWith(".til"))
                    {
                        string numStr = key.Substring(0, key.Length - 4);
                        if (int.TryParse(numStr, out int tileId))
                        {
                            availableTileIds.Add(tileId);
                        }
                    }
                }
            }

            // 檢查 TileId 是否存在於索引中
            bool CheckTileValid(int tileId, out string reason)
            {
                reason = string.Empty;
                if (tileId <= 0) return true;  // TileId = 0 表示空格子，不算無效

                if (!availableTileIds.Contains(tileId))
                {
                    reason = "Til檔案不存在";
                    return false;
                }

                return true;
            }

            foreach (var kvp in _document.S32Files)
            {
                string filePath = kvp.Key;
                string fileName = Path.GetFileName(kvp.Key);
                S32Data s32Data = kvp.Value;

                // 檢查 Layer1（地板）
                for (int y = 0; y < 64; y++)
                {
                    for (int x = 0; x < 128; x++)
                    {
                        var cell = s32Data.Layer1[y, x];
                        if (cell != null && cell.TileId > 0)
                        {
                            if (!CheckTileValid(cell.TileId, out string reason))
                            {
                                invalidTiles.Add(new InvalidTileInfo
                                {
                                    FilePath = filePath,
                                    FileName = fileName,
                                    Layer = "Layer1",
                                    X = x,
                                    Y = y,
                                    TileId = cell.TileId,
                                    IndexId = cell.IndexId,
                                    Reason = reason
                                });
                            }
                        }
                    }
                }

                // 檢查 Layer2
                for (int i = 0; i < s32Data.Layer2.Count; i++)
                {
                    var item = s32Data.Layer2[i];
                    if (item.TileId > 0)
                    {
                        if (!CheckTileValid(item.TileId, out string reason))
                        {
                            invalidTiles.Add(new InvalidTileInfo
                            {
                                FilePath = filePath,
                                FileName = fileName,
                                Layer = "Layer2",
                                X = item.X,
                                Y = item.Y,
                                TileId = item.TileId,
                                IndexId = item.IndexId,
                                Reason = reason
                            });
                        }
                    }
                }

                // 檢查 Layer4（物件）
                for (int i = 0; i < s32Data.Layer4.Count; i++)
                {
                    var obj = s32Data.Layer4[i];
                    if (obj.TileId > 0)
                    {
                        if (!CheckTileValid(obj.TileId, out string reason))
                        {
                            invalidTiles.Add(new InvalidTileInfo
                            {
                                FilePath = filePath,
                                FileName = fileName,
                                Layer = "Layer4",
                                X = obj.X,
                                Y = obj.Y,
                                TileId = obj.TileId,
                                IndexId = obj.IndexId,
                                Reason = reason
                            });
                        }
                    }
                }
            }

            return invalidTiles;
        }

        // 取得 Tile.idx 中超過 list.til 上限的所有 TileId
        private (List<int> overLimitTileIds, int tileLimit, int maxTileId) GetAllOverLimitTileIds()
        {
            var overLimitIds = new List<int>();
            int maxId = 0;

            // 取得 list.til 上限
            int tileLimit = TileHashManager.GetTileLimit();
            if (tileLimit <= 0)
                return (overLimitIds, tileLimit, maxId);  // 無法讀取上限，不檢查

            // 取得所有 Tile 索引
            var tileIdx = L1IdxReader.GetAll("Tile");
            if (tileIdx == null || tileIdx.Count == 0)
                return (overLimitIds, tileLimit, maxId);

            foreach (var key in tileIdx.Keys)
            {
                // key 格式是 "123.til"
                if (key.EndsWith(".til") && key != "list.til")
                {
                    string numStr = key.Substring(0, key.Length - 4);
                    if (int.TryParse(numStr, out int tileId))
                    {
                        if (tileId > maxId) maxId = tileId;
                        if (tileId > tileLimit)
                        {
                            overLimitIds.Add(tileId);
                        }
                    }
                }
            }

            overLimitIds.Sort();
            return (overLimitIds, tileLimit, maxId);
        }

        // 檢查 Layer5 異常和無效 TileId
        private void btnMapValidate_Click(object sender, EventArgs e)
        {
            var invalidL5Items = GetInvalidLayer5Items();
            var invalidTileItems = GetInvalidTileIds();
            var layer8ExtendedS32 = GetLayer8ExtendedS32Files();
            var (overLimitTileIds, tileLimit, maxTileId) = GetAllOverLimitTileIds();
            var invalidL5TypeItems = GetInvalidLayer5TypeItems();

            if (invalidL5Items.Count == 0 && invalidTileItems.Count == 0 && layer8ExtendedS32.Count == 0 && overLimitTileIds.Count == 0 && invalidL5TypeItems.Count == 0)
            {
                WinFormsMessageBox.Show("檢查完成，沒有發現任何異常。",
                    "檢查完成", MessageBoxButtons.OK, MessageBoxIcon.Information);
                btnMapValidate.Visible = false;
                return;
            }

            // 建立訊息
            var msgParts = new List<string>();
            if (invalidL5Items.Count > 0)
            {
                int noGroupCount = invalidL5Items.Count(x => x.reason == "GroupId不存在");
                int noObjCount = invalidL5Items.Count(x => x.reason == "周圍無對應物件");
                var l5Parts = new List<string>();
                if (noGroupCount > 0) l5Parts.Add($"GroupId不存在:{noGroupCount}");
                if (noObjCount > 0) l5Parts.Add($"周圍無物件:{noObjCount}");
                msgParts.Add($"• {invalidL5Items.Count} 個 Layer5 異常 ({string.Join(", ", l5Parts)})");
            }
            if (invalidTileItems.Count > 0)
            {
                // 統計各層的無效 TileId 數量
                int l1Count = invalidTileItems.Count(t => t.Layer == "Layer1");
                int l2Count = invalidTileItems.Count(t => t.Layer == "Layer2");
                int l4Count = invalidTileItems.Count(t => t.Layer == "Layer4");
                var tileParts = new List<string>();
                if (l1Count > 0) tileParts.Add($"L1:{l1Count}");
                if (l2Count > 0) tileParts.Add($"L2:{l2Count}");
                if (l4Count > 0) tileParts.Add($"L4:{l4Count}");
                msgParts.Add($"• {invalidTileItems.Count} 個無效的 TileId ({string.Join(", ", tileParts)})");
            }
            if (layer8ExtendedS32.Count > 0)
            {
                int totalL8Items = layer8ExtendedS32.Sum(x => x.layer8Count);
                msgParts.Add(string.Format(LocalizationManager.L("AbnormalCheck_Layer8Extended"), layer8ExtendedS32.Count, totalL8Items));
            }
            if (overLimitTileIds.Count > 0)
            {
                msgParts.Add(string.Format(LocalizationManager.L("AbnormalCheck_TileOverLimit"), overLimitTileIds.Count, tileLimit, maxTileId));
            }
            if (invalidL5TypeItems.Count > 0)
            {
                // 統計各 Type 值的數量
                var typeCounts = invalidL5TypeItems.GroupBy(x => x.item.Type)
                    .OrderBy(g => g.Key)
                    .Select(g => $"Type={g.Key}:{g.Count()}");
                msgParts.Add($"• {invalidL5TypeItems.Count} 個 L5 無效 Type ({string.Join(", ", typeCounts)})");
            }

            // 顯示確認對話框
            string message = $"{LocalizationManager.L("AbnormalCheck_FoundIssues")}\n\n{string.Join("\n", msgParts)}\n\n{LocalizationManager.L("AbnormalCheck_ViewDetails")}";
            var confirmResult = WinFormsMessageBox.Show(message, LocalizationManager.L("AbnormalCheck_Title"),
                MessageBoxButtons.YesNo, MessageBoxIcon.Warning);

            if (confirmResult != DialogResult.Yes)
                return;

            // 顯示清單讓使用者選擇要清除的項目
            Form resultForm = new Form();
            resultForm.Text = LocalizationManager.L("AbnormalCheck_Title");
            resultForm.Size = new Size(850, 600);
            resultForm.SetFormBorderStyle(FormBorderStyle.Sizable);
            resultForm.SetStartPosition(FormStartPosition.CenterParent);

            // 使用 TabControl 分頁顯示
            TabControl tabControl = new TabControl();
            tabControl.SetLocation(new Point(10, 10));
            // 使用固定初始大小，Anchor 會在 Form 顯示後自動調整
            tabControl.Size = new Size(820, 530);
            tabControl.SetAnchor(AnchorStyles.Top | AnchorStyles.Bottom | AnchorStyles.Left | AnchorStyles.Right);
            resultForm.GetControls().Add(tabControl);

            // ===== Tab 1: Layer5 異常 =====
            if (invalidL5Items.Count > 0)
            {
                TabPage tabL5 = new TabPage(string.Format(LocalizationManager.L("AbnormalCheck_Tab_Layer5"), invalidL5Items.Count));
                tabControl.GetTabPages().Add(tabL5);

                Label lblL5Summary = new Label();
                lblL5Summary.Text = string.Format(LocalizationManager.L("AbnormalCheck_Layer5Summary"), invalidL5Items.Count);
                lblL5Summary.SetLocation(new Point(5, 5));
                lblL5Summary.Size = new Size(tabL5.ClientSize.Width - 10, 20);
                lblL5Summary.SetAnchor(AnchorStyles.Top | AnchorStyles.Left | AnchorStyles.Right);
                tabL5.GetControls().Add(lblL5Summary);

                CheckedListBox clbL5Items = new CheckedListBox();
                clbL5Items.SetLocation(new Point(5, 30));
                clbL5Items.Size = new Size(tabL5.ClientSize.Width - 10, tabL5.ClientSize.Height - 110);
                clbL5Items.Font = new Font("Consolas", 9);
                clbL5Items.CheckOnClick = true;
                clbL5Items.SetAnchor(AnchorStyles.Top | AnchorStyles.Bottom | AnchorStyles.Left | AnchorStyles.Right);

                foreach (var (filePath, fileName, item, itemIndex, reason) in invalidL5Items)
                {
                    string displayText = $"[{fileName}] X={item.X}, Y={item.Y}, ObjIdx={item.ObjectIndex}, Type={item.Type} [{reason}]";
                    clbL5Items.Items.Add(displayText);
                }
                tabL5.GetControls().Add(clbL5Items);

                // 按鈕面板
                Panel pnlL5Buttons = new Panel();
                pnlL5Buttons.SetLocation(new Point(5, tabL5.ClientSize.Height - 75));
                pnlL5Buttons.Size = new Size(tabL5.ClientSize.Width - 10, 70);
                pnlL5Buttons.SetAnchor(AnchorStyles.Bottom | AnchorStyles.Left | AnchorStyles.Right);
                tabL5.GetControls().Add(pnlL5Buttons);

                Button btnL5SelectAll = new Button { Text = LocalizationManager.L("Button_SelectAll"), Location = new Point(0, 0), Size = new Size(80, 30) };
                btnL5SelectAll.Click += (s, args) => { for (int i = 0; i < clbL5Items.Items.Count; i++) clbL5Items.SetItemChecked(i, true); };
                pnlL5Buttons.GetControls().Add(btnL5SelectAll);

                Button btnL5DeselectAll = new Button { Text = LocalizationManager.L("AbnormalCheck_DeselectAll"), Location = new Point(90, 0), Size = new Size(80, 30) };
                btnL5DeselectAll.Click += (s, args) => { for (int i = 0; i < clbL5Items.Items.Count; i++) clbL5Items.SetItemChecked(i, false); };
                pnlL5Buttons.GetControls().Add(btnL5DeselectAll);

                Button btnL5ClearSelected = new Button { Text = LocalizationManager.L("AbnormalCheck_ClearSelected"), Location = new Point(0, 35), Size = new Size(100, 30), BackColor = WinFormsColors.LightCoral };
                btnL5ClearSelected.Click += (s, args) =>
                {
                    if (clbL5Items.CheckedIndices.Count == 0) { WinFormsMessageBox.Show(LocalizationManager.L("AbnormalCheck_PleaseSelectItems"), LocalizationManager.L("AbnormalCheck_Notice")); return; }
                    if (WinFormsMessageBox.Show(string.Format(LocalizationManager.L("AbnormalCheck_ConfirmClearSelected"), clbL5Items.CheckedIndices.Count), LocalizationManager.L("AbnormalCheck_ConfirmDelete"), MessageBoxButtons.YesNo, MessageBoxIcon.Warning) != DialogResult.Yes) return;

                    var toDelete = new Dictionary<string, List<Layer5Item>>();
                    foreach (int idx in clbL5Items.CheckedIndices)
                    {
                        var (filePath, _, item, _, _) = invalidL5Items[idx];
                        if (!toDelete.ContainsKey(filePath)) toDelete[filePath] = new List<Layer5Item>();
                        toDelete[filePath].Add(item);
                    }
                    int deletedCount = 0;
                    foreach (var kvp in toDelete)
                    {
                        if (_document.S32Files.TryGetValue(kvp.Key, out var s32Data))
                        {
                            foreach (var item in kvp.Value) { s32Data.Layer5.Remove(item); deletedCount++; }
                            s32Data.IsModified = true;
                        }
                    }
                    WinFormsMessageBox.Show(string.Format(LocalizationManager.L("AbnormalCheck_ClearedLayer5"), deletedCount), LocalizationManager.L("AbnormalCheck_ClearComplete"));
                    ClearS32BlockCache(); resultForm.Close(); RenderS32Map();
                };
                pnlL5Buttons.GetControls().Add(btnL5ClearSelected);

                Button btnL5ClearAll = new Button { Text = LocalizationManager.L("AbnormalCheck_ClearAll"), Location = new Point(110, 35), Size = new Size(100, 30), BackColor = WinFormsColors.Salmon };
                btnL5ClearAll.Click += (s, args) =>
                {
                    if (WinFormsMessageBox.Show(string.Format(LocalizationManager.L("AbnormalCheck_ConfirmClearAll"), invalidL5Items.Count), LocalizationManager.L("AbnormalCheck_ConfirmDeleteAll"), MessageBoxButtons.YesNo, MessageBoxIcon.Warning) != DialogResult.Yes) return;
                    var toDelete = new Dictionary<string, List<Layer5Item>>();
                    foreach (var (filePath, _, item, _, _) in invalidL5Items)
                    {
                        if (!toDelete.ContainsKey(filePath)) toDelete[filePath] = new List<Layer5Item>();
                        toDelete[filePath].Add(item);
                    }
                    int deletedCount = 0;
                    foreach (var kvp in toDelete)
                    {
                        if (_document.S32Files.TryGetValue(kvp.Key, out var s32Data))
                        {
                            foreach (var item in kvp.Value) { s32Data.Layer5.Remove(item); deletedCount++; }
                            s32Data.IsModified = true;
                        }
                    }
                    WinFormsMessageBox.Show(string.Format(LocalizationManager.L("AbnormalCheck_ClearedLayer5"), deletedCount), LocalizationManager.L("AbnormalCheck_ClearComplete"));
                    ClearS32BlockCache(); resultForm.Close(); RenderS32Map();
                };
                pnlL5Buttons.GetControls().Add(btnL5ClearAll);
            }

            // ===== Tab 2: 無效 TileId =====
            if (invalidTileItems.Count > 0)
            {
                TabPage tabTile = new TabPage(string.Format(LocalizationManager.L("AbnormalCheck_Tab_InvalidTile"), invalidTileItems.Count));
                tabControl.GetTabPages().Add(tabTile);

                // 統計資訊
                int l1Count = invalidTileItems.Count(t => t.Layer == "Layer1");
                int l2Count = invalidTileItems.Count(t => t.Layer == "Layer2");
                int l4Count = invalidTileItems.Count(t => t.Layer == "Layer4");

                Label lblTileSummary = new Label();
                lblTileSummary.Text = string.Format(LocalizationManager.L("AbnormalCheck_TileSummary"), invalidTileItems.Count, l1Count, l2Count, l4Count);
                lblTileSummary.SetLocation(new Point(5, 5));
                lblTileSummary.Size = new Size(tabTile.ClientSize.Width - 10, 20);
                lblTileSummary.SetAnchor(AnchorStyles.Top | AnchorStyles.Left | AnchorStyles.Right);
                tabTile.GetControls().Add(lblTileSummary);

                CheckedListBox clbTileItems = new CheckedListBox();
                clbTileItems.SetLocation(new Point(5, 30));
                clbTileItems.Size = new Size(tabTile.ClientSize.Width - 10, tabTile.ClientSize.Height - 110);
                clbTileItems.Font = new Font("Consolas", 9);
                clbTileItems.CheckOnClick = true;
                clbTileItems.SetAnchor(AnchorStyles.Top | AnchorStyles.Bottom | AnchorStyles.Left | AnchorStyles.Right);

                foreach (var tile in invalidTileItems)
                {
                    string displayText = $"[{tile.FileName}] {tile.Layer} X={tile.X}, Y={tile.Y}, Tile={tile.TileId}, Idx={tile.IndexId} - {tile.Reason}";
                    clbTileItems.Items.Add(displayText);
                }
                tabTile.GetControls().Add(clbTileItems);

                // 按鈕面板
                Panel pnlTileButtons = new Panel();
                pnlTileButtons.SetLocation(new Point(5, tabTile.ClientSize.Height - 75));
                pnlTileButtons.Size = new Size(tabTile.ClientSize.Width - 10, 70);
                pnlTileButtons.SetAnchor(AnchorStyles.Bottom | AnchorStyles.Left | AnchorStyles.Right);
                tabTile.GetControls().Add(pnlTileButtons);

                Button btnTileSelectAll = new Button { Text = LocalizationManager.L("Button_SelectAll"), Location = new Point(0, 0), Size = new Size(80, 30) };
                btnTileSelectAll.Click += (s, args) => { for (int i = 0; i < clbTileItems.Items.Count; i++) clbTileItems.SetItemChecked(i, true); };
                pnlTileButtons.GetControls().Add(btnTileSelectAll);

                Button btnTileDeselectAll = new Button { Text = LocalizationManager.L("AbnormalCheck_DeselectAll"), Location = new Point(90, 0), Size = new Size(80, 30) };
                btnTileDeselectAll.Click += (s, args) => { for (int i = 0; i < clbTileItems.Items.Count; i++) clbTileItems.SetItemChecked(i, false); };
                pnlTileButtons.GetControls().Add(btnTileDeselectAll);

                // 篩選按鈕
                Button btnFilterL1 = new Button { Text = LocalizationManager.L("AbnormalCheck_SelectL1Only"), Location = new Point(180, 0), Size = new Size(70, 30) };
                btnFilterL1.Click += (s, args) => { for (int i = 0; i < invalidTileItems.Count; i++) clbTileItems.SetItemChecked(i, invalidTileItems[i].Layer == "Layer1"); };
                pnlTileButtons.GetControls().Add(btnFilterL1);

                Button btnFilterL2 = new Button { Text = LocalizationManager.L("AbnormalCheck_SelectL2Only"), Location = new Point(255, 0), Size = new Size(70, 30) };
                btnFilterL2.Click += (s, args) => { for (int i = 0; i < invalidTileItems.Count; i++) clbTileItems.SetItemChecked(i, invalidTileItems[i].Layer == "Layer2"); };
                pnlTileButtons.GetControls().Add(btnFilterL2);

                Button btnFilterL4 = new Button { Text = LocalizationManager.L("AbnormalCheck_SelectL4Only"), Location = new Point(330, 0), Size = new Size(70, 30) };
                btnFilterL4.Click += (s, args) => { for (int i = 0; i < invalidTileItems.Count; i++) clbTileItems.SetItemChecked(i, invalidTileItems[i].Layer == "Layer4"); };
                pnlTileButtons.GetControls().Add(btnFilterL4);

                Button btnTileClearSelected = new Button { Text = LocalizationManager.L("AbnormalCheck_ClearSelected"), Location = new Point(0, 35), Size = new Size(100, 30), BackColor = WinFormsColors.LightCoral };
                btnTileClearSelected.Click += (s, args) =>
                {
                    if (clbTileItems.CheckedIndices.Count == 0) { WinFormsMessageBox.Show(LocalizationManager.L("AbnormalCheck_PleaseSelectItems"), LocalizationManager.L("AbnormalCheck_Notice")); return; }
                    if (WinFormsMessageBox.Show(string.Format(LocalizationManager.L("AbnormalCheck_ConfirmClearTiles"), clbTileItems.CheckedIndices.Count),
                        LocalizationManager.L("AbnormalCheck_ConfirmDelete"), MessageBoxButtons.YesNo, MessageBoxIcon.Warning) != DialogResult.Yes) return;

                    int deletedCount = 0;
                    var checkedIndices = clbTileItems.CheckedIndices.Cast<int>().OrderByDescending(i => i).ToList();
                    foreach (int idx in checkedIndices)
                    {
                        var tile = invalidTileItems[idx];
                        if (_document.S32Files.TryGetValue(tile.FilePath, out var s32Data))
                        {
                            if (tile.Layer == "Layer1")
                            {
                                var cell = s32Data.Layer1[tile.Y, tile.X];
                                if (cell != null) { cell.TileId = 0; cell.IndexId = 0; deletedCount++; }
                            }
                            else if (tile.Layer == "Layer2")
                            {
                                var item = s32Data.Layer2.FirstOrDefault(l => l.X == tile.X && l.Y == tile.Y && l.TileId == tile.TileId && l.IndexId == tile.IndexId);
                                if (item != null) { s32Data.Layer2.Remove(item); deletedCount++; }
                            }
                            else if (tile.Layer == "Layer4")
                            {
                                var obj = s32Data.Layer4.FirstOrDefault(o => o.X == tile.X && o.Y == tile.Y && o.TileId == tile.TileId && o.IndexId == tile.IndexId);
                                if (obj != null) { s32Data.Layer4.Remove(obj); Layer4Index_Remove(s32Data, obj); deletedCount++; }
                            }
                            s32Data.IsModified = true;
                        }
                    }
                    WinFormsMessageBox.Show(string.Format(LocalizationManager.L("AbnormalCheck_ClearedTiles"), deletedCount), LocalizationManager.L("AbnormalCheck_ClearComplete"));
                    ClearS32BlockCache(); resultForm.Close(); RenderS32Map();
                };
                pnlTileButtons.GetControls().Add(btnTileClearSelected);

                Button btnTileClearAll = new Button { Text = LocalizationManager.L("AbnormalCheck_ClearAll"), Location = new Point(110, 35), Size = new Size(100, 30), BackColor = WinFormsColors.Salmon };
                btnTileClearAll.Click += (s, args) =>
                {
                    if (WinFormsMessageBox.Show(string.Format(LocalizationManager.L("AbnormalCheck_ConfirmClearAllTiles"), invalidTileItems.Count),
                        LocalizationManager.L("AbnormalCheck_ConfirmDeleteAll"), MessageBoxButtons.YesNo, MessageBoxIcon.Warning) != DialogResult.Yes) return;

                    int deletedCount = 0;
                    foreach (var tile in invalidTileItems)
                    {
                        if (_document.S32Files.TryGetValue(tile.FilePath, out var s32Data))
                        {
                            if (tile.Layer == "Layer1")
                            {
                                var cell = s32Data.Layer1[tile.Y, tile.X];
                                if (cell != null) { cell.TileId = 0; cell.IndexId = 0; deletedCount++; }
                            }
                            else if (tile.Layer == "Layer2")
                            {
                                var item = s32Data.Layer2.FirstOrDefault(l => l.X == tile.X && l.Y == tile.Y && l.TileId == tile.TileId && l.IndexId == tile.IndexId);
                                if (item != null) { s32Data.Layer2.Remove(item); deletedCount++; }
                            }
                            else if (tile.Layer == "Layer4")
                            {
                                var obj = s32Data.Layer4.FirstOrDefault(o => o.X == tile.X && o.Y == tile.Y && o.TileId == tile.TileId && o.IndexId == tile.IndexId);
                                if (obj != null) { s32Data.Layer4.Remove(obj); Layer4Index_Remove(s32Data, obj); deletedCount++; }
                            }
                            s32Data.IsModified = true;
                        }
                    }
                    WinFormsMessageBox.Show(string.Format(LocalizationManager.L("AbnormalCheck_ClearedTiles"), deletedCount), LocalizationManager.L("AbnormalCheck_ClearComplete"));
                    ClearS32BlockCache(); resultForm.Close(); RenderS32Map();
                };
                pnlTileButtons.GetControls().Add(btnTileClearAll);
            }

            // ===== Tab 3: Layer8 擴展格式 =====
            if (layer8ExtendedS32.Count > 0)
            {
                int totalL8Items = layer8ExtendedS32.Sum(x => x.layer8Count);
                TabPage tabL8 = new TabPage(string.Format(LocalizationManager.L("AbnormalCheck_Tab_Layer8"), layer8ExtendedS32.Count));
                tabControl.GetTabPages().Add(tabL8);

                Label lblL8Summary = new Label();
                lblL8Summary.Text = string.Format(LocalizationManager.L("AbnormalCheck_Layer8Summary"), layer8ExtendedS32.Count, totalL8Items);
                lblL8Summary.SetLocation(new Point(5, 5));
                lblL8Summary.Size = new Size(tabL8.ClientSize.Width - 10, 20);
                lblL8Summary.SetAnchor(AnchorStyles.Top | AnchorStyles.Left | AnchorStyles.Right);
                tabL8.GetControls().Add(lblL8Summary);

                CheckedListBox clbL8Items = new CheckedListBox();
                clbL8Items.SetLocation(new Point(5, 30));
                clbL8Items.Size = new Size(tabL8.ClientSize.Width - 10, tabL8.ClientSize.Height - 110);
                clbL8Items.Font = new Font("Consolas", 9);
                clbL8Items.CheckOnClick = true;
                clbL8Items.SetAnchor(AnchorStyles.Top | AnchorStyles.Bottom | AnchorStyles.Left | AnchorStyles.Right);

                foreach (var (filePath, fileName, layer8Count) in layer8ExtendedS32)
                {
                    string displayText = string.Format(LocalizationManager.L("AbnormalCheck_Layer8ItemCount"), fileName, layer8Count);
                    clbL8Items.Items.Add(displayText);
                }
                tabL8.GetControls().Add(clbL8Items);

                // 按鈕面板
                Panel pnlL8Buttons = new Panel();
                pnlL8Buttons.SetLocation(new Point(5, tabL8.ClientSize.Height - 75));
                pnlL8Buttons.Size = new Size(tabL8.ClientSize.Width - 10, 70);
                pnlL8Buttons.SetAnchor(AnchorStyles.Bottom | AnchorStyles.Left | AnchorStyles.Right);
                tabL8.GetControls().Add(pnlL8Buttons);

                Button btnL8SelectAll = new Button { Text = LocalizationManager.L("Button_SelectAll"), Location = new Point(0, 0), Size = new Size(80, 30) };
                btnL8SelectAll.Click += (s, args) => { for (int i = 0; i < clbL8Items.Items.Count; i++) clbL8Items.SetItemChecked(i, true); };
                pnlL8Buttons.GetControls().Add(btnL8SelectAll);

                Button btnL8DeselectAll = new Button { Text = LocalizationManager.L("AbnormalCheck_DeselectAll"), Location = new Point(90, 0), Size = new Size(80, 30) };
                btnL8DeselectAll.Click += (s, args) => { for (int i = 0; i < clbL8Items.Items.Count; i++) clbL8Items.SetItemChecked(i, false); };
                pnlL8Buttons.GetControls().Add(btnL8DeselectAll);

                Button btnL8ResetSelected = new Button { Text = LocalizationManager.L("AbnormalCheck_ResetSelectedFormat"), Location = new Point(0, 35), Size = new Size(150, 30), BackColor = WinFormsColors.LightCoral };
                btnL8ResetSelected.Click += (s, args) =>
                {
                    if (clbL8Items.CheckedIndices.Count == 0) { WinFormsMessageBox.Show(LocalizationManager.L("AbnormalCheck_PleaseSelectReset"), LocalizationManager.L("AbnormalCheck_Notice")); return; }
                    if (WinFormsMessageBox.Show(string.Format(LocalizationManager.L("AbnormalCheck_ConfirmResetSelected"), clbL8Items.CheckedIndices.Count),
                        LocalizationManager.L("AbnormalCheck_ConfirmReset"), MessageBoxButtons.YesNo, MessageBoxIcon.Warning) != DialogResult.Yes) return;

                    int resetCount = 0;
                    int clearedItems = 0;
                    foreach (int idx in clbL8Items.CheckedIndices)
                    {
                        var (filePath, _, _) = layer8ExtendedS32[idx];
                        if (_document.S32Files.TryGetValue(filePath, out var s32Data))
                        {
                            s32Data.Layer8HasExtendedData = false;
                            foreach (var item in s32Data.Layer8)
                            {
                                item.ExtendedData = 0;
                                clearedItems++;
                            }
                            s32Data.IsModified = true;
                            resetCount++;
                        }
                    }
                    WinFormsMessageBox.Show(string.Format(LocalizationManager.L("AbnormalCheck_ResetComplete"), resetCount, clearedItems), LocalizationManager.L("AbnormalCheck_ResetDone"));
                    UpdateMapValidateButton();
                    resultForm.Close();
                };
                pnlL8Buttons.GetControls().Add(btnL8ResetSelected);

                Button btnL8ResetAll = new Button { Text = LocalizationManager.L("AbnormalCheck_ResetAllFormat"), Location = new Point(160, 35), Size = new Size(150, 30), BackColor = WinFormsColors.Salmon };
                btnL8ResetAll.Click += (s, args) =>
                {
                    if (WinFormsMessageBox.Show(string.Format(LocalizationManager.L("AbnormalCheck_ConfirmResetAll"), layer8ExtendedS32.Count),
                        LocalizationManager.L("AbnormalCheck_ConfirmResetAll_Title"), MessageBoxButtons.YesNo, MessageBoxIcon.Warning) != DialogResult.Yes) return;

                    int resetCount = 0;
                    int clearedItems = 0;
                    foreach (var (filePath, _, _) in layer8ExtendedS32)
                    {
                        if (_document.S32Files.TryGetValue(filePath, out var s32Data))
                        {
                            s32Data.Layer8HasExtendedData = false;
                            foreach (var item in s32Data.Layer8)
                            {
                                item.ExtendedData = 0;
                                clearedItems++;
                            }
                            s32Data.IsModified = true;
                            resetCount++;
                        }
                    }
                    WinFormsMessageBox.Show(string.Format(LocalizationManager.L("AbnormalCheck_ResetComplete"), resetCount, clearedItems), LocalizationManager.L("AbnormalCheck_ResetDone"));
                    UpdateMapValidateButton();
                    resultForm.Close();
                };
                pnlL8Buttons.GetControls().Add(btnL8ResetAll);
            }

            // ===== Tab 4: Tile 超過上限 =====
            if (overLimitTileIds.Count > 0)
            {
                TabPage tabOverLimit = new TabPage(string.Format(LocalizationManager.L("AbnormalCheck_Tab_OverLimit"), overLimitTileIds.Count));
                tabControl.GetTabPages().Add(tabOverLimit);

                Label lblOverLimitSummary = new Label();
                lblOverLimitSummary.Text = string.Format(LocalizationManager.L("AbnormalCheck_OverLimitSummary"), overLimitTileIds.Count, tileLimit, maxTileId);
                lblOverLimitSummary.SetLocation(new Point(5, 5));
                lblOverLimitSummary.Size = new Size(tabOverLimit.ClientSize.Width - 10, 40);
                lblOverLimitSummary.SetAnchor(AnchorStyles.Top | AnchorStyles.Left | AnchorStyles.Right);
                tabOverLimit.GetControls().Add(lblOverLimitSummary);

                ListBox lbOverLimitItems = new ListBox();
                lbOverLimitItems.SetLocation(new Point(5, 50));
                lbOverLimitItems.Size = new Size(tabOverLimit.ClientSize.Width - 10, tabOverLimit.ClientSize.Height - 130);
                lbOverLimitItems.Font = new Font("Consolas", 9);
                lbOverLimitItems.SetAnchor(AnchorStyles.Top | AnchorStyles.Bottom | AnchorStyles.Left | AnchorStyles.Right);

                foreach (var tileId in overLimitTileIds)
                {
                    lbOverLimitItems.Items.Add($"Tile ID: {tileId}");
                }
                tabOverLimit.GetControls().Add(lbOverLimitItems);

                // 按鈕面板
                Panel pnlOverLimitButtons = new Panel();
                pnlOverLimitButtons.SetLocation(new Point(5, tabOverLimit.ClientSize.Height - 75));
                pnlOverLimitButtons.Size = new Size(tabOverLimit.ClientSize.Width - 10, 70);
                pnlOverLimitButtons.SetAnchor(AnchorStyles.Bottom | AnchorStyles.Left | AnchorStyles.Right);
                tabOverLimit.GetControls().Add(pnlOverLimitButtons);

                // 計算建議的新上限（最大值 + 5000）
                int suggestedLimit = maxTileId + 5000;

                Label lblSuggestion = new Label();
                lblSuggestion.Text = $"建議將上限擴充至: {suggestedLimit}";
                lblSuggestion.SetLocation(new Point(0, 5));
                lblSuggestion.Size = new Size(300, 20);
                pnlOverLimitButtons.GetControls().Add(lblSuggestion);

                Button btnExpandLimit = new Button { Text = $"擴充上限至 {suggestedLimit}", Location = new Point(0, 30), Size = new Size(180, 30), BackColor = Colors.LightGreen };
                btnExpandLimit.Click += (s, args) =>
                {
                    if (WinFormsMessageBox.Show($"確定要將 list.til 上限從 {tileLimit} 擴充至 {suggestedLimit} 嗎？",
                        "確認擴充上限", MessageBoxButtons.YesNo, MessageBoxIcon.Question) != DialogResult.Yes) return;

                    if (TileHashManager.UpdateTileLimit(suggestedLimit))
                    {
                        _listTilMaxId = null;  // 清除快取
                        WinFormsMessageBox.Show($"已將 list.til 上限擴充至 {suggestedLimit}。", "擴充成功", MessageBoxButtons.OK, MessageBoxIcon.Information);
                        UpdateMapValidateButton();
                        resultForm.Close();
                    }
                    else
                    {
                        WinFormsMessageBox.Show("擴充失敗，請檢查 Tile.pak 是否可寫入。", "錯誤", MessageBoxButtons.OK, MessageBoxIcon.Error);
                    }
                };
                pnlOverLimitButtons.GetControls().Add(btnExpandLimit);

                Button btnExpandCustom = new Button { Text = "自訂上限...", Location = new Point(190, 30), Size = new Size(100, 30) };
                btnExpandCustom.Click += (s, args) =>
                {
                    string input = Microsoft.VisualBasic.Interaction.InputBox(
                        $"請輸入新的上限值（目前上限: {tileLimit}，最大Tile: {maxTileId}）：",
                        "自訂上限", suggestedLimit.ToString());
                    if (string.IsNullOrEmpty(input)) return;
                    if (!int.TryParse(input, out int newLimit) || newLimit < maxTileId)
                    {
                        WinFormsMessageBox.Show($"無效的數值。新上限必須大於或等於最大 Tile ID ({maxTileId})。", "錯誤", MessageBoxButtons.OK, MessageBoxIcon.Warning);
                        return;
                    }
                    if (TileHashManager.UpdateTileLimit(newLimit))
                    {
                        _listTilMaxId = null;
                        WinFormsMessageBox.Show($"已將 list.til 上限設為 {newLimit}。", "設定成功", MessageBoxButtons.OK, MessageBoxIcon.Information);
                        UpdateMapValidateButton();
                        resultForm.Close();
                    }
                    else
                    {
                        WinFormsMessageBox.Show("設定失敗，請檢查 Tile.pak 是否可寫入。", "錯誤", MessageBoxButtons.OK, MessageBoxIcon.Error);
                    }
                };
                pnlOverLimitButtons.GetControls().Add(btnExpandCustom);
            }

            // ===== Tab 5: L5 無效 Type =====
            if (invalidL5TypeItems.Count > 0)
            {
                TabPage tabL5Type = new TabPage($"L5無效Type ({invalidL5TypeItems.Count})");
                tabControl.GetTabPages().Add(tabL5Type);

                // 統計各 Type 的數量
                var typeCounts = invalidL5TypeItems.GroupBy(x => x.item.Type)
                    .OrderBy(g => g.Key)
                    .Select(g => $"Type={g.Key}: {g.Count()}");

                Label lblL5TypeSummary = new Label();
                lblL5TypeSummary.Text = $"發現 {invalidL5TypeItems.Count} 個 L5 項目使用無效的 Type 值 (有效值: 0=半透明, 1=消失)\n分佈: {string.Join(", ", typeCounts)}";
                lblL5TypeSummary.SetLocation(new Point(5, 5));
                lblL5TypeSummary.Size = new Size(tabL5Type.ClientSize.Width - 10, 40);
                lblL5TypeSummary.SetAnchor(AnchorStyles.Top | AnchorStyles.Left | AnchorStyles.Right);
                tabL5Type.GetControls().Add(lblL5TypeSummary);

                CheckedListBox clbL5TypeItems = new CheckedListBox();
                clbL5TypeItems.SetLocation(new Point(5, 50));
                clbL5TypeItems.Size = new Size(tabL5Type.ClientSize.Width - 10, tabL5Type.ClientSize.Height - 130);
                clbL5TypeItems.Font = new Font("Consolas", 9);
                clbL5TypeItems.CheckOnClick = true;
                clbL5TypeItems.SetAnchor(AnchorStyles.Top | AnchorStyles.Bottom | AnchorStyles.Left | AnchorStyles.Right);

                foreach (var (filePath, fileName, item, itemIndex) in invalidL5TypeItems)
                {
                    // 計算遊戲座標
                    string gameCoordStr = "";
                    if (_document.S32Files.TryGetValue(filePath, out var s32Data) && s32Data.SegInfo != null)
                    {
                        int gameX = s32Data.SegInfo.nLinBeginX + item.X / 2;
                        int gameY = s32Data.SegInfo.nLinBeginY + item.Y;
                        gameCoordStr = $" 遊戲({gameX},{gameY})";
                    }
                    string displayText = $"[{fileName}] X={item.X}, Y={item.Y}{gameCoordStr}, ObjIdx={item.ObjectIndex}, Type={item.Type}";
                    clbL5TypeItems.Items.Add(displayText);
                }
                tabL5Type.GetControls().Add(clbL5TypeItems);

                // 按鈕面板
                Panel pnlL5TypeButtons = new Panel();
                pnlL5TypeButtons.SetLocation(new Point(5, tabL5Type.ClientSize.Height - 75));
                pnlL5TypeButtons.Size = new Size(tabL5Type.ClientSize.Width - 10, 70);
                pnlL5TypeButtons.SetAnchor(AnchorStyles.Bottom | AnchorStyles.Left | AnchorStyles.Right);
                tabL5Type.GetControls().Add(pnlL5TypeButtons);

                Button btnL5TypeSelectAll = new Button { Text = "全選", Location = new Point(0, 0), Size = new Size(80, 30) };
                btnL5TypeSelectAll.Click += (s, args) => { for (int i = 0; i < clbL5TypeItems.Items.Count; i++) clbL5TypeItems.SetItemChecked(i, true); };
                pnlL5TypeButtons.GetControls().Add(btnL5TypeSelectAll);

                Button btnL5TypeDeselectAll = new Button { Text = "全不選", Location = new Point(90, 0), Size = new Size(80, 30) };
                btnL5TypeDeselectAll.Click += (s, args) => { for (int i = 0; i < clbL5TypeItems.Items.Count; i++) clbL5TypeItems.SetItemChecked(i, false); };
                pnlL5TypeButtons.GetControls().Add(btnL5TypeDeselectAll);

                Button btnL5TypeClearSelected = new Button { Text = "清除勾選項目", Location = new Point(0, 35), Size = new Size(100, 30), BackColor = WinFormsColors.LightCoral };
                btnL5TypeClearSelected.Click += (s, args) =>
                {
                    if (clbL5TypeItems.CheckedIndices.Count == 0) { WinFormsMessageBox.Show("請先勾選要清除的項目", "提示"); return; }
                    if (WinFormsMessageBox.Show($"確定要清除 {clbL5TypeItems.CheckedIndices.Count} 個 L5 項目？", "確認刪除", MessageBoxButtons.YesNo, MessageBoxIcon.Warning) != DialogResult.Yes) return;

                    var toDelete = new Dictionary<string, List<Layer5Item>>();
                    foreach (int idx in clbL5TypeItems.CheckedIndices)
                    {
                        var (filePath, _, item, _) = invalidL5TypeItems[idx];
                        if (!toDelete.ContainsKey(filePath)) toDelete[filePath] = new List<Layer5Item>();
                        toDelete[filePath].Add(item);
                    }
                    int deletedCount = 0;
                    foreach (var kvp in toDelete)
                    {
                        if (_document.S32Files.TryGetValue(kvp.Key, out var s32Data))
                        {
                            foreach (var item in kvp.Value) { s32Data.Layer5.Remove(item); deletedCount++; }
                            s32Data.IsModified = true;
                        }
                    }
                    WinFormsMessageBox.Show($"已清除 {deletedCount} 個 L5 項目。\n請記得儲存 S32 檔案。", "清除完成");
                    ClearS32BlockCache(); resultForm.Close(); RenderS32Map();
                    UpdateMapValidateButton();
                };
                pnlL5TypeButtons.GetControls().Add(btnL5TypeClearSelected);

                Button btnL5TypeClearAll = new Button { Text = "清除全部", Location = new Point(110, 35), Size = new Size(100, 30), BackColor = WinFormsColors.Salmon };
                btnL5TypeClearAll.Click += (s, args) =>
                {
                    if (WinFormsMessageBox.Show($"確定要清除全部 {invalidL5TypeItems.Count} 個無效 Type 的 L5 項目？", "確認全部刪除", MessageBoxButtons.YesNo, MessageBoxIcon.Warning) != DialogResult.Yes) return;
                    var toDelete = new Dictionary<string, List<Layer5Item>>();
                    foreach (var (filePath, _, item, _) in invalidL5TypeItems)
                    {
                        if (!toDelete.ContainsKey(filePath)) toDelete[filePath] = new List<Layer5Item>();
                        toDelete[filePath].Add(item);
                    }
                    int deletedCount = 0;
                    foreach (var kvp in toDelete)
                    {
                        if (_document.S32Files.TryGetValue(kvp.Key, out var s32Data))
                        {
                            foreach (var item in kvp.Value) { s32Data.Layer5.Remove(item); deletedCount++; }
                            s32Data.IsModified = true;
                        }
                    }
                    WinFormsMessageBox.Show($"已清除 {deletedCount} 個 L5 項目。\n請記得儲存 S32 檔案。", "清除完成");
                    ClearS32BlockCache(); resultForm.Close(); RenderS32Map();
                    UpdateMapValidateButton();
                };
                pnlL5TypeButtons.GetControls().Add(btnL5TypeClearAll);
            }

            // 關閉按鈕
            Button btnClose = new Button();
            btnClose.Text = "關閉";
            // 使用固定初始位置，Anchor 會在 Form 顯示後自動調整
            btnClose.SetLocation(new Point(760, 555));
            btnClose.Size = new Size(80, 30);
            btnClose.SetAnchor(AnchorStyles.Bottom | AnchorStyles.Right);
            btnClose.Click += (s, args) => resultForm.Close();
            resultForm.GetControls().Add(btnClose);

            resultForm.ShowDialog(this);
        }

        // 查看與管理第七層（傳送點）資料 - 支援編輯
        private void btnToolCheckL7_Click(object sender, EventArgs e)
        {
            if (_document.S32Files.Count == 0)
            {
                WinFormsMessageBox.Show("請先載入地圖", "提示", MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            // 收集有 Layer7 資料的 S32
            List<(string filePath, string fileName, int count, List<Layer7Item> items)> s32WithL7 =
                new List<(string, string, int, List<Layer7Item>)>();

            foreach (var kvp in _document.S32Files)
            {
                string filePath = kvp.Key;
                string fileName = Path.GetFileName(kvp.Key);
                S32Data s32Data = kvp.Value;

                if (s32Data.Layer7.Count > 0)
                {
                    s32WithL7.Add((filePath, fileName, s32Data.Layer7.Count, s32Data.Layer7.ToList()));
                }
            }

            // 顯示結果
            Form resultForm = new Form();
            resultForm.Text = $"L7 檢查、編輯與清除 - {s32WithL7.Count} 個 S32 有資料";
            resultForm.Size = new Size(800, 600);
            resultForm.SetFormBorderStyle(FormBorderStyle.Sizable);
            resultForm.SetStartPosition(FormStartPosition.CenterParent);

            int totalItems = s32WithL7.Sum(x => x.count);
            Label lblSummary = new Label();
            lblSummary.Text = $"共 {s32WithL7.Count} 個 S32 檔案有 Layer7（傳送點）資料，總計 {totalItems} 項。選取項目後可編輯或刪除：";
            lblSummary.SetLocation(new Point(10, 10));
            lblSummary.Size = new Size(760, 20);
            resultForm.GetControls().Add(lblSummary);

            // 使用 ListView 來顯示詳細資訊
            ListView lvItems = new ListView();
            lvItems.SetLocation(new Point(10, 35));
            lvItems.Size = new Size(760, 350);
            lvItems.Font = new Font("Consolas", 9);
            lvItems.View = View.Details;
            lvItems.FullRowSelect = true;
            lvItems.CheckBoxes = true;
            lvItems.Columns.Add("S32 檔案", 120);
            lvItems.Columns.Add("名稱", 150);
            lvItems.Columns.Add("X", 50);
            lvItems.Columns.Add("Y", 50);
            lvItems.Columns.Add("目標地圖", 80);
            lvItems.Columns.Add("PortalId", 80);

            List<(string filePath, Layer7Item item)> itemInfoList = new List<(string, Layer7Item)>();

            if (s32WithL7.Count == 0)
            {
                lvItems.Items.Add(new ListViewItem("沒有任何 S32 檔案有 Layer7 資料"));
                lvItems.Enabled = false;
            }
            else
            {
                foreach (var (filePath, fileName, count, items) in s32WithL7)
                {
                    foreach (var item in items)
                    {
                        ListViewItem lvi = new ListViewItem(fileName);
                        lvi.SubItems.Add(item.Name);
                        lvi.SubItems.Add(item.X.ToString());
                        lvi.SubItems.Add(item.Y.ToString());
                        lvi.SubItems.Add(item.TargetMapId.ToString());
                        lvi.SubItems.Add(item.PortalId.ToString());
                        lvi.Tag = (filePath, item);
                        lvItems.Items.Add(lvi);
                        itemInfoList.Add((filePath, item));
                    }
                }
            }
            resultForm.GetControls().Add(lvItems);

            // 編輯區域
            GroupBox gbEdit = new GroupBox();
            gbEdit.Text = "編輯選取的項目";
            gbEdit.SetLocation(new Point(10, 395));
            gbEdit.Size = new Size(760, 80);

            Label lblName = new Label { Text = "名稱:", Size = new Size(40, 20) };
            lblName.SetLocation(new Point(10, 25));
            TextBox txtName = new TextBox { Size = new Size(120, 23) };
            txtName.SetLocation(new Point(55, 22));
            Label lblX = new Label { Text = "X:", Size = new Size(20, 20) };
            lblX.SetLocation(new Point(185, 25));
            TextBox txtX = new TextBox { Size = new Size(50, 23) };
            txtX.SetLocation(new Point(205, 22));
            Label lblY = new Label { Text = "Y:", Size = new Size(20, 20) };
            lblY.SetLocation(new Point(265, 25));
            TextBox txtY = new TextBox { Size = new Size(50, 23) };
            txtY.SetLocation(new Point(285, 22));
            Label lblTarget = new Label { Text = "目標地圖:", Size = new Size(60, 20) };
            lblTarget.SetLocation(new Point(345, 25));
            TextBox txtTarget = new TextBox { Size = new Size(60, 23) };
            txtTarget.SetLocation(new Point(410, 22));
            Label lblPortal = new Label { Text = "PortalId:", Size = new Size(55, 20) };
            lblPortal.SetLocation(new Point(480, 25));
            TextBox txtPortal = new TextBox { Size = new Size(60, 23) };
            txtPortal.SetLocation(new Point(540, 22));

            Button btnApplyEdit = new Button();
            btnApplyEdit.Text = "套用修改";
            btnApplyEdit.SetLocation(new Point(620, 20));
            btnApplyEdit.Size = new Size(80, 28);
            btnApplyEdit.Click += (s, args) =>
            {
                if (lvItems.SelectedItems.Count != 1)
                {
                    WinFormsMessageBox.Show("請選取一個項目進行編輯", "提示", MessageBoxButtons.OK, MessageBoxIcon.Information);
                    return;
                }

                var lvi = lvItems.SelectedItems[0];
                var (filePath, item) = ((string, Layer7Item))lvi.Tag;

                if (!byte.TryParse(txtX.Text, out byte newX) ||
                    !byte.TryParse(txtY.Text, out byte newY) ||
                    !ushort.TryParse(txtTarget.Text, out ushort newTarget) ||
                    !int.TryParse(txtPortal.Text, out int newPortal))
                {
                    WinFormsMessageBox.Show("請輸入有效的數值", "錯誤", MessageBoxButtons.OK, MessageBoxIcon.Error);
                    return;
                }

                // 更新資料
                item.Name = txtName.Text;
                item.X = newX;
                item.Y = newY;
                item.TargetMapId = newTarget;
                item.PortalId = newPortal;

                // 更新 ListView 顯示
                lvi.SubItems[1].Text = item.Name;
                lvi.SubItems[2].Text = item.X.ToString();
                lvi.SubItems[3].Text = item.Y.ToString();
                lvi.SubItems[4].Text = item.TargetMapId.ToString();
                lvi.SubItems[5].Text = item.PortalId.ToString();

                // 標記已修改
                if (_document.S32Files.TryGetValue(filePath, out S32Data s32Data))
                {
                    s32Data.IsModified = true;
                }

                WinFormsMessageBox.Show("已套用修改。請記得儲存 S32 檔案。", "完成", MessageBoxButtons.OK, MessageBoxIcon.Information);
            };

            // 新增項目按鈕
            Button btnAddNew = new Button();
            btnAddNew.Text = "新增";
            btnAddNew.SetLocation(new Point(620, 52));
            btnAddNew.Size = new Size(80, 28);
            btnAddNew.Click += (s, args) =>
            {
                // 選擇要新增到哪個 S32 檔案
                Form selectForm = new Form();
                selectForm.Text = "選擇 S32 檔案";
                selectForm.Size = new Size(400, 350);
                selectForm.SetFormBorderStyle(FormBorderStyle.FixedDialog);
                selectForm.SetStartPosition(FormStartPosition.CenterParent);
                selectForm.SetMaximizeBox(false);
                selectForm.SetMinimizeBox(false);

                Label lblSelect = new Label();
                lblSelect.Text = "選擇要新增 Layer7 項目的 S32 檔案：";
                lblSelect.SetLocation(new Point(10, 10));
                lblSelect.Size = new Size(360, 20);
                selectForm.GetControls().Add(lblSelect);

                ListBox lbS32Files = new ListBox();
                lbS32Files.SetLocation(new Point(10, 35));
                lbS32Files.Size = new Size(360, 220);
                foreach (var kvp in _document.S32Files)
                {
                    lbS32Files.Items.Add(Path.GetFileName(kvp.Key));
                }
                if (lbS32Files.Items.Count > 0)
                    lbS32Files.SelectedIndex = 0;
                selectForm.GetControls().Add(lbS32Files);

                Button btnOK = new Button();
                btnOK.Text = "確定";
                btnOK.SetLocation(new Point(100, 265));
                btnOK.Size = new Size(80, 30);
                btnOK.DialogResult = DialogResult.Ok;
                selectForm.GetControls().Add(btnOK);

                Button btnCancel = new Button();
                btnCancel.Text = "取消";
                btnCancel.SetLocation(new Point(200, 265));
                btnCancel.Size = new Size(80, 30);
                btnCancel.DialogResult = DialogResult.Cancel;
                selectForm.GetControls().Add(btnCancel);

                selectForm.AcceptButton = btnOK;
                selectForm.CancelButton = btnCancel;

                if (selectForm.ShowDialog(this) == DialogResult.Ok && lbS32Files.SelectedItem != null)
                {
                    string selectedFileName = lbS32Files.SelectedItem.ToString();
                    string selectedFilePath = _document.S32Files.Keys.FirstOrDefault(k => Path.GetFileName(k) == selectedFileName);

                    if (selectedFilePath != null && _document.S32Files.TryGetValue(selectedFilePath, out S32Data s32Data))
                    {
                        // 驗證輸入
                        if (!byte.TryParse(txtX.Text, out byte newX))
                            newX = 0;
                        if (!byte.TryParse(txtY.Text, out byte newY))
                            newY = 0;
                        if (!ushort.TryParse(txtTarget.Text, out ushort newTarget))
                            newTarget = 0;
                        if (!int.TryParse(txtPortal.Text, out int newPortal))
                            newPortal = 0;

                        // 建立新項目
                        Layer7Item newItem = new Layer7Item
                        {
                            Name = string.IsNullOrEmpty(txtName.Text) ? "NewPortal" : txtName.Text,
                            X = newX,
                            Y = newY,
                            TargetMapId = newTarget,
                            PortalId = newPortal
                        };

                        // 加入 S32 資料
                        s32Data.Layer7.Add(newItem);
                        s32Data.IsModified = true;

                        // 更新 ListView
                        ListViewItem newLvi = new ListViewItem(selectedFileName);
                        newLvi.SubItems.Add(newItem.Name);
                        newLvi.SubItems.Add(newItem.X.ToString());
                        newLvi.SubItems.Add(newItem.Y.ToString());
                        newLvi.SubItems.Add(newItem.TargetMapId.ToString());
                        newLvi.SubItems.Add(newItem.PortalId.ToString());
                        newLvi.Tag = (selectedFilePath, newItem);
                        lvItems.Items.Add(newLvi);
                        itemInfoList.Add((selectedFilePath, newItem));

                        // 選取新增的項目
                        newLvi.Selected = true;
                        newLvi.EnsureVisible();

                        WinFormsMessageBox.Show($"已新增 Layer7 項目到 {selectedFileName}。\n\n請記得儲存 S32 檔案。", "完成",
                            MessageBoxButtons.OK, MessageBoxIcon.Information);
                    }
                }
            };

            gbEdit.GetControls().Add(lblName);
            gbEdit.GetControls().Add(txtName);
            gbEdit.GetControls().Add(lblX);
            gbEdit.GetControls().Add(txtX);
            gbEdit.GetControls().Add(lblY);
            gbEdit.GetControls().Add(txtY);
            gbEdit.GetControls().Add(lblTarget);
            gbEdit.GetControls().Add(txtTarget);
            gbEdit.GetControls().Add(lblPortal);
            gbEdit.GetControls().Add(txtPortal);
            gbEdit.GetControls().Add(btnApplyEdit);
            gbEdit.GetControls().Add(btnAddNew);
            resultForm.GetControls().Add(gbEdit);

            // 選取項目時填入編輯區
            lvItems.SelectedIndexChanged += (s, args) =>
            {
                if (lvItems.SelectedItems.Count == 1)
                {
                    var lvi = lvItems.SelectedItems[0];
                    var (filePath, item) = ((string, Layer7Item))lvi.Tag;
                    txtName.Text = item.Name;
                    txtX.Text = item.X.ToString();
                    txtY.Text = item.Y.ToString();
                    txtTarget.Text = item.TargetMapId.ToString();
                    txtPortal.Text = item.PortalId.ToString();
                }
            };

            Button btnSelectAll = new Button();
            btnSelectAll.Text = "全選";
            btnSelectAll.SetLocation(new Point(10, 485));
            btnSelectAll.Size = new Size(80, 30);
            btnSelectAll.Click += (s, args) =>
            {
                foreach (ListViewItem lvi in lvItems.Items)
                    lvi.Checked = true;
            };
            resultForm.GetControls().Add(btnSelectAll);

            Button btnDeselectAll = new Button();
            btnDeselectAll.Text = "取消全選";
            btnDeselectAll.SetLocation(new Point(100, 485));
            btnDeselectAll.Size = new Size(80, 30);
            btnDeselectAll.Click += (s, args) =>
            {
                foreach (ListViewItem lvi in lvItems.Items)
                    lvi.Checked = false;
            };
            resultForm.GetControls().Add(btnDeselectAll);

            Button btnClearSelected = new Button();
            btnClearSelected.Text = "刪除勾選項目";
            btnClearSelected.SetLocation(new Point(10, 525));
            btnClearSelected.Size = new Size(120, 35);
            btnClearSelected.BackgroundColor = WinFormsColors.LightCoral;
            btnClearSelected.Enabled = s32WithL7.Count > 0;
            btnClearSelected.Click += (s, args) =>
            {
                int checkedCount = lvItems.CheckedItems.Count;
                if (checkedCount == 0)
                {
                    WinFormsMessageBox.Show("請先勾選要刪除的項目", "提示", MessageBoxButtons.OK, MessageBoxIcon.Information);
                    return;
                }

                var confirmResult = WinFormsMessageBox.Show(
                    $"確定要刪除勾選的 {checkedCount} 個 Layer7 項目嗎？",
                    "確認刪除",
                    MessageBoxButtons.YesNo,
                    MessageBoxIcon.Warning);

                if (confirmResult != DialogResult.Yes) return;

                Dictionary<string, List<Layer7Item>> toRemove = new Dictionary<string, List<Layer7Item>>();
                foreach (ListViewItem lvi in lvItems.CheckedItems)
                {
                    var (filePath, item) = ((string, Layer7Item))lvi.Tag;
                    if (!toRemove.ContainsKey(filePath))
                        toRemove[filePath] = new List<Layer7Item>();
                    toRemove[filePath].Add(item);
                }

                int removedCount = 0;
                foreach (var kvp in toRemove)
                {
                    if (_document.S32Files.TryGetValue(kvp.Key, out S32Data s32Data))
                    {
                        foreach (var item in kvp.Value)
                        {
                            if (s32Data.Layer7.Remove(item))
                                removedCount++;
                        }
                        s32Data.IsModified = true;
                    }
                }

                WinFormsMessageBox.Show($"已刪除 {removedCount} 個 Layer7 項目。\n\n請記得儲存 S32 檔案。", "完成",
                    MessageBoxButtons.OK, MessageBoxIcon.Information);

                resultForm.Close();
                RenderS32Map();
            };
            resultForm.GetControls().Add(btnClearSelected);

            Button btnClearAll = new Button();
            btnClearAll.Text = "刪除全部 L7";
            btnClearAll.SetLocation(new Point(140, 525));
            btnClearAll.Size = new Size(120, 35);
            btnClearAll.BackgroundColor = WinFormsColors.Salmon;
            btnClearAll.Enabled = s32WithL7.Count > 0;
            btnClearAll.Click += (s, args) =>
            {
                var confirmResult = WinFormsMessageBox.Show(
                    $"確定要刪除所有 {totalItems} 個 Layer7 項目嗎？",
                    "確認刪除全部",
                    MessageBoxButtons.YesNo,
                    MessageBoxIcon.Warning);

                if (confirmResult != DialogResult.Yes) return;

                int removedCount = 0;
                foreach (var (filePath, fileName, count, items) in s32WithL7)
                {
                    if (_document.S32Files.TryGetValue(filePath, out S32Data s32Data))
                    {
                        removedCount += s32Data.Layer7.Count;
                        s32Data.Layer7.Clear();
                        s32Data.IsModified = true;
                    }
                }

                WinFormsMessageBox.Show($"已刪除 {removedCount} 個 Layer7 項目。\n\n請記得儲存 S32 檔案。", "完成",
                    MessageBoxButtons.OK, MessageBoxIcon.Information);

                resultForm.Close();
                RenderS32Map();
            };
            resultForm.GetControls().Add(btnClearAll);

            Button btnClose = new Button();
            btnClose.Text = "關閉";
            btnClose.SetLocation(new Point(680, 525));
            btnClose.Size = new Size(90, 35);
            btnClose.Click += (s, args) => resultForm.Close();
            resultForm.GetControls().Add(btnClose);

            resultForm.Resize += (s, args) =>
            {
                int clientWidth = Math.Max(100, resultForm.ClientSize.Width);
                int clientHeight = Math.Max(300, resultForm.ClientSize.Height);
                lvItems.Size = new Size(Math.Max(10, clientWidth - 20), Math.Max(10, clientHeight - 210));
                gbEdit.SetLocation(new Point(10, Math.Max(10, clientHeight - 165)));
                gbEdit.Size = new Size(Math.Max(10, clientWidth - 20), 80);
                btnSelectAll.SetLocation(new Point(10, Math.Max(10, clientHeight - 75)));
                btnDeselectAll.SetLocation(new Point(100, Math.Max(10, clientHeight - 75)));
                btnClearSelected.SetLocation(new Point(10, Math.Max(10, clientHeight - 35)));
                btnClearAll.SetLocation(new Point(140, Math.Max(10, clientHeight - 35)));
                btnClose.SetLocation(new Point(Math.Max(10, clientWidth - 100), Math.Max(10, clientHeight - 35)));
            };

            resultForm.ShowDialog(this);
        }

        private void btnToolAddS32_Click(object sender, EventArgs e)
        {
            // 檢查是否已載入地圖
            if (string.IsNullOrEmpty(_document.MapId) || !Share.MapDataList.ContainsKey(_document.MapId))
            {
                WinFormsMessageBox.Show("請先載入地圖", "提示", MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }

            Struct.L1Map currentMap = Share.MapDataList[_document.MapId];

            // 創建新增 S32 對話框
            Form addS32Form = new Form();
            addS32Form.Text = "新增 S32 區塊";
            addS32Form.Size = new Size(400, 280);
            addS32Form.SetFormBorderStyle(FormBorderStyle.FixedDialog);
            addS32Form.SetStartPosition(FormStartPosition.CenterParent);
            addS32Form.SetMaximizeBox(false);
            addS32Form.SetMinimizeBox(false);

            // 說明
            Label lblInfo = new Label();
            lblInfo.Text = "輸入要新增的 S32 區塊座標（BlockX, BlockY）\n或輸入遊戲座標自動計算";
            lblInfo.SetLocation(new Point(20, 15));
            lblInfo.Size = new Size(350, 35);
            addS32Form.GetControls().Add(lblInfo);

            // BlockX
            Label lblBlockX = new Label();
            lblBlockX.Text = "BlockX (16進位):";
            lblBlockX.SetLocation(new Point(20, 60));
            lblBlockX.Size = new Size(100, 20);
            addS32Form.GetControls().Add(lblBlockX);

            TextBox txtBlockX = new TextBox();
            txtBlockX.SetLocation(new Point(130, 58));
            txtBlockX.Size = new Size(80, 20);
            txtBlockX.Text = "7FFF";
            addS32Form.GetControls().Add(txtBlockX);

            // BlockY
            Label lblBlockY = new Label();
            lblBlockY.Text = "BlockY (16進位):";
            lblBlockY.SetLocation(new Point(20, 90));
            lblBlockY.Size = new Size(100, 20);
            addS32Form.GetControls().Add(lblBlockY);

            TextBox txtBlockY = new TextBox();
            txtBlockY.SetLocation(new Point(130, 88));
            txtBlockY.Size = new Size(80, 20);
            txtBlockY.Text = "8000";
            addS32Form.GetControls().Add(txtBlockY);

            // 分隔線
            Label lblSeparator = new Label();
            lblSeparator.Text = "── 或用遊戲座標計算 ──";
            lblSeparator.SetLocation(new Point(20, 120));
            lblSeparator.Size = new Size(350, 20);
            lblSeparator.TextColor = Colors.Gray;
            addS32Form.GetControls().Add(lblSeparator);

            // 遊戲座標 X
            Label lblGameX = new Label();
            lblGameX.Text = "遊戲座標 X:";
            lblGameX.SetLocation(new Point(20, 150));
            lblGameX.Size = new Size(100, 20);
            addS32Form.GetControls().Add(lblGameX);

            TextBox txtGameX = new TextBox();
            txtGameX.SetLocation(new Point(130, 148));
            txtGameX.Size = new Size(80, 20);
            addS32Form.GetControls().Add(txtGameX);

            // 遊戲座標 Y
            Label lblGameY = new Label();
            lblGameY.Text = "遊戲座標 Y:";
            lblGameY.SetLocation(new Point(220, 150));
            lblGameY.Size = new Size(80, 20);
            addS32Form.GetControls().Add(lblGameY);

            TextBox txtGameY = new TextBox();
            txtGameY.SetLocation(new Point(300, 148));
            txtGameY.Size = new Size(80, 20);
            addS32Form.GetControls().Add(txtGameY);

            // 計算按鈕
            Button btnCalc = new Button();
            btnCalc.Text = "計算";
            btnCalc.SetLocation(new Point(230, 58));
            btnCalc.Size = new Size(60, 50);
            addS32Form.GetControls().Add(btnCalc);

            // 新增按鈕
            Button btnAdd = new Button();
            btnAdd.Text = "新增";
            btnAdd.SetLocation(new Point(100, 195));
            btnAdd.Size = new Size(80, 30);
            addS32Form.GetControls().Add(btnAdd);

            // 取消按鈕
            Button btnCancel = new Button();
            btnCancel.Text = "取消";
            btnCancel.SetLocation(new Point(200, 195));
            btnCancel.Size = new Size(80, 30);
            btnCancel.Click += (s, args) => addS32Form.Close();
            addS32Form.GetControls().Add(btnCancel);

            // 計算功能：從遊戲座標計算 BlockX, BlockY
            btnCalc.Click += (s, args) =>
            {
                if (!int.TryParse(txtGameX.Text, out int gameX) ||
                    !int.TryParse(txtGameY.Text, out int gameY))
                {
                    WinFormsMessageBox.Show("請輸入有效的遊戲座標", "錯誤", MessageBoxButtons.OK, MessageBoxIcon.Error);
                    return;
                }

                // 從遊戲座標計算 BlockX, BlockY
                // 公式來自 L1MapSeg: nLinEndX = (nBlockX - 0x7fff) * 64 + 0x7fff
                // 反推: nBlockX = (nLinEndX - 0x7fff) / 64 + 0x7fff
                // 而 nLinEndX = nLinBeginX + 63，所以 nLinBeginX 在某個 block 內時
                // blockX = ((gameX - 0x7fff) / 64) + 0x7fff + (if gameX > 0x7fff then 1 else 0)
                int blockX = ((gameX - 0x7FFF - 1) / 64) + 0x8000;
                int blockY = ((gameY - 0x7FFF - 1) / 64) + 0x8000;

                txtBlockX.Text = blockX.ToString("X4");
                txtBlockY.Text = blockY.ToString("X4");
            };

            // 新增功能
            btnAdd.Click += (s, args) =>
            {
                int blockX, blockY;
                try
                {
                    blockX = Convert.ToInt32(txtBlockX.Text, 16);
                    blockY = Convert.ToInt32(txtBlockY.Text, 16);
                }
                catch
                {
                    WinFormsMessageBox.Show("請輸入有效的 16 進位 BlockX 和 BlockY", "錯誤", MessageBoxButtons.OK, MessageBoxIcon.Error);
                    return;
                }

                // 檢查檔案是否已存在
                string fileName = $"{blockX:X4}{blockY:X4}.s32".ToLower();
                string filePath = Path.Combine(currentMap.szFullDirName, fileName);

                if (File.Exists(filePath))
                {
                    WinFormsMessageBox.Show($"S32 檔案已存在: {fileName}", "錯誤", MessageBoxButtons.OK, MessageBoxIcon.Error);
                    return;
                }

                // 檢查是否已在記憶體中
                if (_document.S32Files.Keys.Any(k => k.EndsWith(fileName, StringComparison.OrdinalIgnoreCase)))
                {
                    WinFormsMessageBox.Show($"S32 檔案已載入: {fileName}", "錯誤", MessageBoxButtons.OK, MessageBoxIcon.Error);
                    return;
                }

                // 確認新增
                var confirmResult = WinFormsMessageBox.Show(
                    $"確定要新增 S32 區塊嗎？\n\n檔案名稱: {fileName}\nBlockX: {blockX:X4}, BlockY: {blockY:X4}\n路徑: {filePath}",
                    "確認新增",
                    MessageBoxButtons.YesNo,
                    MessageBoxIcon.Question);

                if (confirmResult != DialogResult.Yes) return;

                // 創建空的 S32 資料
                S32Data newS32Data = CreateEmptyS32Data(blockX, blockY, filePath);

                // 創建 SegInfo
                Struct.L1MapSeg segInfo = new Struct.L1MapSeg(blockX, blockY, true);
                segInfo.isRemastered = false;
                segInfo.nMapMinBlockX = currentMap.nMinBlockX;
                segInfo.nMapMinBlockY = currentMap.nMinBlockY;
                segInfo.nMapBlockCountX = currentMap.nBlockCountX;

                newS32Data.SegInfo = segInfo;
                newS32Data.IsModified = true;

                // 加入到記憶體（先加入才能用 SaveS32File）
                _document.S32Files[filePath] = newS32Data;

                // 寫入檔案
                try
                {
                    SaveS32File(filePath);  // 使用正確格式的保存方法
                }
                catch (Exception ex)
                {
                    // 移除失敗的 S32
                    _document.S32Files.Remove(filePath);
                    WinFormsMessageBox.Show($"寫入檔案失敗: {ex.Message}", "錯誤", MessageBoxButtons.OK, MessageBoxIcon.Error);
                    return;
                }

                // 加入到 FullFileNameList
                currentMap.FullFileNameList[filePath] = segInfo;

                // 更新地圖邊界（如果新的 S32 超出現有邊界）
                if (blockX < currentMap.nMinBlockX || blockX > currentMap.nMaxBlockX ||
                    blockY < currentMap.nMinBlockY || blockY > currentMap.nMaxBlockY)
                {
                    currentMap.nMinBlockX = Math.Min(currentMap.nMinBlockX, blockX);
                    currentMap.nMinBlockY = Math.Min(currentMap.nMinBlockY, blockY);
                    currentMap.nMaxBlockX = Math.Max(currentMap.nMaxBlockX, blockX);
                    currentMap.nMaxBlockY = Math.Max(currentMap.nMaxBlockY, blockY);
                    currentMap.nBlockCountX = currentMap.nMaxBlockX - currentMap.nMinBlockX + 1;
                    currentMap.nBlockCountY = currentMap.nMaxBlockY - currentMap.nMinBlockY + 1;
                    currentMap.nLinLengthX = currentMap.nBlockCountX * 64;
                    currentMap.nLinLengthY = currentMap.nBlockCountY * 64;
                    currentMap.nLinEndX = (currentMap.nMaxBlockX - 0x7FFF) * 64 + 0x7FFF;
                    currentMap.nLinEndY = (currentMap.nMaxBlockY - 0x7FFF) * 64 + 0x7FFF;
                    currentMap.nLinBeginX = currentMap.nLinEndX - currentMap.nLinLengthX + 1;
                    currentMap.nLinBeginY = currentMap.nLinEndY - currentMap.nLinLengthY + 1;

                    // 更新所有 SegInfo 的共享值
                    foreach (var seg in currentMap.FullFileNameList.Values)
                    {
                        seg.nMapMinBlockX = currentMap.nMinBlockX;
                        seg.nMapMinBlockY = currentMap.nMinBlockY;
                        seg.nMapBlockCountX = currentMap.nBlockCountX;
                    }
                }

                // 加入到 UI 清單
                string displayName = $"{fileName} ({blockX:X4},{blockY:X4}) [{segInfo.nLinBeginX},{segInfo.nLinBeginY}~{segInfo.nLinEndX},{segInfo.nLinEndY}]";
                S32FileItem item = new S32FileItem
                {
                    FilePath = filePath,
                    DisplayName = displayName,
                    SegInfo = segInfo,
                    IsChecked = true
                };
                // 重新載入地圖（重新讀取所有 S32 檔案）
                ReloadCurrentMap();

                WinFormsMessageBox.Show($"S32 區塊已新增！\n\n檔案: {fileName}", "完成", MessageBoxButtons.OK, MessageBoxIcon.Information);
                this.toolStripStatusLabel1.Text = $"已新增 S32: {fileName}";
                addS32Form.Close();
            };

            addS32Form.ShowDialog(this);
        }

        // 創建空的 S32 資料
        private S32Data CreateEmptyS32Data(int blockX, int blockY, string filePath)
        {
            S32Data s32Data = new S32Data();
            s32Data.FilePath = filePath;

            // 初始化 Layer1（128x64 的格子，全部設為空白）
            s32Data.Layer1 = new TileCell[64, 128];
            for (int y = 0; y < 64; y++)
            {
                for (int x = 0; x < 128; x++)
                {
                    s32Data.Layer1[y, x] = new TileCell
                    {
                        X = x,
                        Y = y,
                        TileId = 0,
                        IndexId = 0,
                        IsModified = false
                    };
                }
            }

            // 初始化 Layer2（空的）
            s32Data.Layer2 = new List<Layer2Item>();

            // 初始化 Layer3（64x64 的屬性，全部設為可通行）
            s32Data.Layer3 = new MapAttribute[64, 64];
            for (int y = 0; y < 64; y++)
            {
                for (int x = 0; x < 64; x++)
                {
                    s32Data.Layer3[y, x] = new MapAttribute { Attribute1 = 0, Attribute2 = 0 }; // 預設可通行
                }
            }

            // 初始化 Layer4（物件列表，空的）
            s32Data.Layer4 = new List<ObjectTile>();

            // 初始化 Layer5-8
            s32Data.Layer5 = new List<Layer5Item>();
            s32Data.Layer6 = new List<int>();
            s32Data.Layer7 = new List<Layer7Item>();
            s32Data.Layer8 = new List<Layer8Item>();

            // 初始化其他欄位
            s32Data.UsedTiles = new Dictionary<int, TileInfo>();
            s32Data.OriginalFileData = new byte[0];
            s32Data.Layer1Offset = 0;
            s32Data.Layer2Offset = 0;
            s32Data.Layer3Offset = 0;
            s32Data.Layer4Offset = 0;
            s32Data.Layer4EndOffset = 0;
            s32Data.Layer5to8Data = new byte[0];
            s32Data.IsModified = true;

            return s32Data;
        }

        /// <summary>
        /// 顯示自動關閉的訊息視窗
        /// </summary>
        /// <param name="message">訊息內容</param>
        /// <param name="title">視窗標題</param>
        /// <param name="seconds">自動關閉秒數</param>
        private void ShowAutoCloseMessage(string message, string title, int seconds = 3)
        {
            var form = new Form
            {
                Text = title,
                Size = new Size(400, 150),
                FormBorderStyle = FormBorderStyle.FixedDialog,
                StartPosition = FormStartPosition.CenterParent,
                MaximizeBox = false,
                MinimizeBox = false,
                ShowInTaskbar = false
            };

            var label = new Label
            {
                Text = message,
                AutoSize = false,
                TextAlign = ContentAlignment.MiddleCenter,
                Dock = DockStyle.Fill,
                Font = new Font(Eto.Drawing.SystemFonts.Default().Family, 10f)
            };
            form.GetControls().Add(label);

            var timer = new Timer { Interval = seconds * 1000 };
            timer.Tick += (s, e) =>
            {
                timer.Stop();
                timer.Dispose();
                form.Close();
            };
            timer.Start();

            form.ShowDialog(this);
        }

        private void discordToolStripMenuItem_Click(object sender, EventArgs e)
        {
            System.Diagnostics.Process.Start(new System.Diagnostics.ProcessStartInfo
            {
                FileName = "https://discord.gg/vjSKGD95HB",
                UseShellExecute = true
            });
        }

        #region 批次刪除 Tile

        private void batchDeleteTileToolStripMenuItem_Click(object sender, EventArgs e)
        {
            // 檢查是否已載入客戶端
            if (Share.MapDataList == null || Share.MapDataList.Count == 0)
            {
                WinFormsMessageBox.Show(
                    LocalizationManager.L("BatchDeleteTile_NoClient"),
                    LocalizationManager.L("Warning"),
                    MessageBoxButtons.OK,
                    MessageBoxIcon.Warning);
                return;
            }

            bool hasCurrentMap = _document != null && !string.IsNullOrEmpty(_document.MapId);

            using (var dialog = new L1MapViewer.Forms.BatchDeleteTileDialog(hasCurrentMap))
            {
                if (dialog.ShowDialog(this) != DialogResult.Ok)
                    return;

                BatchDeleteTiles(
                    dialog.TileIdStart,
                    dialog.TileIdEnd,
                    dialog.IndexIdStart,
                    dialog.IndexIdEnd,
                    dialog.ProcessAllMaps);
            }
        }

        private void BatchDeleteTiles(int tileIdStart, int tileIdEnd, int indexIdStart, int indexIdEnd, bool processAllMaps)
        {
            var s32FilesToProcess = new List<string>();

            if (processAllMaps)
            {
                // 收集所有地圖的 S32 檔案
                foreach (var mapEntry in Share.MapDataList)
                {
                    foreach (var fileEntry in mapEntry.Value.FullFileNameList)
                    {
                        if (fileEntry.Value.isS32 && File.Exists(fileEntry.Key))
                        {
                            s32FilesToProcess.Add(fileEntry.Key);
                        }
                    }
                }
            }
            else
            {
                // 只處理當前地圖的 S32 檔案
                if (_document == null || string.IsNullOrEmpty(_document.MapId))
                {
                    WinFormsMessageBox.Show(
                        LocalizationManager.L("BatchDeleteTile_NoMapLoaded"),
                        LocalizationManager.L("Warning"),
                        MessageBoxButtons.OK,
                        MessageBoxIcon.Warning);
                    return;
                }

                foreach (var s32Data in _document.S32Files.Values)
                {
                    if (!string.IsNullOrEmpty(s32Data.FilePath) && File.Exists(s32Data.FilePath))
                    {
                        s32FilesToProcess.Add(s32Data.FilePath);
                    }
                }
            }

            if (s32FilesToProcess.Count == 0)
            {
                WinFormsMessageBox.Show(
                    LocalizationManager.L("BatchDeleteTile_NoS32Files"),
                    LocalizationManager.L("Warning"),
                    MessageBoxButtons.OK,
                    MessageBoxIcon.Warning);
                return;
            }

            // 開始處理
            Utils.ShowProgressBar(true, this);
            int totalDeleted = 0;
            int filesModified = 0;
            int filesFailed = 0;

            for (int i = 0; i < s32FilesToProcess.Count; i++)
            {
                string filePath = s32FilesToProcess[i];
                string fileName = Path.GetFileName(filePath);

                this.toolStripStatusLabel1.Text = string.Format(
                    LocalizationManager.L("BatchDeleteTile_Processing"),
                    fileName, i + 1, s32FilesToProcess.Count);
                toolStripProgressBar1.Value = (int)((i + 1) * 100.0 / s32FilesToProcess.Count);
                ApplicationHelper.DoEvents();

                try
                {
                    var s32Data = S32Parser.ParseFile(filePath);
                    if (s32Data == null) continue;

                    int deletedInFile = DeleteTilesFromS32(s32Data, tileIdStart, tileIdEnd, indexIdStart, indexIdEnd);

                    if (deletedInFile > 0)
                    {
                        // 寫回檔案
                        byte[] newData = S32Writer.ToBytes(s32Data);
                        File.WriteAllBytes(filePath, newData);
                        totalDeleted += deletedInFile;
                        filesModified++;
                    }
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"[BatchDeleteTiles] 處理 {fileName} 失敗: {ex.Message}");
                    filesFailed++;
                }
            }

            Utils.ShowProgressBar(false, this);

            // 顯示結果
            string resultMessage = string.Format(
                LocalizationManager.L("BatchDeleteTile_Result"),
                totalDeleted, filesModified, filesFailed);

            this.toolStripStatusLabel1.Text = resultMessage;

            WinFormsMessageBox.Show(
                resultMessage,
                LocalizationManager.L("BatchDeleteTile_Complete"),
                MessageBoxButtons.OK,
                MessageBoxIcon.Information);

            // 如果修改了當前地圖，重新載入
            if (!processAllMaps && filesModified > 0 && _document != null)
            {
                ReloadCurrentMap();
            }
        }

        private int DeleteTilesFromS32(S32Data s32Data, int tileIdStart, int tileIdEnd, int indexIdStart, int indexIdEnd)
        {
            int deletedCount = 0;

            // 刪除 Layer1 中符合條件的 Tile
            for (int y = 0; y < 64; y++)
            {
                for (int x = 0; x < 128; x++)
                {
                    var cell = s32Data.Layer1[y, x];
                    if (cell != null &&
                        cell.TileId >= tileIdStart && cell.TileId <= tileIdEnd &&
                        cell.IndexId >= indexIdStart && cell.IndexId <= indexIdEnd)
                    {
                        cell.TileId = 0;
                        cell.IndexId = 0;
                        deletedCount++;
                    }
                }
            }

            // 刪除 Layer2 中符合條件的項目
            int layer2Removed = s32Data.Layer2.RemoveAll(item =>
                item.TileId >= tileIdStart && item.TileId <= tileIdEnd &&
                item.IndexId >= indexIdStart && item.IndexId <= indexIdEnd);
            deletedCount += layer2Removed;

            // 刪除 Layer4 中符合條件的物件
            int layer4Removed = s32Data.Layer4.RemoveAll(obj =>
                obj.TileId >= tileIdStart && obj.TileId <= tileIdEnd &&
                obj.IndexId >= indexIdStart && obj.IndexId <= indexIdEnd);
            deletedCount += layer4Removed;

            return deletedCount;
        }

        #endregion
    }

    /// <summary>
    /// ListView 欄位排序器
    /// </summary>
    public class ListViewColumnSorter : System.Collections.IComparer
    {
        private int _column;
        private bool _ascending;

        public ListViewColumnSorter(int column, bool ascending)
        {
            _column = column;
            _ascending = ascending;
        }

        public int Compare(object x, object y)
        {
            ListViewItem itemX = x as ListViewItem;
            ListViewItem itemY = y as ListViewItem;
            if (itemX == null || itemY == null) return 0;

            string textX = _column < itemX.SubItems.Count ? itemX.SubItems[_column].Text : "";
            string textY = _column < itemY.SubItems.Count ? itemY.SubItems[_column].Text : "";

            int result;
            // 嘗試數字比較
            if (int.TryParse(textX, out int numX) && int.TryParse(textY, out int numY))
            {
                result = numX.CompareTo(numY);
            }
            else
            {
                result = string.Compare(textX, textY, StringComparison.OrdinalIgnoreCase);
            }

            return _ascending ? result : -result;
        }
    }
}
